; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\Obj\guialloc.o --depend=.\Obj\guialloc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\BaseDrive -I..\Ucosii -I..\Ucosii\Port -I..\Ucosii\Src -I..\Ucosii\Include -I..\Ucgui -I..\Ucgui\Config -I..\Ucgui\GUI_X -I..\Ucgui\GUI -I..\Ucgui\GUI\ConvertColor -I..\Ucgui\GUI\ConvertMono -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\LCDDriver -I..\Ucgui\GUI\MultiLayer -I..\Ucgui\GUI\Widget -I..\Ucgui\GUI\WM -I..\ExternalDrive\Lcd -I..\ExternalDrive\Touch -I..\Panel -ID:\Keil\ARM\INC -ID:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\guialloc.crf ..\Ucgui\GUI\Core\GUIAlloc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _Size2LegalSize PROC
;;;135    */
;;;136    static GUI_ALLOC_DATATYPE _Size2LegalSize(GUI_ALLOC_DATATYPE size) {
000000  4601              MOV      r1,r0
;;;137      return (size + ((1 << GUI_BLOCK_ALIGN) - 1)) & ~((1 << GUI_BLOCK_ALIGN) - 1);
000002  1cc8              ADDS     r0,r1,#3
000004  f0200003          BIC      r0,r0,#3
000008  b200              SXTH     r0,r0
;;;138    }
00000a  4770              BX       lr
;;;139      
                          ENDP

                  _GetSize PROC
;;;143    */
;;;144    static GUI_ALLOC_DATATYPE _GetSize(GUI_HMEM  hMem) {
00000c  4601              MOV      r1,r0
;;;145      return aBlock[hMem].Size;
00000e  48ec              LDR      r0,|L1.960|
000010  eb0000c1          ADD      r0,r0,r1,LSL #3
000014  f9b00002          LDRSH    r0,[r0,#2]
;;;146    }
000018  4770              BX       lr
;;;147    
                          ENDP

                  _Free PROC
;;;151    */
;;;152    static void _Free(GUI_HMEM hMem) {
00001a  b530              PUSH     {r4,r5,lr}
;;;153      GUI_ALLOC_DATATYPE Size;
;;;154      GUI_DEBUG_LOG1("\nGUI_ALLOC_Free(%d)", hMem);
;;;155      /* Do some error checking ... */
;;;156      #if GUI_DEBUG_LEVEL>0
;;;157        /* Block not allocated ? */
;;;158        if (aBlock[hMem].Size == 0) {
00001c  49e8              LDR      r1,|L1.960|
00001e  eb0101c0          ADD      r1,r1,r0,LSL #3
000022  8849              LDRH     r1,[r1,#2]
000024  b901              CBNZ     r1,|L1.40|
                  |L1.38|
;;;159          GUI_DEBUG_ERROROUT("GUI_ALLOC_Free(): Invalid hMem");
;;;160          return;
;;;161        }
;;;162      #endif
;;;163      Size = aBlock[hMem].Size;
;;;164      #ifdef WIN32
;;;165        GUI_MEMSET(&GUI_Heap.abHeap[aBlock[hMem].Off], 0xcc, Size);
;;;166      #endif
;;;167      GUI_ALLOC.NumFreeBytes += Size;
;;;168      GUI_ALLOC.NumUsedBytes -= Size;
;;;169      aBlock[hMem].Size = 0;
;;;170      {
;;;171        int Next = aBlock[hMem].Next;
;;;172        int Prev = aBlock[hMem].Prev;
;;;173        aBlock[Prev].Next = Next;
;;;174        if (Next) {
;;;175          aBlock[Next].Prev = Prev;
;;;176        }
;;;177      }  
;;;178      GUI_ALLOC.NumFreeBlocks++;
;;;179      GUI_ALLOC.NumUsedBlocks--;
;;;180    }
000026  bd30              POP      {r4,r5,pc}
                  |L1.40|
000028  49e5              LDR      r1,|L1.960|
00002a  eb0101c0          ADD      r1,r1,r0,LSL #3       ;163
00002e  f9b12002          LDRSH    r2,[r1,#2]            ;163
000032  49e4              LDR      r1,|L1.964|
000034  89c9              LDRH     r1,[r1,#0xe]          ;167  ; GUI_ALLOC
000036  4411              ADD      r1,r1,r2              ;167
000038  b209              SXTH     r1,r1                 ;167
00003a  4be2              LDR      r3,|L1.964|
00003c  81d9              STRH     r1,[r3,#0xe]          ;167
00003e  4619              MOV      r1,r3                 ;168
000040  8989              LDRH     r1,[r1,#0xc]          ;168  ; GUI_ALLOC
000042  1a89              SUBS     r1,r1,r2              ;168
000044  b209              SXTH     r1,r1                 ;168
000046  8199              STRH     r1,[r3,#0xc]          ;168
000048  2100              MOVS     r1,#0                 ;169
00004a  4bdd              LDR      r3,|L1.960|
00004c  eb0303c0          ADD      r3,r3,r0,LSL #3       ;169
000050  8059              STRH     r1,[r3,#2]            ;169
000052  4cdb              LDR      r4,|L1.960|
000054  eb0404c0          ADD      r4,r4,r0,LSL #3       ;171
000058  88a1              LDRH     r1,[r4,#4]            ;171
00005a  4cd9              LDR      r4,|L1.960|
00005c  eb0404c0          ADD      r4,r4,r0,LSL #3       ;172
000060  88e3              LDRH     r3,[r4,#6]            ;172
000062  4cd7              LDR      r4,|L1.960|
000064  eb0404c3          ADD      r4,r4,r3,LSL #3       ;173
000068  80a1              STRH     r1,[r4,#4]            ;173
00006a  b119              CBZ      r1,|L1.116|
00006c  4dd4              LDR      r5,|L1.960|
00006e  eb0505c1          ADD      r5,r5,r1,LSL #3       ;175
000072  80eb              STRH     r3,[r5,#6]            ;175
                  |L1.116|
000074  49d3              LDR      r1,|L1.964|
000076  6849              LDR      r1,[r1,#4]            ;178  ; GUI_ALLOC
000078  1c49              ADDS     r1,r1,#1              ;178
00007a  4bd2              LDR      r3,|L1.964|
00007c  6059              STR      r1,[r3,#4]            ;178  ; GUI_ALLOC
00007e  4619              MOV      r1,r3                 ;179
000080  6809              LDR      r1,[r1,#0]            ;179  ; GUI_ALLOC
000082  1e49              SUBS     r1,r1,#1              ;179
000084  6019              STR      r1,[r3,#0]            ;179  ; GUI_ALLOC
000086  bf00              NOP      
000088  e7cd              B        |L1.38|
;;;181    
                          ENDP

                  _FindFreeHandle PROC
;;;188    */
;;;189    static GUI_HMEM _FindFreeHandle(void) {
00008a  2101              MOVS     r1,#1
;;;190      int i;
;;;191      for (i=1; i< GUI_MAXBLOCKS; i++) {
00008c  e007              B        |L1.158|
                  |L1.142|
;;;192        if (aBlock[i].Size ==0)
00008e  48cc              LDR      r0,|L1.960|
000090  eb0000c1          ADD      r0,r0,r1,LSL #3
000094  8840              LDRH     r0,[r0,#2]
000096  b908              CBNZ     r0,|L1.156|
;;;193    	  return i;
000098  b208              SXTH     r0,r1
                  |L1.154|
;;;194      }
;;;195      GUI_DEBUG_ERROROUT1("Insufficient memory handles configured (GUI_MAXBLOCKS == %d (See GUIConf.h))", GUI_MAXBLOCKS);
;;;196      return GUI_HMEM_NULL;
;;;197    }
00009a  4770              BX       lr
                  |L1.156|
00009c  1c49              ADDS     r1,r1,#1              ;191
                  |L1.158|
00009e  f5b17fc4          CMP      r1,#0x188             ;191
0000a2  dbf4              BLT      |L1.142|
0000a4  2000              MOVS     r0,#0                 ;196
0000a6  e7f8              B        |L1.154|
;;;198    
                          ENDP

                  _FindHole PROC
;;;206    */
;;;207    static GUI_HMEM _FindHole(GUI_ALLOC_DATATYPE Size) {
0000a8  b530              PUSH     {r4,r5,lr}
0000aa  4602              MOV      r2,r0
;;;208      int i, iNext;
;;;209      for (i=0; (iNext = aBlock[i].Next) != 0; i = iNext) {
0000ac  2100              MOVS     r1,#0
0000ae  e011              B        |L1.212|
                  |L1.176|
;;;210        int NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
0000b0  48c3              LDR      r0,|L1.960|
0000b2  f9300031          LDRSH    r0,[r0,r1,LSL #3]
0000b6  4dc2              LDR      r5,|L1.960|
0000b8  eb0505c1          ADD      r5,r5,r1,LSL #3
0000bc  f9b55002          LDRSH    r5,[r5,#2]
0000c0  4428              ADD      r0,r0,r5
0000c2  4dbf              LDR      r5,|L1.960|
0000c4  f9355033          LDRSH    r5,[r5,r3,LSL #3]
0000c8  1a2c              SUBS     r4,r5,r0
;;;211        if (NumFreeBytes>=Size) {
0000ca  4294              CMP      r4,r2
0000cc  db01              BLT      |L1.210|
;;;212          return i;
0000ce  b208              SXTH     r0,r1
                  |L1.208|
;;;213        }
;;;214      }
;;;215      /* Check last block */
;;;216      if (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size) >= Size) {
;;;217        return i;
;;;218      }
;;;219      return -1;
;;;220    }
0000d0  bd30              POP      {r4,r5,pc}
                  |L1.210|
0000d2  4619              MOV      r1,r3                 ;209
                  |L1.212|
0000d4  48ba              LDR      r0,|L1.960|
0000d6  eb0000c1          ADD      r0,r0,r1,LSL #3       ;209
0000da  8883              LDRH     r3,[r0,#4]            ;209
0000dc  2b00              CMP      r3,#0                 ;209
0000de  d1e7              BNE      |L1.176|
0000e0  48b7              LDR      r0,|L1.960|
0000e2  f9300031          LDRSH    r0,[r0,r1,LSL #3]     ;216
0000e6  4cb6              LDR      r4,|L1.960|
0000e8  eb0404c1          ADD      r4,r4,r1,LSL #3       ;216
0000ec  f9b44002          LDRSH    r4,[r4,#2]            ;216
0000f0  4420              ADD      r0,r0,r4              ;216
0000f2  f24304d4          MOV      r4,#0x30d4            ;216
0000f6  1a20              SUBS     r0,r4,r0              ;216
0000f8  4290              CMP      r0,r2                 ;216
0000fa  db01              BLT      |L1.256|
0000fc  b208              SXTH     r0,r1                 ;217
0000fe  e7e7              B        |L1.208|
                  |L1.256|
000100  f04f30ff          MOV      r0,#0xffffffff        ;219
000104  e7e4              B        |L1.208|
;;;221    
                          ENDP

                  _CreateHole PROC
;;;229    */
;;;230    static GUI_HMEM _CreateHole(GUI_ALLOC_DATATYPE Size) {
000106  e92d47f0          PUSH     {r4-r10,lr}
00010a  4606              MOV      r6,r0
;;;231      int i, iNext;
;;;232      int r = -1;
00010c  f04f39ff          MOV      r9,#0xffffffff
;;;233      for (i=0; (iNext =aBlock[i].Next) !=0; i= iNext) {
000110  2400              MOVS     r4,#0
000112  e038              B        |L1.390|
                  |L1.276|
;;;234        GUI_ALLOC_DATATYPE NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
000114  48aa              LDR      r0,|L1.960|
000116  f8300034          LDRH     r0,[r0,r4,LSL #3]
00011a  49a9              LDR      r1,|L1.960|
00011c  eb0101c4          ADD      r1,r1,r4,LSL #3
000120  8849              LDRH     r1,[r1,#2]
000122  4408              ADD      r0,r0,r1
000124  49a6              LDR      r1,|L1.960|
000126  f8311035          LDRH     r1,[r1,r5,LSL #3]
00012a  1a08              SUBS     r0,r1,r0
00012c  fa0ffa80          SXTH     r10,r0
;;;235        if (NumFreeBytes < Size) {
000130  45b2              CMP      r10,r6
000132  da27              BGE      |L1.388|
;;;236          GUI_ALLOC_DATATYPE NumBytesBeforeBlock = aBlock[iNext].Off - (aBlock[i].Off+aBlock[i].Size);
000134  48a2              LDR      r0,|L1.960|
000136  f8300034          LDRH     r0,[r0,r4,LSL #3]
00013a  49a1              LDR      r1,|L1.960|
00013c  eb0101c4          ADD      r1,r1,r4,LSL #3
000140  8849              LDRH     r1,[r1,#2]
000142  4408              ADD      r0,r0,r1
000144  499e              LDR      r1,|L1.960|
000146  f8311035          LDRH     r1,[r1,r5,LSL #3]
00014a  1a08              SUBS     r0,r1,r0
00014c  b207              SXTH     r7,r0
;;;237          if (NumBytesBeforeBlock) {
00014e  b1c7              CBZ      r7,|L1.386|
;;;238            U8* pData = &GUI_Heap.abHeap[aBlock[iNext].Off];
000150  489b              LDR      r0,|L1.960|
000152  f9300035          LDRSH    r0,[r0,r5,LSL #3]
000156  499c              LDR      r1,|L1.968|
000158  eb000801          ADD      r8,r0,r1
;;;239            memmove(pData-NumBytesBeforeBlock, pData, aBlock[iNext].Size);
00015c  4998              LDR      r1,|L1.960|
00015e  eb0101c5          ADD      r1,r1,r5,LSL #3
000162  f9b12002          LDRSH    r2,[r1,#2]
000166  eba80007          SUB      r0,r8,r7
00016a  4641              MOV      r1,r8
00016c  f7fffffe          BL       __aeabi_memmove
;;;240            aBlock[iNext].Off -=NumBytesBeforeBlock;
000170  4893              LDR      r0,|L1.960|
000172  f8300035          LDRH     r0,[r0,r5,LSL #3]
000176  1bc0              SUBS     r0,r0,r7
000178  b200              SXTH     r0,r0
00017a  4991              LDR      r1,|L1.960|
00017c  f8210035          STRH     r0,[r1,r5,LSL #3]
;;;241          }
000180  bf00              NOP      
                  |L1.386|
;;;242        }
000182  bf00              NOP      
                  |L1.388|
000184  462c              MOV      r4,r5                 ;233
                  |L1.390|
000186  488e              LDR      r0,|L1.960|
000188  eb0000c4          ADD      r0,r0,r4,LSL #3       ;233
00018c  8885              LDRH     r5,[r0,#4]            ;233
00018e  2d00              CMP      r5,#0                 ;233
000190  d1c0              BNE      |L1.276|
;;;243      }
;;;244      /* Check last block */
;;;245      if (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size) >= Size) {
000192  488b              LDR      r0,|L1.960|
000194  f9300034          LDRSH    r0,[r0,r4,LSL #3]
000198  4989              LDR      r1,|L1.960|
00019a  eb0101c4          ADD      r1,r1,r4,LSL #3
00019e  f9b11002          LDRSH    r1,[r1,#2]
0001a2  4408              ADD      r0,r0,r1
0001a4  f24301d4          MOV      r1,#0x30d4
0001a8  1a08              SUBS     r0,r1,r0
0001aa  42b0              CMP      r0,r6
0001ac  db00              BLT      |L1.432|
;;;246        r = i;
0001ae  46a1              MOV      r9,r4
                  |L1.432|
;;;247      }
;;;248      return r;
0001b0  fa0ff089          SXTH     r0,r9
;;;249    }
0001b4  e8bd87f0          POP      {r4-r10,pc}
;;;250    
                          ENDP

                  GUI_ALLOC_Init PROC
;;;323    */
;;;324    void GUI_ALLOC_Init(void) {
0001b8  f2401087          MOV      r0,#0x187
;;;325      GUI_DEBUG_LOG("\nGUI_ALLOC_Init...");
;;;326      GUI_ALLOC.NumFreeBlocksMin = GUI_ALLOC.NumFreeBlocks = GUI_MAXBLOCKS-1;
0001bc  4981              LDR      r1,|L1.964|
0001be  6048              STR      r0,[r1,#4]  ; GUI_ALLOC
0001c0  6088              STR      r0,[r1,#8]  ; GUI_ALLOC
;;;327      GUI_ALLOC.NumFreeBytesMin  = GUI_ALLOC.NumFreeBytes  = GUI_ALLOC_SIZE;
0001c2  f24300d4          MOV      r0,#0x30d4
0001c6  81c8              STRH     r0,[r1,#0xe]
0001c8  8208              STRH     r0,[r1,#0x10]
;;;328      GUI_ALLOC.NumUsedBlocks = 0;
0001ca  2000              MOVS     r0,#0
0001cc  6008              STR      r0,[r1,#0]  ; GUI_ALLOC
;;;329      GUI_ALLOC.NumUsedBytes = 0;
0001ce  8188              STRH     r0,[r1,#0xc]
;;;330      aBlock[0].Size = (1<<GUI_BLOCK_ALIGN);  /* occupy minimum for a block */
0001d0  2004              MOVS     r0,#4
0001d2  497b              LDR      r1,|L1.960|
0001d4  8048              STRH     r0,[r1,#2]
;;;331      aBlock[0].Off  = 0;
0001d6  2000              MOVS     r0,#0
0001d8  8008              STRH     r0,[r1,#0]
;;;332      aBlock[0].Next = 0;
0001da  8088              STRH     r0,[r1,#4]
;;;333      IsInitialized =1;
0001dc  2001              MOVS     r0,#1
0001de  497b              LDR      r1,|L1.972|
0001e0  7008              STRB     r0,[r1,#0]
;;;334    }
0001e2  4770              BX       lr
;;;335    
                          ENDP

                  _CheckInit PROC
;;;254    */
;;;255    static void _CheckInit(void) {
0001e4  b500              PUSH     {lr}
;;;256      if (!IsInitialized) {
0001e6  4879              LDR      r0,|L1.972|
0001e8  7800              LDRB     r0,[r0,#0]  ; IsInitialized
0001ea  b908              CBNZ     r0,|L1.496|
;;;257        GUI_ALLOC_Init();
0001ec  f7fffffe          BL       GUI_ALLOC_Init
                  |L1.496|
;;;258      }
;;;259    }
0001f0  bd00              POP      {pc}
;;;260    
                          ENDP

                  _Alloc PROC
;;;264    */
;;;265    static GUI_HMEM _Alloc(GUI_ALLOC_DATATYPE size) {
0001f2  b570              PUSH     {r4-r6,lr}
0001f4  4606              MOV      r6,r0
;;;266      GUI_HMEM hMemNew, hMemIns;
;;;267      _CheckInit();
0001f6  f7fffffe          BL       _CheckInit
;;;268      size = _Size2LegalSize(size);
0001fa  4630              MOV      r0,r6
0001fc  f7fffffe          BL       _Size2LegalSize
000200  4606              MOV      r6,r0
;;;269      /* Check if memory is available at all ...*/
;;;270      if (size > GUI_ALLOC.NumFreeBytes) {
000202  4870              LDR      r0,|L1.964|
000204  f9b0000e          LDRSH    r0,[r0,#0xe]  ; GUI_ALLOC
000208  42b0              CMP      r0,r6
00020a  da01              BGE      |L1.528|
;;;271        GUI_DEBUG_WARN1("GUI_ALLOC_Alloc: Insufficient memory configured (Trying to alloc % bytes)", size);
;;;272        return 0;
00020c  2000              MOVS     r0,#0
                  |L1.526|
;;;273      }
;;;274      /* Locate free handle */
;;;275      if ((hMemNew = _FindFreeHandle()) == 0)
;;;276        return 0;
;;;277      /* Locate or Create hole of sufficient size */
;;;278      hMemIns = _FindHole(size);
;;;279      #if GUI_ALLOC_AUTDEFRAG
;;;280        if (hMemIns == -1) {
;;;281          hMemIns = _CreateHole(size);
;;;282        }
;;;283      #endif
;;;284      /* Occupy hole */
;;;285      if (hMemIns==-1) {
;;;286        GUI_DEBUG_ERROROUT1("GUI_ALLOC_Alloc: Could not allocate %d bytes",size);
;;;287        return 0;
;;;288    	}
;;;289      {
;;;290        GUI_ALLOC_DATATYPE Off = aBlock[hMemIns].Off + aBlock[hMemIns].Size;
;;;291        int Next = aBlock[hMemIns].Next;
;;;292        aBlock[hMemNew].Size  = size;
;;;293        aBlock[hMemNew].Off   = Off;
;;;294        if ((aBlock[hMemNew].Next  = Next) >0) {
;;;295          aBlock[Next].Prev = hMemNew;  
;;;296        }
;;;297        aBlock[hMemNew].Prev  = hMemIns;
;;;298        aBlock[hMemIns].Next  = hMemNew;
;;;299      }
;;;300      /* Keep track of number of blocks and av. memory */
;;;301      GUI_ALLOC.NumUsedBlocks++;
;;;302      GUI_ALLOC.NumFreeBlocks--;
;;;303      if (GUI_ALLOC.NumFreeBlocksMin > GUI_ALLOC.NumFreeBlocks) {
;;;304        GUI_ALLOC.NumFreeBlocksMin = GUI_ALLOC.NumFreeBlocks;
;;;305      }
;;;306      GUI_ALLOC.NumUsedBytes += size;
;;;307      GUI_ALLOC.NumFreeBytes -= size;
;;;308      if (GUI_ALLOC.NumFreeBytesMin > GUI_ALLOC.NumFreeBytes) {
;;;309        GUI_ALLOC.NumFreeBytesMin = GUI_ALLOC.NumFreeBytes;
;;;310      }
;;;311      return hMemNew;
;;;312    }
00020e  bd70              POP      {r4-r6,pc}
                  |L1.528|
000210  f7fffffe          BL       _FindFreeHandle
000214  0005              MOVS     r5,r0                 ;275
000216  d100              BNE      |L1.538|
000218  e7f9              B        |L1.526|
                  |L1.538|
00021a  4630              MOV      r0,r6                 ;278
00021c  f7fffffe          BL       _FindHole
000220  4604              MOV      r4,r0                 ;278
000222  1c60              ADDS     r0,r4,#1              ;280
000224  d103              BNE      |L1.558|
000226  4630              MOV      r0,r6                 ;281
000228  f7fffffe          BL       _CreateHole
00022c  4604              MOV      r4,r0                 ;281
                  |L1.558|
00022e  1c60              ADDS     r0,r4,#1              ;285
000230  d100              BNE      |L1.564|
000232  e7ec              B        |L1.526|
                  |L1.564|
000234  4a62              LDR      r2,|L1.960|
000236  f8322034          LDRH     r2,[r2,r4,LSL #3]     ;290
00023a  4b61              LDR      r3,|L1.960|
00023c  eb0303c4          ADD      r3,r3,r4,LSL #3       ;290
000240  885b              LDRH     r3,[r3,#2]            ;290
000242  441a              ADD      r2,r2,r3              ;290
000244  b211              SXTH     r1,r2                 ;290
000246  4a5e              LDR      r2,|L1.960|
000248  eb0202c4          ADD      r2,r2,r4,LSL #3       ;291
00024c  8890              LDRH     r0,[r2,#4]            ;291
00024e  4a5c              LDR      r2,|L1.960|
000250  eb0202c5          ADD      r2,r2,r5,LSL #3       ;292
000254  8056              STRH     r6,[r2,#2]            ;292
000256  4a5a              LDR      r2,|L1.960|
000258  f8221035          STRH     r1,[r2,r5,LSL #3]     ;293
00025c  eb0202c5          ADD      r2,r2,r5,LSL #3       ;294
000260  8090              STRH     r0,[r2,#4]            ;294
000262  2800              CMP      r0,#0                 ;294
000264  dd03              BLE      |L1.622|
000266  4b56              LDR      r3,|L1.960|
000268  eb0303c0          ADD      r3,r3,r0,LSL #3       ;295
00026c  80dd              STRH     r5,[r3,#6]            ;295
                  |L1.622|
00026e  4b54              LDR      r3,|L1.960|
000270  eb0303c5          ADD      r3,r3,r5,LSL #3       ;297
000274  80dc              STRH     r4,[r3,#6]            ;297
000276  4b52              LDR      r3,|L1.960|
000278  eb0303c4          ADD      r3,r3,r4,LSL #3       ;298
00027c  809d              STRH     r5,[r3,#4]            ;298
00027e  4851              LDR      r0,|L1.964|
000280  6800              LDR      r0,[r0,#0]            ;301  ; GUI_ALLOC
000282  1c40              ADDS     r0,r0,#1              ;301
000284  494f              LDR      r1,|L1.964|
000286  6008              STR      r0,[r1,#0]            ;301  ; GUI_ALLOC
000288  4608              MOV      r0,r1                 ;302
00028a  6840              LDR      r0,[r0,#4]            ;302  ; GUI_ALLOC
00028c  1e40              SUBS     r0,r0,#1              ;302
00028e  6048              STR      r0,[r1,#4]            ;302  ; GUI_ALLOC
000290  4608              MOV      r0,r1                 ;303
000292  6880              LDR      r0,[r0,#8]            ;303  ; GUI_ALLOC
000294  6849              LDR      r1,[r1,#4]            ;303  ; GUI_ALLOC
000296  4288              CMP      r0,r1                 ;303
000298  dd03              BLE      |L1.674|
00029a  484a              LDR      r0,|L1.964|
00029c  6840              LDR      r0,[r0,#4]            ;304  ; GUI_ALLOC
00029e  4949              LDR      r1,|L1.964|
0002a0  6088              STR      r0,[r1,#8]            ;304  ; GUI_ALLOC
                  |L1.674|
0002a2  4848              LDR      r0,|L1.964|
0002a4  8980              LDRH     r0,[r0,#0xc]          ;306  ; GUI_ALLOC
0002a6  4430              ADD      r0,r0,r6              ;306
0002a8  b200              SXTH     r0,r0                 ;306
0002aa  4946              LDR      r1,|L1.964|
0002ac  8188              STRH     r0,[r1,#0xc]          ;306
0002ae  4608              MOV      r0,r1                 ;307
0002b0  89c0              LDRH     r0,[r0,#0xe]          ;307  ; GUI_ALLOC
0002b2  1b80              SUBS     r0,r0,r6              ;307
0002b4  b200              SXTH     r0,r0                 ;307
0002b6  81c8              STRH     r0,[r1,#0xe]          ;307
0002b8  4608              MOV      r0,r1                 ;308
0002ba  f9b00010          LDRSH    r0,[r0,#0x10]         ;308  ; GUI_ALLOC
0002be  f9b1100e          LDRSH    r1,[r1,#0xe]          ;308  ; GUI_ALLOC
0002c2  4288              CMP      r0,r1                 ;308
0002c4  dd03              BLE      |L1.718|
0002c6  483f              LDR      r0,|L1.964|
0002c8  89c0              LDRH     r0,[r0,#0xe]          ;309  ; GUI_ALLOC
0002ca  493e              LDR      r1,|L1.964|
0002cc  8208              STRH     r0,[r1,#0x10]         ;309
                  |L1.718|
0002ce  4628              MOV      r0,r5                 ;311
0002d0  e79d              B        |L1.526|
;;;313    
                          ENDP

                  GUI_ALLOC_AllocNoInit PROC
;;;339    */
;;;340    GUI_HMEM GUI_ALLOC_AllocNoInit(GUI_ALLOC_DATATYPE Size) {
0002d2  b570              PUSH     {r4-r6,lr}
0002d4  4604              MOV      r4,r0
;;;341      GUI_HMEM hMem;
;;;342      if (Size == 0) {
0002d6  b90c              CBNZ     r4,|L1.732|
;;;343        return (GUI_HMEM)0;
0002d8  2000              MOVS     r0,#0
                  |L1.730|
;;;344      }
;;;345      GUI_LOCK();
;;;346      GUI_DEBUG_LOG2("\nGUI_ALLOC_AllocNoInit... requesting %d, %d avail", Size, GUI_ALLOC.NumFreeBytes);
;;;347      hMem = _Alloc(Size);
;;;348      GUI_DEBUG_LOG1("\nGUI_ALLOC_AllocNoInit : Handle", hMem);
;;;349      GUI_UNLOCK();
;;;350      return hMem;
;;;351    }
0002da  bd70              POP      {r4-r6,pc}
                  |L1.732|
0002dc  f7fffffe          BL       GUI_Lock
0002e0  4620              MOV      r0,r4                 ;347
0002e2  f7fffffe          BL       _Alloc
0002e6  4605              MOV      r5,r0                 ;347
0002e8  f7fffffe          BL       GUI_Unlock
0002ec  4628              MOV      r0,r5                 ;350
0002ee  e7f4              B        |L1.730|
;;;352    
                          ENDP

                  GUI_ALLOC_h2p PROC
;;;356    */
;;;357    void* GUI_ALLOC_h2p(GUI_HMEM  hMem) {
0002f0  4601              MOV      r1,r0
;;;358      GUI_ASSERT_LOCK();
;;;359      #if GUI_DEBUG_LEVEL > 0
;;;360        if (!hMem) {
0002f2  b909              CBNZ     r1,|L1.760|
;;;361          GUI_DEBUG_ERROROUT("\n"__FILE__ " GUI_ALLOC_h2p: illegal argument (0 handle)");
;;;362          return 0;
0002f4  2000              MOVS     r0,#0
                  |L1.758|
;;;363        }
;;;364        if (aBlock[hMem].Size == 0) {
;;;365          GUI_DEBUG_ERROROUT("Dereferencing free block");
;;;366        }
;;;367    
;;;368      #endif
;;;369      return HMEM2PTR(hMem);
;;;370    }
0002f6  4770              BX       lr
                  |L1.760|
0002f8  4831              LDR      r0,|L1.960|
0002fa  f9300031          LDRSH    r0,[r0,r1,LSL #3]     ;369
0002fe  4a32              LDR      r2,|L1.968|
000300  4410              ADD      r0,r0,r2              ;369
000302  e7f8              B        |L1.758|
;;;371    
                          ENDP

                  GUI_ALLOC_GetNumFreeBytes PROC
;;;375    */
;;;376    GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBytes(void) {
000304  b510              PUSH     {r4,lr}
;;;377      _CheckInit();
000306  f7fffffe          BL       _CheckInit
;;;378      return GUI_ALLOC.NumFreeBytes;  
00030a  482e              LDR      r0,|L1.964|
00030c  f9b0000e          LDRSH    r0,[r0,#0xe]  ; GUI_ALLOC
;;;379    }
000310  bd10              POP      {r4,pc}
;;;380    
                          ENDP

                  GUI_ALLOC_GetMaxSize PROC
;;;387    */
;;;388    GUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize(void) {
000312  e92d41f0          PUSH     {r4-r8,lr}
;;;389      GUI_ALLOC_DATATYPE r = 0;
000316  2700              MOVS     r7,#0
;;;390      GUI_ALLOC_DATATYPE NumFreeBytes;
;;;391      int i, iNext;
;;;392    
;;;393      GUI_LOCK();
000318  f7fffffe          BL       GUI_Lock
;;;394      _CheckInit();
00031c  f7fffffe          BL       _CheckInit
;;;395      for (i=0; (iNext =aBlock[i].Next) !=0; i= iNext) {
000320  2500              MOVS     r5,#0
000322  e010              B        |L1.838|
                  |L1.804|
;;;396        NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
000324  4826              LDR      r0,|L1.960|
000326  f8300035          LDRH     r0,[r0,r5,LSL #3]
00032a  4925              LDR      r1,|L1.960|
00032c  eb0101c5          ADD      r1,r1,r5,LSL #3
000330  8849              LDRH     r1,[r1,#2]
000332  4408              ADD      r0,r0,r1
000334  4922              LDR      r1,|L1.960|
000336  f8311036          LDRH     r1,[r1,r6,LSL #3]
00033a  1a08              SUBS     r0,r1,r0
00033c  b204              SXTH     r4,r0
;;;397        if (NumFreeBytes > r) {
00033e  42bc              CMP      r4,r7
000340  dd00              BLE      |L1.836|
;;;398          r = NumFreeBytes;
000342  4627              MOV      r7,r4
                  |L1.836|
000344  4635              MOV      r5,r6                 ;395
                  |L1.838|
000346  481e              LDR      r0,|L1.960|
000348  eb0000c5          ADD      r0,r0,r5,LSL #3       ;395
00034c  8886              LDRH     r6,[r0,#4]            ;395
00034e  2e00              CMP      r6,#0                 ;395
000350  d1e8              BNE      |L1.804|
;;;399        }
;;;400      }
;;;401      /* Check last block */
;;;402      NumFreeBytes = (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size));
000352  481b              LDR      r0,|L1.960|
000354  f8300035          LDRH     r0,[r0,r5,LSL #3]
000358  4919              LDR      r1,|L1.960|
00035a  eb0101c5          ADD      r1,r1,r5,LSL #3
00035e  8849              LDRH     r1,[r1,#2]
000360  4408              ADD      r0,r0,r1
000362  f24301d4          MOV      r1,#0x30d4
000366  1a08              SUBS     r0,r1,r0
000368  b204              SXTH     r4,r0
;;;403      if (NumFreeBytes > r) {
00036a  42bc              CMP      r4,r7
00036c  dd00              BLE      |L1.880|
;;;404        r = NumFreeBytes;
00036e  4627              MOV      r7,r4
                  |L1.880|
;;;405      }
;;;406      GUI_UNLOCK();
000370  f7fffffe          BL       GUI_Unlock
;;;407      return r;
000374  4638              MOV      r0,r7
;;;408    }
000376  e8bd81f0          POP      {r4-r8,pc}
;;;409    
                          ENDP

                  GUI_ALLOC_GetSize PROC
;;;509    */
;;;510    GUI_ALLOC_DATATYPE GUI_ALLOC_GetSize(GUI_HMEM  hMem) {
00037a  b510              PUSH     {r4,lr}
00037c  4604              MOV      r4,r0
;;;511      /* Do the error checking first */
;;;512      #if GUI_DEBUG_LEVEL>0
;;;513        if (!hMem) {
00037e  b90c              CBNZ     r4,|L1.900|
;;;514          GUI_DEBUG_ERROROUT("\n"__FILE__ " GUI_ALLOC_h2p: illegal argument (0 handle)");
;;;515          return 0;
000380  2000              MOVS     r0,#0
                  |L1.898|
;;;516        }
;;;517      #endif
;;;518      return _GetSize(hMem);
;;;519    }
000382  bd10              POP      {r4,pc}
                  |L1.900|
000384  4620              MOV      r0,r4                 ;518
000386  f7fffffe          BL       _GetSize
00038a  e7fa              B        |L1.898|
;;;520    
                          ENDP

                  GUI_ALLOC_Free PROC
;;;524    */
;;;525    void GUI_ALLOC_Free(GUI_HMEM hMem) {
00038c  b510              PUSH     {r4,lr}
00038e  4604              MOV      r4,r0
;;;526      if (hMem == GUI_HMEM_NULL) { /* Note: This is not an error, it is permitted */
000390  b904              CBNZ     r4,|L1.916|
                  |L1.914|
;;;527        return;
;;;528      }
;;;529      GUI_LOCK();
;;;530      GUI_DEBUG_LOG1("\nGUI_ALLOC_Free(%d)", hMem);
;;;531      _Free(hMem);
;;;532      GUI_UNLOCK();
;;;533    }
000392  bd10              POP      {r4,pc}
                  |L1.916|
000394  f7fffffe          BL       GUI_Lock
000398  4620              MOV      r0,r4                 ;531
00039a  f7fffffe          BL       _Free
00039e  f7fffffe          BL       GUI_Unlock
0003a2  bf00              NOP      
0003a4  e7f5              B        |L1.914|
;;;534    
                          ENDP

                  GUI_ALLOC_FreePtr PROC
;;;539    */
;;;540    void GUI_ALLOC_FreePtr(GUI_HMEM *ph) {
0003a6  b510              PUSH     {r4,lr}
0003a8  4604              MOV      r4,r0
;;;541      GUI_LOCK();
0003aa  f7fffffe          BL       GUI_Lock
;;;542      GUI_ALLOC_Free(*ph);
0003ae  f9b40000          LDRSH    r0,[r4,#0]
0003b2  f7fffffe          BL       GUI_ALLOC_Free
;;;543      *ph =0;
0003b6  2000              MOVS     r0,#0
0003b8  8020              STRH     r0,[r4,#0]
;;;544      GUI_UNLOCK();
0003ba  f7fffffe          BL       GUI_Unlock
;;;545    }
0003be  bd10              POP      {r4,pc}
;;;546    
                          ENDP

                  |L1.960|
                          DCD      aBlock
                  |L1.964|
                          DCD      GUI_ALLOC
                  |L1.968|
                          DCD      GUI_Heap
                  |L1.972|
                          DCD      IsInitialized

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  GUI_Heap
                          %        12500
                  aBlock
                          %        3136
                  GUI_ALLOC
                          %        20

                          AREA ||.data||, DATA, ALIGN=0

                  IsInitialized
000000  00                DCB      0x00
