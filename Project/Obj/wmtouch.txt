; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\Obj\wmtouch.o --depend=.\Obj\wmtouch.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\BaseDrive -I..\Ucosii -I..\Ucosii\Port -I..\Ucosii\Src -I..\Ucosii\Include -I..\Ucgui -I..\Ucgui\Config -I..\Ucgui\GUI_X -I..\Ucgui\GUI -I..\Ucgui\GUI\ConvertColor -I..\Ucgui\GUI\ConvertMono -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\LCDDriver -I..\Ucgui\GUI\MultiLayer -I..\Ucgui\GUI\Widget -I..\Ucgui\GUI\WM -I..\ExternalDrive\Lcd -I..\ExternalDrive\Touch -I..\Panel -ID:\Keil\ARM\INC -ID:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\wmtouch.crf ..\Ucgui\GUI\WM\WMTouch.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  WM__IsInModalArea PROC
;;;45     */
;;;46     int WM__IsInModalArea(WM_HWIN hWin) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;47       if ((WM__CHWinModal.hWin == 0) || WM__IsAncestor(hWin, WM__CHWinModal.hWin) || (hWin == WM__CHWinModal.hWin)) {
000004  4884              LDR      r0,|L1.536|
000006  8880              LDRH     r0,[r0,#4]  ; WM__CHWinModal
000008  b158              CBZ      r0,|L1.34|
00000a  4883              LDR      r0,|L1.536|
00000c  f9b01004          LDRSH    r1,[r0,#4]  ; WM__CHWinModal
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       WM__IsAncestor
000016  b920              CBNZ     r0,|L1.34|
000018  487f              LDR      r0,|L1.536|
00001a  f9b00004          LDRSH    r0,[r0,#4]  ; WM__CHWinModal
00001e  42a0              CMP      r0,r4
000020  d101              BNE      |L1.38|
                  |L1.34|
;;;48         return 1;
000022  2001              MOVS     r0,#1
                  |L1.36|
;;;49       }
;;;50       return 0;
;;;51     }
000024  bd10              POP      {r4,pc}
                  |L1.38|
000026  2000              MOVS     r0,#0                 ;50
000028  e7fc              B        |L1.36|
;;;52     
                          ENDP

                  WM__SendPIDMessage PROC
;;;62     */
;;;63     void WM__SendPIDMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
00002a  b53e              PUSH     {r1-r5,lr}
00002c  4604              MOV      r4,r0
00002e  460d              MOV      r5,r1
;;;64       WM_MESSAGE Msg;
;;;65       /* Send message to the affected window */
;;;66       Msg = *pMsg;                 /* Save message as it may be modified in callback (as return value) */
000030  e8950007          LDM      r5,{r0-r2}
000034  e88d0007          STM      sp,{r0-r2}
;;;67       WM__SendMessageIfEnabled(hWin, &Msg);
000038  4669              MOV      r1,sp
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       WM__SendMessageIfEnabled
;;;68       /* Send notification to all ancestors.
;;;69          We need to check if the window which has received the last message still exists,
;;;70          since it may have deleted itself and its parent as result of the message.
;;;71       */
;;;72       Msg.hWinSrc = hWin;
000040  f8ad4006          STRH     r4,[sp,#6]
;;;73       Msg.MsgId   = WM_TOUCH_CHILD;
000044  200d              MOVS     r0,#0xd
000046  9000              STR      r0,[sp,#0]
;;;74       while (WM_IsWindow(hWin)) {
000048  e009              B        |L1.94|
                  |L1.74|
;;;75         hWin = WM_GetParent(hWin);
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       WM_GetParent
000050  4604              MOV      r4,r0
;;;76         if (hWin) {
000052  b124              CBZ      r4,|L1.94|
;;;77           Msg.Data.p  = pMsg;            /* Needs to be set for each window, as callback is allowed to modify it */
000054  9502              STR      r5,[sp,#8]
;;;78           WM__SendMessageIfEnabled(hWin, &Msg);    /* Send message to the ancestors */
000056  4669              MOV      r1,sp
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       WM__SendMessageIfEnabled
                  |L1.94|
00005e  4620              MOV      r0,r4                 ;74
000060  f7fffffe          BL       WM_IsWindow
000064  2800              CMP      r0,#0                 ;74
000066  d1f0              BNE      |L1.74|
;;;79         }
;;;80       }
;;;81     }
000068  bd3e              POP      {r1-r5,pc}
;;;82     
                          ENDP

                  WM__SendTouchMessage PROC
;;;86     */
;;;87     void WM__SendTouchMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
00006a  e92d41f0          PUSH     {r4-r8,lr}
00006e  4607              MOV      r7,r0
000070  460d              MOV      r5,r1
;;;88       GUI_PID_STATE* pState;
;;;89       pState     = (GUI_PID_STATE*)pMsg->Data.p;
000072  68ac              LDR      r4,[r5,#8]
;;;90       if (pState) {
000074  b174              CBZ      r4,|L1.148|
;;;91         WM_Obj* pWin;
;;;92         pWin       = WM_H2P(hWin);
000076  4638              MOV      r0,r7
000078  f7fffffe          BL       GUI_ALLOC_h2p
00007c  4606              MOV      r6,r0
;;;93         pState->x -= pWin->Rect.x0;
00007e  f9b61000          LDRSH    r1,[r6,#0]
000082  6820              LDR      r0,[r4,#0]
000084  1a40              SUBS     r0,r0,r1
000086  6020              STR      r0,[r4,#0]
;;;94         pState->y -= pWin->Rect.y0;
000088  f9b61002          LDRSH    r1,[r6,#2]
00008c  6860              LDR      r0,[r4,#4]
00008e  1a40              SUBS     r0,r0,r1
000090  6060              STR      r0,[r4,#4]
;;;95       }
000092  bf00              NOP      
                  |L1.148|
;;;96       WM__SendPIDMessage(hWin, pMsg);
000094  4629              MOV      r1,r5
000096  4638              MOV      r0,r7
000098  f7fffffe          BL       WM__SendPIDMessage
;;;97     }
00009c  e8bd81f0          POP      {r4-r8,pc}
;;;98     
                          ENDP

                  _Screen2Win PROC
;;;108    */
;;;109    static WM_HWIN _Screen2Win(GUI_PID_STATE* pState) {
0000a0  b510              PUSH     {r4,lr}
0000a2  4604              MOV      r4,r0
;;;110      if (WM__hCapture == 0) {
0000a4  485d              LDR      r0,|L1.540|
0000a6  8800              LDRH     r0,[r0,#0]  ; WM__hCapture
0000a8  b920              CBNZ     r0,|L1.180|
;;;111        return WM_Screen2hWin(pState->x, pState->y);
0000aa  e9d40100          LDRD     r0,r1,[r4,#0]
0000ae  f7fffffe          BL       WM_Screen2hWin
                  |L1.178|
;;;112      } 
;;;113      return WM__hCapture;
;;;114    }
0000b2  bd10              POP      {r4,pc}
                  |L1.180|
0000b4  4859              LDR      r0,|L1.540|
0000b6  f9b00000          LDRSH    r0,[r0,#0]            ;113  ; WM__hCapture
0000ba  e7fa              B        |L1.178|
;;;115    
                          ENDP

                  WM_HandlePID PROC
;;;132    */
;;;133    int WM_HandlePID(void) {
0000bc  b530              PUSH     {r4,r5,lr}
0000be  b08f              SUB      sp,sp,#0x3c
;;;134      int r = 0;
0000c0  2500              MOVS     r5,#0
;;;135      WM_MESSAGE Msg;
;;;136      WM_CRITICAL_HANDLE CHWin;
;;;137      GUI_PID_STATE State, StateNew;
;;;138      GUI_PID_GetState(&StateNew);
0000c2  a804              ADD      r0,sp,#0x10
0000c4  f7fffffe          BL       GUI_PID_GetState
;;;139      WM_LOCK();
0000c8  f7fffffe          BL       GUI_Lock
;;;140      WM__AddCriticalHandle(&CHWin);
0000cc  a80a              ADD      r0,sp,#0x28
0000ce  f7fffffe          BL       WM__AddCriticalHandle
;;;141      if ((WM_PID__StateLast.x != StateNew.x) || (WM_PID__StateLast.y != StateNew.y) || (WM_PID__StateLast.Pressed != StateNew.Pressed)) {
0000d2  4853              LDR      r0,|L1.544|
0000d4  6800              LDR      r0,[r0,#0]  ; WM_PID__StateLast
0000d6  9904              LDR      r1,[sp,#0x10]
0000d8  4288              CMP      r0,r1
0000da  d10a              BNE      |L1.242|
0000dc  4850              LDR      r0,|L1.544|
0000de  6840              LDR      r0,[r0,#4]  ; WM_PID__StateLast
0000e0  9905              LDR      r1,[sp,#0x14]
0000e2  4288              CMP      r0,r1
0000e4  d105              BNE      |L1.242|
0000e6  484e              LDR      r0,|L1.544|
0000e8  7a00              LDRB     r0,[r0,#8]  ; WM_PID__StateLast
0000ea  f89d1018          LDRB     r1,[sp,#0x18]
0000ee  4288              CMP      r0,r1
0000f0  d075              BEQ      |L1.478|
                  |L1.242|
;;;142        #if GUI_SUPPORT_CURSOR
;;;143          GUI_CURSOR_SetPosition(StateNew.x, StateNew.y);
0000f2  e9dd0104          LDRD     r0,r1,[sp,#0x10]
0000f6  f7fffffe          BL       GUI_CURSOR_SetPosition
;;;144        #endif
;;;145        CHWin.hWin = _Screen2Win(&StateNew);
0000fa  a804              ADD      r0,sp,#0x10
0000fc  f7fffffe          BL       _Screen2Win
000100  f8ad002c          STRH     r0,[sp,#0x2c]
;;;146        if (WM__IsInModalArea(CHWin.hWin)) {
000104  f9bd002c          LDRSH    r0,[sp,#0x2c]
000108  f7fffffe          BL       WM__IsInModalArea
00010c  b3e8              CBZ      r0,|L1.394|
;;;147          /*
;;;148           * Send WM_PID_STATE_CHANGED message if state has changed (just pressed or just released)
;;;149           */
;;;150          if ((WM_PID__StateLast.Pressed != StateNew.Pressed) && CHWin.hWin) {
00010e  4844              LDR      r0,|L1.544|
000110  7a00              LDRB     r0,[r0,#8]  ; WM_PID__StateLast
000112  f89d1018          LDRB     r1,[sp,#0x18]
000116  4288              CMP      r0,r1
000118  d023              BEQ      |L1.354|
00011a  f8bd002c          LDRH     r0,[sp,#0x2c]
00011e  b300              CBZ      r0,|L1.354|
;;;151            WM_PID_STATE_CHANGED_INFO Info;
;;;152            WM_Obj* pWin;
;;;153            pWin = WM_H2P(CHWin.hWin);
000120  f9bd002c          LDRSH    r0,[sp,#0x2c]
000124  f7fffffe          BL       GUI_ALLOC_h2p
000128  4604              MOV      r4,r0
;;;154            Info.State     = StateNew.Pressed;
00012a  f89d0018          LDRB     r0,[sp,#0x18]
00012e  f88d000c          STRB     r0,[sp,#0xc]
;;;155            Info.StatePrev = WM_PID__StateLast.Pressed;
000132  483b              LDR      r0,|L1.544|
000134  7a00              LDRB     r0,[r0,#8]  ; WM_PID__StateLast
000136  f88d000d          STRB     r0,[sp,#0xd]
;;;156            Info.x         = StateNew.x - pWin->Rect.x0;
00013a  f9b41000          LDRSH    r1,[r4,#0]
00013e  9804              LDR      r0,[sp,#0x10]
000140  1a40              SUBS     r0,r0,r1
000142  9001              STR      r0,[sp,#4]
;;;157            Info.y         = StateNew.y - pWin->Rect.y0;
000144  f9b41002          LDRSH    r1,[r4,#2]
000148  9805              LDR      r0,[sp,#0x14]
00014a  1a40              SUBS     r0,r0,r1
00014c  9002              STR      r0,[sp,#8]
;;;158            Msg.Data.p = &Info;
00014e  a801              ADD      r0,sp,#4
000150  900e              STR      r0,[sp,#0x38]
;;;159            Msg.MsgId  = WM_PID_STATE_CHANGED;
000152  2011              MOVS     r0,#0x11
000154  900c              STR      r0,[sp,#0x30]
;;;160            WM__SendMessageIfEnabled(CHWin.hWin, &Msg);
000156  f9bd002c          LDRSH    r0,[sp,#0x2c]
00015a  a90c              ADD      r1,sp,#0x30
00015c  f7fffffe          BL       WM__SendMessageIfEnabled
;;;161          }
000160  bf00              NOP      
                  |L1.354|
;;;162          /*
;;;163           * Send WM_TOUCH message(s)
;;;164           * Note that we may have to send 2 touch messages.
;;;165           */
;;;166          if (WM_PID__StateLast.Pressed | StateNew.Pressed) {    /* Only if pressed or just released */
000162  482f              LDR      r0,|L1.544|
000164  7a00              LDRB     r0,[r0,#8]  ; WM_PID__StateLast
000166  f89d1018          LDRB     r1,[sp,#0x18]
00016a  4308              ORRS     r0,r0,r1
00016c  d047              BEQ      |L1.510|
;;;167            Msg.MsgId = WM_TOUCH;
00016e  200c              MOVS     r0,#0xc
000170  900c              STR      r0,[sp,#0x30]
;;;168            r = 1;
000172  2501              MOVS     r5,#1
;;;169            /*
;;;170             * Tell window if it is no longer pressed
;;;171             * This happens for 2 possible reasons:
;;;172             * a) PID is released
;;;173             * b) PID is moved out
;;;174             */
;;;175            if (WM__CHWinLast.hWin != CHWin.hWin) {
000174  482b              LDR      r0,|L1.548|
000176  f9b00004          LDRSH    r0,[r0,#4]  ; WM__CHWinLast
00017a  f9bd102c          LDRSH    r1,[sp,#0x2c]
00017e  4288              CMP      r0,r1
000180  d01e              BEQ      |L1.448|
;;;176              if (WM__CHWinLast.hWin != 0) {
000182  4828              LDR      r0,|L1.548|
000184  8880              LDRH     r0,[r0,#4]  ; WM__CHWinLast
000186  b1d8              CBZ      r0,|L1.448|
;;;177                if (StateNew.Pressed) {
000188  e000              B        |L1.396|
                  |L1.394|
00018a  e038              B        |L1.510|
                  |L1.396|
00018c  f89d0018          LDRB     r0,[sp,#0x18]
000190  b110              CBZ      r0,|L1.408|
;;;178                  /* Moved out -> no longer in this window
;;;179                   * Send a NULL pointer as data
;;;180                   */
;;;181                  Msg.Data.p = NULL;
000192  2000              MOVS     r0,#0
000194  900e              STR      r0,[sp,#0x38]
000196  e00a              B        |L1.430|
                  |L1.408|
;;;182                } else {
;;;183                  /* Last window needs to know that it has been "Released"
;;;184                   * Send last coordinates 
;;;185                   */
;;;186                  State.x       = WM_PID__StateLast.x;
000198  4821              LDR      r0,|L1.544|
00019a  6800              LDR      r0,[r0,#0]  ; WM_PID__StateLast
00019c  9007              STR      r0,[sp,#0x1c]
;;;187                  State.y       = WM_PID__StateLast.y;
00019e  4820              LDR      r0,|L1.544|
0001a0  6840              LDR      r0,[r0,#4]  ; WM_PID__StateLast
0001a2  9008              STR      r0,[sp,#0x20]
;;;188                  State.Pressed = 0;
0001a4  2000              MOVS     r0,#0
0001a6  f88d0024          STRB     r0,[sp,#0x24]
;;;189                  Msg.Data.p = (void*)&State;
0001aa  a807              ADD      r0,sp,#0x1c
0001ac  900e              STR      r0,[sp,#0x38]
                  |L1.430|
;;;190                }
;;;191                GUI_DEBUG_LOG1 ("\nSending WM_Touch to LastWindow %d (out of area)", WM__CHWinLast.hWin);
;;;192                WM__SendTouchMessage(WM__CHWinLast.hWin, &Msg);
0001ae  491d              LDR      r1,|L1.548|
0001b0  f9b10004          LDRSH    r0,[r1,#4]  ; WM__CHWinLast
0001b4  a90c              ADD      r1,sp,#0x30
0001b6  f7fffffe          BL       WM__SendTouchMessage
;;;193                WM__CHWinLast.hWin = 0;
0001ba  2000              MOVS     r0,#0
0001bc  4919              LDR      r1,|L1.548|
0001be  8088              STRH     r0,[r1,#4]
                  |L1.448|
;;;194              }
;;;195            }
;;;196            /* Sending WM_Touch to current window */
;;;197            if (CHWin.hWin) {
0001c0  f8bd002c          LDRH     r0,[sp,#0x2c]
0001c4  b1d8              CBZ      r0,|L1.510|
;;;198              /* convert screen into window coordinates */
;;;199              State = StateNew;
0001c6  a804              ADD      r0,sp,#0x10
0001c8  c807              LDM      r0,{r0-r2}
0001ca  ab07              ADD      r3,sp,#0x1c
0001cc  c307              STM      r3!,{r0-r2}
;;;200              /* Remember window */
;;;201              if (State.Pressed) {
0001ce  f89d0024          LDRB     r0,[sp,#0x24]
0001d2  b128              CBZ      r0,|L1.480|
;;;202                WM__CHWinLast.hWin = CHWin.hWin;
0001d4  f8bd002c          LDRH     r0,[sp,#0x2c]
0001d8  4912              LDR      r1,|L1.548|
0001da  8088              STRH     r0,[r1,#4]
0001dc  e008              B        |L1.496|
                  |L1.478|
0001de  e012              B        |L1.518|
                  |L1.480|
;;;203              } else {
;;;204                /* Handle automatic capture release */
;;;205                if (WM__CaptureReleaseAuto) {
0001e0  4811              LDR      r0,|L1.552|
0001e2  7800              LDRB     r0,[r0,#0]  ; WM__CaptureReleaseAuto
0001e4  b108              CBZ      r0,|L1.490|
;;;206                  WM_ReleaseCapture();
0001e6  f7fffffe          BL       WM_ReleaseCapture
                  |L1.490|
;;;207                }
;;;208                WM__CHWinLast.hWin = 0;
0001ea  2000              MOVS     r0,#0
0001ec  490d              LDR      r1,|L1.548|
0001ee  8088              STRH     r0,[r1,#4]
                  |L1.496|
;;;209              }
;;;210              Msg.Data.p = (void*)&State;
0001f0  a807              ADD      r0,sp,#0x1c
0001f2  900e              STR      r0,[sp,#0x38]
;;;211              WM__SendTouchMessage(CHWin.hWin, &Msg);
0001f4  f9bd002c          LDRSH    r0,[sp,#0x2c]
0001f8  a90c              ADD      r1,sp,#0x30
0001fa  f7fffffe          BL       WM__SendTouchMessage
                  |L1.510|
;;;212            }
;;;213          }
;;;214          /*
;;;215           * Send WM_MOUSEOVER message
;;;216           */
;;;217          #if GUI_SUPPORT_MOUSE
;;;218          else {
;;;219            /* Send WM_MOUSEOVER Message */
;;;220            if (CHWin.hWin) {
;;;221              /* Do not send messages to disabled windows */
;;;222              if (WM__IsEnabled(CHWin.hWin)) {
;;;223                State      = StateNew;
;;;224                Msg.MsgId  = WM_MOUSEOVER;
;;;225                Msg.Data.p = (void*)&State;
;;;226                WM__SendTouchMessage(CHWin.hWin, &Msg);
;;;227              }
;;;228            }
;;;229          }
;;;230          #endif
;;;231        }
;;;232        /* Store the new state */
;;;233        WM_PID__StateLast = StateNew;
0001fe  4808              LDR      r0,|L1.544|
000200  a904              ADD      r1,sp,#0x10
000202  c90e              LDM      r1,{r1-r3}
000204  c00e              STM      r0!,{r1-r3}
                  |L1.518|
;;;234      }
;;;235      WM__RemoveCriticalHandle(&CHWin);
000206  a80a              ADD      r0,sp,#0x28
000208  f7fffffe          BL       WM__RemoveCriticalHandle
;;;236      WM_UNLOCK();
00020c  f7fffffe          BL       GUI_Unlock
;;;237      return r;
000210  4628              MOV      r0,r5
;;;238    }
000212  b00f              ADD      sp,sp,#0x3c
000214  bd30              POP      {r4,r5,pc}
;;;239    
                          ENDP

000216  0000              DCW      0x0000
                  |L1.536|
                          DCD      WM__CHWinModal
                  |L1.540|
                          DCD      WM__hCapture
                  |L1.544|
                          DCD      WM_PID__StateLast
                  |L1.548|
                          DCD      WM__CHWinLast
                  |L1.552|
                          DCD      WM__CaptureReleaseAuto

                          AREA ||.data||, DATA, ALIGN=2

                  WM__CHWinModal
                          %        8
                  WM__CHWinLast
                          %        8
