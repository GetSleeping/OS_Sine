; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\Obj\wm.o --depend=.\Obj\wm.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\BaseDrive -I..\Ucosii -I..\Ucosii\Port -I..\Ucosii\Src -I..\Ucosii\Include -I..\Ucgui -I..\Ucgui\Config -I..\Ucgui\GUI_X -I..\Ucgui\GUI -I..\Ucgui\GUI\ConvertColor -I..\Ucgui\GUI\ConvertMono -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\LCDDriver -I..\Ucgui\GUI\MultiLayer -I..\Ucgui\GUI\Widget -I..\Ucgui\GUI\WM -I..\ExternalDrive\Lcd -I..\ExternalDrive\Touch -I..\Panel -ID:\Keil\ARM\INC -ID:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\wm.crf ..\Ucgui\GUI\WM\WM.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _CheckCriticalHandles PROC
;;;99     */
;;;100    static void _CheckCriticalHandles(WM_HWIN hWin) {
000000  4601              MOV      r1,r0
;;;101      WM_CRITICAL_HANDLE * pCH;
;;;102      for (pCH = WM__pFirstCriticalHandle; pCH; pCH = pCH->pNext) {
000002  4af7              LDR      r2,|L1.992|
000004  6810              LDR      r0,[r2,#0]  ; WM__pFirstCriticalHandle
000006  e006              B        |L1.22|
                  |L1.8|
;;;103        if (pCH->hWin == hWin) {
000008  f9b02004          LDRSH    r2,[r0,#4]
00000c  428a              CMP      r2,r1
00000e  d101              BNE      |L1.20|
;;;104          pCH->hWin = 0;
000010  2200              MOVS     r2,#0
000012  8082              STRH     r2,[r0,#4]
                  |L1.20|
000014  6800              LDR      r0,[r0,#0]            ;102
                  |L1.22|
000016  2800              CMP      r0,#0                 ;102
000018  d1f6              BNE      |L1.8|
;;;105        }
;;;106      }
;;;107    }
00001a  4770              BX       lr
;;;108    
                          ENDP

                  _DesktopHandle2Index PROC
;;;119    */
;;;120    static int _DesktopHandle2Index(WM_HWIN hDesktop) {
00001c  4601              MOV      r1,r0
;;;121    #if GUI_NUM_LAYERS > 1
;;;122      int i;
;;;123      for (i = 0; i < GUI_NUM_LAYERS; i++) {
;;;124        if (hDesktop == WM__ahDesktopWin[i]) {
;;;125          return i;
;;;126        }
;;;127      }
;;;128    #else
;;;129      if (hDesktop == WM__ahDesktopWin[0]) {
00001e  48f1              LDR      r0,|L1.996|
000020  f9b00000          LDRSH    r0,[r0,#0]  ; WM__ahDesktopWin
000024  4288              CMP      r0,r1
000026  d101              BNE      |L1.44|
;;;130        return 0;
000028  2000              MOVS     r0,#0
                  |L1.42|
;;;131      }
;;;132    #endif
;;;133      return -1;
;;;134    }
00002a  4770              BX       lr
                  |L1.44|
00002c  f04f30ff          MOV      r0,#0xffffffff        ;133
000030  e7fb              B        |L1.42|
;;;135    
                          ENDP

                  WM__RectIsNZ PROC
;;;548    */
;;;549    int WM__RectIsNZ(const GUI_RECT* pr) {
000032  4601              MOV      r1,r0
;;;550      if (pr->x0 > pr->x1)
000034  f9b10000          LDRSH    r0,[r1,#0]
000038  f9b12004          LDRSH    r2,[r1,#4]
00003c  4290              CMP      r0,r2
00003e  dd01              BLE      |L1.68|
;;;551        return 0;
000040  2000              MOVS     r0,#0
                  |L1.66|
;;;552      if (pr->y0 > pr->y1)
;;;553        return 0;
;;;554      return 1;
;;;555    }
000042  4770              BX       lr
                  |L1.68|
000044  f9b10002          LDRSH    r0,[r1,#2]            ;552
000048  f9b12006          LDRSH    r2,[r1,#6]            ;552
00004c  4290              CMP      r0,r2                 ;552
00004e  dd01              BLE      |L1.84|
000050  2000              MOVS     r0,#0                 ;553
000052  e7f6              B        |L1.66|
                  |L1.84|
000054  2001              MOVS     r0,#1                 ;554
000056  e7f4              B        |L1.66|
;;;556    
                          ENDP

                  _Invalidate1Abs PROC
;;;141    */
;;;142    static void _Invalidate1Abs(WM_HWIN hWin, const GUI_RECT*pRect) {
000058  e92d41fc          PUSH     {r2-r8,lr}
00005c  4607              MOV      r7,r0
00005e  460d              MOV      r5,r1
;;;143      GUI_RECT r;
;;;144      WM_Obj* pWin;
;;;145      int Status;
;;;146      pWin = WM_H2P(hWin);
000060  4638              MOV      r0,r7
000062  f7fffffe          BL       GUI_ALLOC_h2p
000066  4604              MOV      r4,r0
;;;147      Status = pWin->Status;
000068  8ba6              LDRH     r6,[r4,#0x1c]
;;;148      if ((Status & WM_SF_ISVIS) == 0) {
00006a  f0160f02          TST      r6,#2
00006e  d101              BNE      |L1.116|
                  |L1.112|
;;;149        return;   /* Window is not visible... we are done */
;;;150      }
;;;151      if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
;;;152        return;   /* Window is transparent; transparency may change... we are done, since background will be invalidated */
;;;153      }
;;;154      if (WM__RectIsNZ(pRect) == 0) {
;;;155        return;   /* Nothing to do ... */
;;;156      }
;;;157      /* Calc affected area */
;;;158      GUI__IntersectRects(&r, pRect, &pWin->Rect);
;;;159      if (WM__RectIsNZ(&r)) {
;;;160        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;161          WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
;;;162        #endif
;;;163    
;;;164        if (pWin->Status & WM_SF_INVALID) {
;;;165          GUI_MergeRect(&pWin->InvalidRect, &pWin->InvalidRect, &r);
;;;166        } else {
;;;167          pWin->InvalidRect = r;
;;;168          pWin->Status |= WM_SF_INVALID;
;;;169          WM__NumInvalidWindows++;
;;;170          /* Optional code: Call external routine to notify that drawing is required */
;;;171          #ifdef GUI_X_REDRAW
;;;172          {
;;;173            GUI_RECT r;
;;;174            r = pWin->Rect;
;;;175            if (WM__ClipAtParentBorders(&r,  hWin)) {
;;;176              GUI_X_REDRAW(); /* Call hook function to signal an invalidation */
;;;177            }
;;;178          }
;;;179          #endif
;;;180          GUI_X_SIGNAL_EVENT();
;;;181        }
;;;182        /* Debug code: shows invalid areas */
;;;183        #if (WM_SUPPORT_DIAG)
;;;184          if (WM__pfShowInvalid) {
;;;185            (WM__pfShowInvalid)(hWin);
;;;186          }
;;;187        #endif
;;;188      }
;;;189    }
000070  e8bd81fc          POP      {r2-r8,pc}
                  |L1.116|
000074  f6400001          MOV      r0,#0x801             ;151
000078  4030              ANDS     r0,r0,r6              ;151
00007a  2801              CMP      r0,#1                 ;151
00007c  d100              BNE      |L1.128|
00007e  e7f7              B        |L1.112|
                  |L1.128|
000080  4628              MOV      r0,r5                 ;154
000082  f7fffffe          BL       WM__RectIsNZ
000086  b900              CBNZ     r0,|L1.138|
000088  e7f2              B        |L1.112|
                  |L1.138|
00008a  4622              MOV      r2,r4                 ;158
00008c  4629              MOV      r1,r5                 ;158
00008e  4668              MOV      r0,sp                 ;158
000090  f7fffffe          BL       GUI__IntersectRects
000094  4668              MOV      r0,sp                 ;159
000096  f7fffffe          BL       WM__RectIsNZ
00009a  b1b8              CBZ      r0,|L1.204|
00009c  8ba0              LDRH     r0,[r4,#0x1c]         ;164
00009e  f0100f20          TST      r0,#0x20              ;164
0000a2  d006              BEQ      |L1.178|
0000a4  466a              MOV      r2,sp                 ;165
0000a6  f1040108          ADD      r1,r4,#8              ;165
0000aa  4608              MOV      r0,r1                 ;165
0000ac  f7fffffe          BL       GUI_MergeRect
0000b0  e00c              B        |L1.204|
                  |L1.178|
0000b2  9800              LDR      r0,[sp,#0]            ;167
0000b4  60a0              STR      r0,[r4,#8]            ;167
0000b6  9801              LDR      r0,[sp,#4]            ;167
0000b8  60e0              STR      r0,[r4,#0xc]          ;167
0000ba  8ba0              LDRH     r0,[r4,#0x1c]         ;168
0000bc  f0400020          ORR      r0,r0,#0x20           ;168
0000c0  83a0              STRH     r0,[r4,#0x1c]         ;168
0000c2  48c9              LDR      r0,|L1.1000|
0000c4  8800              LDRH     r0,[r0,#0]            ;169  ; WM__NumInvalidWindows
0000c6  1c40              ADDS     r0,r0,#1              ;169
0000c8  49c7              LDR      r1,|L1.1000|
0000ca  8008              STRH     r0,[r1,#0]            ;169
                  |L1.204|
0000cc  bf00              NOP      
0000ce  e7cf              B        |L1.112|
;;;190    
                          ENDP

                  ResetNextDrawWin PROC
;;;210    */
;;;211    static void ResetNextDrawWin(void) {
0000d0  2000              MOVS     r0,#0
;;;212      NextDrawWin = WM_HWIN_NULL;
0000d2  49c6              LDR      r1,|L1.1004|
0000d4  8008              STRH     r0,[r1,#0]
;;;213    }
0000d6  4770              BX       lr
;;;214    
                          ENDP

                  _GethDrawWin PROC
;;;223    */
;;;224    static WM_HWIN _GethDrawWin(void) {
0000d8  49c5              LDR      r1,|L1.1008|
;;;225      WM_HWIN h;
;;;226      #if WM_SUPPORT_TRANSPARENCY
;;;227        if (WM__hATransWindow) {
0000da  8809              LDRH     r1,[r1,#0]  ; WM__hATransWindow
0000dc  b119              CBZ      r1,|L1.230|
;;;228          h = WM__hATransWindow;
0000de  49c4              LDR      r1,|L1.1008|
0000e0  f9b10000          LDRSH    r0,[r1,#0]  ; WM__hATransWindow
0000e4  e002              B        |L1.236|
                  |L1.230|
;;;229        } else
;;;230      #endif
;;;231      {
;;;232        h = GUI_Context.hAWin;
0000e6  49c3              LDR      r1,|L1.1012|
0000e8  f9b1003c          LDRSH    r0,[r1,#0x3c]  ; GUI_Context
                  |L1.236|
;;;233      }
;;;234      return h;
;;;235    }
0000ec  4770              BX       lr
;;;236    
                          ENDP

                  WM__Client2Screen PROC
;;;476    */
;;;477    void WM__Client2Screen(const WM_Obj* pWin, GUI_RECT *pRect) {
0000ee  b570              PUSH     {r4-r6,lr}
0000f0  4604              MOV      r4,r0
0000f2  460d              MOV      r5,r1
;;;478      GUI_MoveRect(pRect, pWin->Rect.x0, pWin->Rect.y0);
0000f4  f9b42002          LDRSH    r2,[r4,#2]
0000f8  f9b41000          LDRSH    r1,[r4,#0]
0000fc  4628              MOV      r0,r5
0000fe  f7fffffe          BL       GUI_MoveRect
;;;479    }
000102  bd70              POP      {r4-r6,pc}
;;;480    
                          ENDP

                  _SetClipRectUserIntersect PROC
;;;244    */
;;;245    static void _SetClipRectUserIntersect(const GUI_RECT* prSrc) {
000104  b57c              PUSH     {r2-r6,lr}
000106  4604              MOV      r4,r0
;;;246      if (GUI_Context.WM__pUserClipRect == NULL) {
000108  48ba              LDR      r0,|L1.1012|
00010a  6b80              LDR      r0,[r0,#0x38]  ; GUI_Context
00010c  b918              CBNZ     r0,|L1.278|
;;;247        LCD_SetClipRectEx(prSrc);
00010e  4620              MOV      r0,r4
000110  f7fffffe          BL       LCD_SetClipRectEx
000114  e016              B        |L1.324|
                  |L1.278|
;;;248      } else {
;;;249        GUI_RECT r;
;;;250        r = *GUI_Context.WM__pUserClipRect;             
000116  48b7              LDR      r0,|L1.1012|
000118  6b80              LDR      r0,[r0,#0x38]  ; GUI_Context
00011a  6801              LDR      r1,[r0,#0]
00011c  9100              STR      r1,[sp,#0]
00011e  6840              LDR      r0,[r0,#4]
000120  9001              STR      r0,[sp,#4]
;;;251        WM__Client2Screen(WM_H2P(_GethDrawWin()), &r);     /* Convert User ClipRect into screen coordinates */
000122  f7fffffe          BL       _GethDrawWin
000126  4606              MOV      r6,r0
000128  f7fffffe          BL       GUI_ALLOC_h2p
00012c  4605              MOV      r5,r0
00012e  4669              MOV      r1,sp
000130  f7fffffe          BL       WM__Client2Screen
;;;252        /* Set intersection as clip rect */    
;;;253        GUI__IntersectRect(&r, prSrc);
000134  4621              MOV      r1,r4
000136  4668              MOV      r0,sp
000138  f7fffffe          BL       GUI__IntersectRect
;;;254        LCD_SetClipRectEx(&r);
00013c  4668              MOV      r0,sp
00013e  f7fffffe          BL       LCD_SetClipRectEx
;;;255      }
000142  bf00              NOP      
                  |L1.324|
;;;256    }
000144  bd7c              POP      {r2-r6,pc}
;;;257    
                          ENDP

                  WM__ClipAtParentBorders PROC
;;;287    */
;;;288    int WM__ClipAtParentBorders(GUI_RECT* pRect, WM_HWIN hWin) {
000146  b570              PUSH     {r4-r6,lr}
000148  4606              MOV      r6,r0
00014a  460d              MOV      r5,r1
;;;289      WM_Obj* pWin;
;;;290    
;;;291      /* Iterate up the window hierarchy.
;;;292         If the window is invisible, we are done.
;;;293         Clip at parent boarders.
;;;294         We are done with iterating if hWin has no parent.
;;;295      */
;;;296      do {
00014c  bf00              NOP      
                  |L1.334|
;;;297        pWin = WM_H2P(hWin);
00014e  4628              MOV      r0,r5
000150  f7fffffe          BL       GUI_ALLOC_h2p
000154  4604              MOV      r4,r0
;;;298        if ((pWin->Status & WM_SF_ISVIS) == 0) {
000156  8ba0              LDRH     r0,[r4,#0x1c]
000158  f0100f02          TST      r0,#2
00015c  d101              BNE      |L1.354|
;;;299          return 0;                     /* Invisible */
00015e  2000              MOVS     r0,#0
                  |L1.352|
;;;300        }
;;;301        GUI__IntersectRect(pRect, &pWin->Rect);  /* And clip on borders */
;;;302        if (pWin->hParent == 0) {
;;;303          break;   /* hWin is now the top level window which has no parent */
;;;304        }
;;;305        hWin = pWin->hParent;                    /* Go one level up (parent)*/
;;;306      } while (1);                               /* Only way out is in the loop. Required for efficiency, no bug, even though some compilers may complain. */
;;;307      
;;;308      /* Now check if the top level window is a desktop window. If it is not,
;;;309        then the window is not visible.
;;;310      */
;;;311      if (_DesktopHandle2Index(hWin) < 0) {
;;;312        return 0;           /* No desktop - (unattached) - Nothing to draw */
;;;313      }
;;;314      return 1;               /* Something may be visible */
;;;315    }
000160  bd70              POP      {r4-r6,pc}
                  |L1.354|
000162  4621              MOV      r1,r4                 ;301
000164  4630              MOV      r0,r6                 ;301
000166  f7fffffe          BL       GUI__IntersectRect
00016a  8ae0              LDRH     r0,[r4,#0x16]         ;302
00016c  b900              CBNZ     r0,|L1.368|
00016e  e002              B        |L1.374|
                  |L1.368|
000170  f9b45016          LDRSH    r5,[r4,#0x16]         ;305
000174  e7eb              B        |L1.334|
                  |L1.374|
000176  bf00              NOP                            ;303
000178  4628              MOV      r0,r5                 ;311
00017a  f7fffffe          BL       _DesktopHandle2Index
00017e  2800              CMP      r0,#0                 ;311
000180  da01              BGE      |L1.390|
000182  2000              MOVS     r0,#0                 ;312
000184  e7ec              B        |L1.352|
                  |L1.390|
000186  2001              MOVS     r0,#1                 ;314
000188  e7ea              B        |L1.352|
;;;316    
                          ENDP

                  WM__ActivateClipRect PROC
;;;320    */
;;;321    void  WM__ActivateClipRect(void) {
00018a  b51c              PUSH     {r2-r4,lr}
;;;322      if (WM_IsActive) {
00018c  489a              LDR      r0,|L1.1016|
00018e  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
000190  b118              CBZ      r0,|L1.410|
;;;323        _SetClipRectUserIntersect(&_ClipContext.CurRect);
000192  489a              LDR      r0,|L1.1020|
000194  f7fffffe          BL       _SetClipRectUserIntersect
000198  e016              B        |L1.456|
                  |L1.410|
;;;324      } else {    /* Window manager disabled, typically because meory device is active */
;;;325        GUI_RECT r;
;;;326        WM_Obj *pAWin;
;;;327        pAWin = WM_H2P(GUI_Context.hAWin);
00019a  4996              LDR      r1,|L1.1012|
00019c  f9b1003c          LDRSH    r0,[r1,#0x3c]  ; GUI_Context
0001a0  f7fffffe          BL       GUI_ALLOC_h2p
0001a4  4604              MOV      r4,r0
;;;328        r = pAWin->Rect;
0001a6  e9d40100          LDRD     r0,r1,[r4,#0]
0001aa  e9cd0100          STRD     r0,r1,[sp,#0]
;;;329        #if WM_SUPPORT_TRANSPARENCY
;;;330          if (WM__hATransWindow) {
0001ae  4890              LDR      r0,|L1.1008|
0001b0  8800              LDRH     r0,[r0,#0]  ; WM__hATransWindow
0001b2  b128              CBZ      r0,|L1.448|
;;;331            WM__ClipAtParentBorders(&r, WM__hATransWindow);
0001b4  488e              LDR      r0,|L1.1008|
0001b6  f9b01000          LDRSH    r1,[r0,#0]  ; WM__hATransWindow
0001ba  4668              MOV      r0,sp
0001bc  f7fffffe          BL       WM__ClipAtParentBorders
                  |L1.448|
;;;332          }
;;;333        #endif
;;;334        /* Take UserClipRect into account */
;;;335        _SetClipRectUserIntersect(&r);
0001c0  4668              MOV      r0,sp
0001c2  f7fffffe          BL       _SetClipRectUserIntersect
;;;336      }
0001c6  bf00              NOP      
                  |L1.456|
;;;337    }
0001c8  bd1c              POP      {r2-r4,pc}
;;;338    
                          ENDP

                  WM__InsertWindowIntoList PROC
;;;350    */
;;;351    void WM__InsertWindowIntoList(WM_HWIN hWin, WM_HWIN hParent) {
0001ca  e92d4ff8          PUSH     {r3-r11,lr}
0001ce  4606              MOV      r6,r0
0001d0  4688              MOV      r8,r1
;;;352      int OnTop;
;;;353      WM_HWIN hi;
;;;354      WM_Obj * pWin;
;;;355      WM_Obj * pParent;
;;;356      WM_Obj * pi;
;;;357    
;;;358      if (hParent) {
0001d2  f1b80f00          CMP      r8,#0
0001d6  d03f              BEQ      |L1.600|
;;;359        pWin = WM_H2P(hWin);
0001d8  4630              MOV      r0,r6
0001da  f7fffffe          BL       GUI_ALLOC_h2p
0001de  4604              MOV      r4,r0
;;;360        pWin->hNext = 0;
0001e0  2000              MOVS     r0,#0
0001e2  8360              STRH     r0,[r4,#0x1a]
;;;361        pWin->hParent = hParent;
0001e4  f8a48016          STRH     r8,[r4,#0x16]
;;;362        pParent = WM_H2P(hParent);
0001e8  4640              MOV      r0,r8
0001ea  f7fffffe          BL       GUI_ALLOC_h2p
0001ee  4607              MOV      r7,r0
;;;363        OnTop   = pWin->Status & WM_CF_STAYONTOP;
0001f0  8ba0              LDRH     r0,[r4,#0x1c]
0001f2  f0000b08          AND      r11,r0,#8
;;;364        hi = pParent->hFirstChild;
0001f6  f9b79018          LDRSH    r9,[r7,#0x18]
;;;365        /* Put it at beginning of the list if there is no child */
;;;366        if (hi == 0) {   /* No child yet ... Makes things easy ! */
0001fa  f1b90f00          CMP      r9,#0
0001fe  d102              BNE      |L1.518|
;;;367          pParent->hFirstChild = hWin;
000200  833e              STRH     r6,[r7,#0x18]
                  |L1.514|
;;;368          return;                         /* Early out ... We are done */
;;;369        }
;;;370        /* Put it at beginning of the list if first child is a TOP window and new one is not */
;;;371        pi = WM_H2P(hi);
;;;372        if (!OnTop) {
;;;373          if (pi->Status & WM_SF_STAYONTOP) {
;;;374            pWin->hNext = hi;
;;;375            pParent->hFirstChild = hWin;
;;;376            return;                         /* Early out ... We are done */
;;;377          }
;;;378        }
;;;379        /* Put it at the end of the list or before the last non "STAY-ON-TOP" child */
;;;380        do {
;;;381          WM_Obj* pNext;
;;;382          WM_HWIN hNext;
;;;383          if ((hNext = pi->hNext) == 0) {   /* End of sibling list ? */
;;;384            pi->hNext = hWin;             /* Then modify this last element to point to new one and we are done */
;;;385            break;
;;;386          }
;;;387          pNext = WM_H2P(hNext);
;;;388          if (!OnTop) {
;;;389            if (pNext->Status & WM_SF_STAYONTOP) {
;;;390              pi->hNext = hWin;
;;;391              pWin->hNext = hNext;
;;;392              break;
;;;393            }
;;;394          }
;;;395          pi = pNext;
;;;396        }  while (1);
;;;397        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;398          WM__NotifyVisChanged(hWin, &pWin->Rect);
;;;399        #endif
;;;400      }
;;;401    }
000202  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.518|
000206  4648              MOV      r0,r9                 ;371
000208  f7fffffe          BL       GUI_ALLOC_h2p
00020c  4605              MOV      r5,r0                 ;371
00020e  f1bb0f00          CMP      r11,#0                ;372
000212  d107              BNE      |L1.548|
000214  8ba8              LDRH     r0,[r5,#0x1c]         ;373
000216  f0100f08          TST      r0,#8                 ;373
00021a  d003              BEQ      |L1.548|
00021c  f8a4901a          STRH     r9,[r4,#0x1a]         ;374
000220  833e              STRH     r6,[r7,#0x18]         ;375
000222  e7ee              B        |L1.514|
                  |L1.548|
000224  bf00              NOP                            ;380
                  |L1.550|
000226  f9b5001a          LDRSH    r0,[r5,#0x1a]         ;383
00022a  9000              STR      r0,[sp,#0]            ;383
00022c  b908              CBNZ     r0,|L1.562|
00022e  836e              STRH     r6,[r5,#0x1a]         ;384
000230  e011              B        |L1.598|
                  |L1.562|
000232  9800              LDR      r0,[sp,#0]            ;387
000234  f7fffffe          BL       GUI_ALLOC_h2p
000238  4682              MOV      r10,r0                ;387
00023a  f1bb0f00          CMP      r11,#0                ;388
00023e  d108              BNE      |L1.594|
000240  f8ba001c          LDRH     r0,[r10,#0x1c]        ;389
000244  f0100f08          TST      r0,#8                 ;389
000248  d003              BEQ      |L1.594|
00024a  836e              STRH     r6,[r5,#0x1a]         ;390
00024c  9800              LDR      r0,[sp,#0]            ;391
00024e  8360              STRH     r0,[r4,#0x1a]         ;391
000250  e001              B        |L1.598|
                  |L1.594|
000252  4655              MOV      r5,r10                ;395
000254  e7e7              B        |L1.550|
                  |L1.598|
000256  bf00              NOP                            ;385
                  |L1.600|
000258  bf00              NOP      
00025a  e7d2              B        |L1.514|
;;;402    
                          ENDP

                  WM__RemoveWindowFromList PROC
;;;406    */
;;;407    void WM__RemoveWindowFromList(WM_HWIN hWin) {
00025c  e92d47f0          PUSH     {r4-r10,lr}
000260  4607              MOV      r7,r0
;;;408      WM_HWIN hi, hParent;
;;;409      WM_Obj * pWin, * pParent, * pi;
;;;410      
;;;411      pWin = WM_H2P(hWin);
000262  4638              MOV      r0,r7
000264  f7fffffe          BL       GUI_ALLOC_h2p
000268  4681              MOV      r9,r0
;;;412      hParent = pWin->hParent;
00026a  f9b98016          LDRSH    r8,[r9,#0x16]
;;;413      if (hParent) {
00026e  f1b80f00          CMP      r8,#0
000272  d020              BEQ      |L1.694|
;;;414        pParent = WM_H2P(hParent);
000274  4640              MOV      r0,r8
000276  f7fffffe          BL       GUI_ALLOC_h2p
00027a  4606              MOV      r6,r0
;;;415        hi = pParent->hFirstChild;
00027c  f9b65018          LDRSH    r5,[r6,#0x18]
;;;416        if (hi == hWin) {
000280  42bd              CMP      r5,r7
000282  d106              BNE      |L1.658|
;;;417          pi = WM_H2P(hi);
000284  4628              MOV      r0,r5
000286  f7fffffe          BL       GUI_ALLOC_h2p
00028a  4604              MOV      r4,r0
;;;418          pParent->hFirstChild = pi->hNext;
00028c  8b60              LDRH     r0,[r4,#0x1a]
00028e  8330              STRH     r0,[r6,#0x18]
000290  e011              B        |L1.694|
                  |L1.658|
;;;419        } else {
;;;420          while (hi) {
000292  e00d              B        |L1.688|
                  |L1.660|
;;;421            pi = WM_H2P(hi);
000294  4628              MOV      r0,r5
000296  f7fffffe          BL       GUI_ALLOC_h2p
00029a  4604              MOV      r4,r0
;;;422            if (pi->hNext == hWin) {
00029c  f9b4001a          LDRSH    r0,[r4,#0x1a]
0002a0  42b8              CMP      r0,r7
0002a2  d103              BNE      |L1.684|
;;;423              pi->hNext = pWin->hNext;
0002a4  f8b9001a          LDRH     r0,[r9,#0x1a]
0002a8  8360              STRH     r0,[r4,#0x1a]
;;;424              break;
0002aa  e003              B        |L1.692|
                  |L1.684|
;;;425            }
;;;426            hi = pi->hNext;
0002ac  f9b4501a          LDRSH    r5,[r4,#0x1a]
                  |L1.688|
0002b0  2d00              CMP      r5,#0                 ;420
0002b2  d1ef              BNE      |L1.660|
                  |L1.692|
0002b4  bf00              NOP                            ;424
                  |L1.694|
;;;427          }
;;;428        }
;;;429      }
;;;430    }
0002b6  e8bd87f0          POP      {r4-r10,pc}
;;;431    
                          ENDP

                  WM_InvalidateArea PROC
;;;781    */
;;;782    void WM_InvalidateArea(const GUI_RECT* pRect) {
0002ba  b570              PUSH     {r4-r6,lr}
0002bc  4604              MOV      r4,r0
;;;783      WM_HWIN   hWin;
;;;784      WM_LOCK();
0002be  f7fffffe          BL       GUI_Lock
;;;785      /* Iterate over all windows */
;;;786      for (hWin = WM__FirstWin; hWin; hWin = WM_H2P(hWin)->hNextLin) {
0002c2  484f              LDR      r0,|L1.1024|
0002c4  f9b05000          LDRSH    r5,[r0,#0]  ; WM__FirstWin
0002c8  e008              B        |L1.732|
                  |L1.714|
;;;787        _Invalidate1Abs(hWin, pRect);
0002ca  4621              MOV      r1,r4
0002cc  4628              MOV      r0,r5
0002ce  f7fffffe          BL       _Invalidate1Abs
0002d2  4628              MOV      r0,r5                 ;786
0002d4  f7fffffe          BL       GUI_ALLOC_h2p
0002d8  f9b05014          LDRSH    r5,[r0,#0x14]         ;786
                  |L1.732|
0002dc  2d00              CMP      r5,#0                 ;786
0002de  d1f4              BNE      |L1.714|
;;;788      }
;;;789      WM_UNLOCK();
0002e0  f7fffffe          BL       GUI_Unlock
;;;790    }
0002e4  bd70              POP      {r4-r6,pc}
;;;791    
                          ENDP

                  WM__DetachWindow PROC
;;;439    */
;;;440    void WM__DetachWindow(WM_HWIN hWin) {
0002e6  b570              PUSH     {r4-r6,lr}
0002e8  4605              MOV      r5,r0
;;;441      WM_Obj* pWin;
;;;442      WM_HWIN hParent;
;;;443      pWin = WM_H2P(hWin);
0002ea  4628              MOV      r0,r5
0002ec  f7fffffe          BL       GUI_ALLOC_h2p
0002f0  4604              MOV      r4,r0
;;;444      hParent = pWin->hParent;
0002f2  f9b46016          LDRSH    r6,[r4,#0x16]
;;;445      if (hParent) {
0002f6  b13e              CBZ      r6,|L1.776|
;;;446        WM__RemoveWindowFromList(hWin);
0002f8  4628              MOV      r0,r5
0002fa  f7fffffe          BL       WM__RemoveWindowFromList
;;;447        /* Clear area used by this window */
;;;448        WM_InvalidateArea(&pWin->Rect);
0002fe  4620              MOV      r0,r4
000300  f7fffffe          BL       WM_InvalidateArea
;;;449        pWin->hParent = 0;
000304  2000              MOVS     r0,#0
000306  82e0              STRH     r0,[r4,#0x16]
                  |L1.776|
;;;450      }
;;;451    }
000308  bd70              POP      {r4-r6,pc}
;;;452    
                          ENDP

                  WM_SelectWindow PROC
;;;958    */
;;;959    WM_HWIN WM_SelectWindow(WM_HWIN  hWin) {
00030a  b570              PUSH     {r4-r6,lr}
00030c  4604              MOV      r4,r0
;;;960      WM_HWIN hWinPrev;
;;;961      WM_Obj* pObj;
;;;962    
;;;963      WM_ASSERT_NOT_IN_PAINT();
;;;964      WM_LOCK();
00030e  f7fffffe          BL       GUI_Lock
;;;965      hWinPrev = GUI_Context.hAWin;
000312  4838              LDR      r0,|L1.1012|
000314  f9b0603c          LDRSH    r6,[r0,#0x3c]  ; GUI_Context
;;;966      if (hWin == 0) {
000318  b914              CBNZ     r4,|L1.800|
;;;967        hWin = WM__FirstWin;
00031a  4839              LDR      r0,|L1.1024|
00031c  f9b04000          LDRSH    r4,[r0,#0]  ; WM__FirstWin
                  |L1.800|
;;;968      }
;;;969      /* Select new window */
;;;970      GUI_Context.hAWin = hWin;
000320  4834              LDR      r0,|L1.1012|
000322  8784              STRH     r4,[r0,#0x3c]
;;;971      #if GUI_NUM_LAYERS > 1
;;;972      {
;;;973        WM_HWIN hTop;
;;;974        int LayerIndex;
;;;975        hTop = _GetTopLevelWindow(hWin);
;;;976        LayerIndex = _DesktopHandle2Index(hTop);
;;;977        if (LayerIndex >= 0) {
;;;978          GUI_SelectLayer(LayerIndex);
;;;979        }
;;;980      }
;;;981      #endif
;;;982      pObj = WM_H2P(hWin);
000324  4620              MOV      r0,r4
000326  f7fffffe          BL       GUI_ALLOC_h2p
00032a  4605              MOV      r5,r0
;;;983      LCD_SetClipRectMax();             /* Drawing operations will clip ... If WM is deactivated, allow all */
00032c  f7fffffe          BL       LCD_SetClipRectMax
;;;984      GUI_Context.xOff = pObj->Rect.x0;
000330  f9b50000          LDRSH    r0,[r5,#0]
000334  492f              LDR      r1,|L1.1012|
000336  6408              STR      r0,[r1,#0x40]  ; GUI_Context
;;;985      GUI_Context.yOff = pObj->Rect.y0;
000338  f9b50002          LDRSH    r0,[r5,#2]
00033c  6448              STR      r0,[r1,#0x44]  ; GUI_Context
;;;986      WM_UNLOCK();
00033e  f7fffffe          BL       GUI_Unlock
;;;987      return hWinPrev;
000342  4630              MOV      r0,r6
;;;988    }
000344  bd70              POP      {r4-r6,pc}
;;;989    
                          ENDP

                  WM__RemoveFromLinList PROC
;;;509    */
;;;510    void WM__RemoveFromLinList(WM_HWIN hWin) {
000346  e92d41f0          PUSH     {r4-r8,lr}
00034a  4606              MOV      r6,r0
;;;511      WM_Obj* piWin;
;;;512      WM_HWIN hiWin;
;;;513      WM_HWIN hNext;
;;;514      for (hiWin = WM__FirstWin; hiWin; ) {
00034c  482c              LDR      r0,|L1.1024|
00034e  f9b07000          LDRSH    r7,[r0,#0]  ; WM__FirstWin
000352  e00e              B        |L1.882|
                  |L1.852|
;;;515        piWin = WM_H2P(hiWin);
000354  4638              MOV      r0,r7
000356  f7fffffe          BL       GUI_ALLOC_h2p
00035a  4604              MOV      r4,r0
;;;516        hNext = piWin->hNextLin;
00035c  f9b45014          LDRSH    r5,[r4,#0x14]
;;;517        if (hNext == hWin) {
000360  42b5              CMP      r5,r6
000362  d105              BNE      |L1.880|
;;;518          piWin->hNextLin = WM_H2P(hWin)->hNextLin;
000364  4630              MOV      r0,r6
000366  f7fffffe          BL       GUI_ALLOC_h2p
00036a  8a80              LDRH     r0,[r0,#0x14]
00036c  82a0              STRH     r0,[r4,#0x14]
;;;519          break;
00036e  e002              B        |L1.886|
                  |L1.880|
;;;520        }
;;;521        hiWin = hNext;
000370  462f              MOV      r7,r5
                  |L1.882|
000372  2f00              CMP      r7,#0                 ;514
000374  d1ee              BNE      |L1.852|
                  |L1.886|
000376  bf00              NOP                            ;519
;;;522      }
;;;523    }
000378  e8bd81f0          POP      {r4-r8,pc}
;;;524    
                          ENDP

                  WM_SendMessage PROC
;;;676    */
;;;677    void WM_SendMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
00037c  b570              PUSH     {r4-r6,lr}
00037e  4604              MOV      r4,r0
000380  460d              MOV      r5,r1
;;;678      if (hWin) {
000382  b174              CBZ      r4,|L1.930|
;;;679        WM_Obj* pWin;
;;;680        WM_LOCK();
000384  f7fffffe          BL       GUI_Lock
;;;681        pWin = WM_H2P(hWin);
000388  4620              MOV      r0,r4
00038a  f7fffffe          BL       GUI_ALLOC_h2p
00038e  4606              MOV      r6,r0
;;;682        if (pWin->cb != NULL) {
000390  6930              LDR      r0,[r6,#0x10]
000392  b118              CBZ      r0,|L1.924|
;;;683          pMsg->hWin = hWin;
000394  80ac              STRH     r4,[r5,#4]
;;;684          (*pWin->cb)(pMsg);
000396  4628              MOV      r0,r5
000398  6931              LDR      r1,[r6,#0x10]
00039a  4788              BLX      r1
                  |L1.924|
;;;685        }
;;;686        WM_UNLOCK();
00039c  f7fffffe          BL       GUI_Unlock
;;;687      }
0003a0  bf00              NOP      
                  |L1.930|
;;;688    }
0003a2  bd70              POP      {r4-r6,pc}
;;;689    
                          ENDP

                  WM__SendMsgNoData PROC
;;;693    */
;;;694    void WM__SendMsgNoData(WM_HWIN hWin, U8 MsgId) {
0003a4  b53e              PUSH     {r1-r5,lr}
0003a6  4605              MOV      r5,r0
0003a8  460c              MOV      r4,r1
;;;695      WM_MESSAGE Msg;
;;;696      Msg.hWin  = hWin;
0003aa  f8ad5004          STRH     r5,[sp,#4]
;;;697      Msg.MsgId = MsgId;
0003ae  9400              STR      r4,[sp,#0]
;;;698      WM_SendMessage(hWin, &Msg);
0003b0  4669              MOV      r1,sp
0003b2  4628              MOV      r0,r5
0003b4  f7fffffe          BL       WM_SendMessage
;;;699    }
0003b8  bd3e              POP      {r1-r5,pc}
;;;700    
                          ENDP

                  WM__IsWindow PROC
;;;484    */
;;;485    int WM__IsWindow(WM_HWIN hWin) {
0003ba  b570              PUSH     {r4-r6,lr}
0003bc  4605              MOV      r5,r0
;;;486      WM_HWIN iWin;
;;;487      for (iWin = WM__FirstWin; iWin; iWin = WM_H2P(iWin)->hNextLin) {
0003be  4810              LDR      r0,|L1.1024|
0003c0  f9b04000          LDRSH    r4,[r0,#0]  ; WM__FirstWin
0003c4  e008              B        |L1.984|
                  |L1.966|
;;;488        if (iWin == hWin) {
0003c6  42ac              CMP      r4,r5
0003c8  d101              BNE      |L1.974|
;;;489          return 1;
0003ca  2001              MOVS     r0,#1
                  |L1.972|
;;;490        }
;;;491      }
;;;492      return 0;
;;;493    }
0003cc  bd70              POP      {r4-r6,pc}
                  |L1.974|
0003ce  4620              MOV      r0,r4                 ;487
0003d0  f7fffffe          BL       GUI_ALLOC_h2p
0003d4  f9b04014          LDRSH    r4,[r0,#0x14]         ;487
                  |L1.984|
0003d8  2c00              CMP      r4,#0                 ;487
0003da  d1f4              BNE      |L1.966|
0003dc  2000              MOVS     r0,#0                 ;492
0003de  e7f5              B        |L1.972|
                  |L1.992|
                          DCD      WM__pFirstCriticalHandle
                  |L1.996|
                          DCD      WM__ahDesktopWin
                  |L1.1000|
                          DCD      WM__NumInvalidWindows
                  |L1.1004|
                          DCD      NextDrawWin
                  |L1.1008|
                          DCD      WM__hATransWindow
                  |L1.1012|
                          DCD      GUI_Context
                  |L1.1016|
                          DCD      WM_IsActive
                  |L1.1020|
                          DCD      _ClipContext+0x8
                  |L1.1024|
                          DCD      WM__FirstWin
                          ENDP

                  WM_DeleteWindow PROC
;;;899    */
;;;900    void WM_DeleteWindow (WM_HWIN hWin) {
000404  b570              PUSH     {r4-r6,lr}
000406  4604              MOV      r4,r0
;;;901      WM_Obj* pWin;
;;;902      if (!hWin) {
000408  b904              CBNZ     r4,|L1.1036|
                  |L1.1034|
;;;903        return;
;;;904      }
;;;905      WM_ASSERT_NOT_IN_PAINT();
;;;906      WM_LOCK();
;;;907      if (WM__IsWindow(hWin)) {
;;;908        pWin = WM_H2P(hWin);
;;;909        ResetNextDrawWin();              /* Make sure the window will no longer receive drawing messages */
;;;910      /* Make sure that focus is set to an existing window */
;;;911        if (WM__hWinFocus == hWin) {
;;;912          WM__hWinFocus = 0;
;;;913        }
;;;914        if (WM__hCapture == hWin) {
;;;915          WM__hCapture = 0;
;;;916        }
;;;917        /* check if critical handles are affected. If so, reset the window handle to 0 */
;;;918        _CheckCriticalHandles(hWin);
;;;919        /* Inform parent */
;;;920        WM_NotifyParent(hWin, WM_NOTIFICATION_CHILD_DELETED);
;;;921        /* Delete all children */
;;;922        _DeleteAllChildren(pWin->hFirstChild);
;;;923        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;924          WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
;;;925        #endif
;;;926        /* Send WM_DELETE message to window in order to inform window itself */
;;;927        WM__SendMsgNoData(hWin, WM_DELETE);     /* tell window about it */
;;;928        WM__DetachWindow(hWin);
;;;929        /* Remove window from window stack */
;;;930        WM__RemoveFromLinList(hWin);
;;;931        /* Handle transparency counter if necessary */
;;;932        #if WM_SUPPORT_TRANSPARENCY
;;;933          if (pWin->Status & WM_SF_HASTRANS) {
;;;934            WM__TransWindowCnt--;
;;;935          }
;;;936        #endif
;;;937        /* Make sure window is no longer counted as invalid */
;;;938        if (pWin->Status & WM_SF_INVALID) {
;;;939          WM__NumInvalidWindows--;
;;;940        }
;;;941      /* Free window memory */
;;;942        WM__NumWindows--;
;;;943        GUI_ALLOC_Free(hWin);
;;;944      /* Select a valid window */
;;;945        WM_SelectWindow(WM__FirstWin);
;;;946      } else {
;;;947        GUI_DEBUG_WARN("WM_DeleteWindow: Invalid handle");
;;;948      }
;;;949      WM_UNLOCK();
;;;950    }
00040a  bd70              POP      {r4-r6,pc}
                  |L1.1036|
00040c  f7fffffe          BL       GUI_Lock
000410  4620              MOV      r0,r4                 ;907
000412  f7fffffe          BL       WM__IsWindow
000416  b3f0              CBZ      r0,|L1.1174|
000418  4620              MOV      r0,r4                 ;908
00041a  f7fffffe          BL       GUI_ALLOC_h2p
00041e  4605              MOV      r5,r0                 ;908
000420  f7fffffe          BL       ResetNextDrawWin
000424  48ff              LDR      r0,|L1.2084|
000426  f9b00000          LDRSH    r0,[r0,#0]            ;911  ; WM__hWinFocus
00042a  42a0              CMP      r0,r4                 ;911
00042c  d102              BNE      |L1.1076|
00042e  2000              MOVS     r0,#0                 ;912
000430  49fc              LDR      r1,|L1.2084|
000432  8008              STRH     r0,[r1,#0]            ;912
                  |L1.1076|
000434  48fc              LDR      r0,|L1.2088|
000436  f9b00000          LDRSH    r0,[r0,#0]            ;914  ; WM__hCapture
00043a  42a0              CMP      r0,r4                 ;914
00043c  d102              BNE      |L1.1092|
00043e  2000              MOVS     r0,#0                 ;915
000440  49f9              LDR      r1,|L1.2088|
000442  8008              STRH     r0,[r1,#0]            ;915
                  |L1.1092|
000444  4620              MOV      r0,r4                 ;918
000446  f7fffffe          BL       _CheckCriticalHandles
00044a  2107              MOVS     r1,#7                 ;920
00044c  4620              MOV      r0,r4                 ;920
00044e  f7fffffe          BL       WM_NotifyParent
000452  f9b50018          LDRSH    r0,[r5,#0x18]         ;922
000456  f7fffffe          BL       _DeleteAllChildren
00045a  210b              MOVS     r1,#0xb               ;927
00045c  4620              MOV      r0,r4                 ;927
00045e  f7fffffe          BL       WM__SendMsgNoData
000462  4620              MOV      r0,r4                 ;928
000464  f7fffffe          BL       WM__DetachWindow
000468  4620              MOV      r0,r4                 ;930
00046a  f7fffffe          BL       WM__RemoveFromLinList
00046e  8ba8              LDRH     r0,[r5,#0x1c]         ;933
000470  f0100f01          TST      r0,#1                 ;933
000474  d004              BEQ      |L1.1152|
000476  48ed              LDR      r0,|L1.2092|
000478  6800              LDR      r0,[r0,#0]            ;934  ; WM__TransWindowCnt
00047a  1e40              SUBS     r0,r0,#1              ;934
00047c  49eb              LDR      r1,|L1.2092|
00047e  6008              STR      r0,[r1,#0]            ;934  ; WM__TransWindowCnt
                  |L1.1152|
000480  8ba8              LDRH     r0,[r5,#0x1c]         ;938
000482  f0100f20          TST      r0,#0x20              ;938
000486  d004              BEQ      |L1.1170|
000488  48e9              LDR      r0,|L1.2096|
00048a  8800              LDRH     r0,[r0,#0]            ;939  ; WM__NumInvalidWindows
00048c  1e40              SUBS     r0,r0,#1              ;939
00048e  49e8              LDR      r1,|L1.2096|
000490  8008              STRH     r0,[r1,#0]            ;939
                  |L1.1170|
000492  48e8              LDR      r0,|L1.2100|
000494  e000              B        |L1.1176|
                  |L1.1174|
000496  e00b              B        |L1.1200|
                  |L1.1176|
000498  8800              LDRH     r0,[r0,#0]            ;942  ; WM__NumWindows
00049a  1e40              SUBS     r0,r0,#1              ;942
00049c  49e5              LDR      r1,|L1.2100|
00049e  8008              STRH     r0,[r1,#0]            ;942
0004a0  4620              MOV      r0,r4                 ;943
0004a2  f7fffffe          BL       GUI_ALLOC_Free
0004a6  48e4              LDR      r0,|L1.2104|
0004a8  f9b00000          LDRSH    r0,[r0,#0]            ;945  ; WM__FirstWin
0004ac  f7fffffe          BL       WM_SelectWindow
                  |L1.1200|
0004b0  f7fffffe          BL       GUI_Unlock
0004b4  bf00              NOP      
0004b6  e7a8              B        |L1.1034|
;;;951    
                          ENDP

                  _DeleteAllChildren PROC
;;;457    */
;;;458    static void _DeleteAllChildren(WM_HWIN hChild) {
0004b8  b570              PUSH     {r4-r6,lr}
0004ba  4604              MOV      r4,r0
;;;459      while (hChild) {
0004bc  e00a              B        |L1.1236|
                  |L1.1214|
;;;460        WM_Obj* pChild = WM_H2P(hChild);
0004be  4620              MOV      r0,r4
0004c0  f7fffffe          BL       GUI_ALLOC_h2p
0004c4  4605              MOV      r5,r0
;;;461        WM_HWIN hNext = pChild->hNext;
0004c6  f9b5601a          LDRSH    r6,[r5,#0x1a]
;;;462        WM_DeleteWindow(hChild);
0004ca  4620              MOV      r0,r4
0004cc  f7fffffe          BL       WM_DeleteWindow
;;;463        hChild = hNext;
0004d0  4634              MOV      r4,r6
;;;464      }
0004d2  bf00              NOP      
                  |L1.1236|
0004d4  2c00              CMP      r4,#0                 ;459
0004d6  d1f2              BNE      |L1.1214|
;;;465    }
0004d8  bd70              POP      {r4-r6,pc}
;;;466    
                          ENDP

                  WM__InvalidateAreaBelow PROC
;;;500    */
;;;501    void WM__InvalidateAreaBelow(const GUI_RECT* pRect, WM_HWIN StopWin) {
0004da  b570              PUSH     {r4-r6,lr}
0004dc  4605              MOV      r5,r0
0004de  460c              MOV      r4,r1
;;;502      GUI_USE_PARA(StopWin);
0004e0  bf00              NOP      
;;;503      WM_InvalidateArea(pRect);      /* Can be optimized to spare windows above */
0004e2  4628              MOV      r0,r5
0004e4  f7fffffe          BL       WM_InvalidateArea
;;;504    }
0004e8  bd70              POP      {r4-r6,pc}
;;;505    
                          ENDP

                  _AddToLinList PROC
;;;528    */
;;;529    static void _AddToLinList(WM_HWIN hNew) {
0004ea  b570              PUSH     {r4-r6,lr}
0004ec  4604              MOV      r4,r0
;;;530      WM_Obj* pFirst;
;;;531      WM_Obj* pNew;
;;;532      if (WM__FirstWin) {
0004ee  48d2              LDR      r0,|L1.2104|
0004f0  8800              LDRH     r0,[r0,#0]  ; WM__FirstWin
0004f2  b168              CBZ      r0,|L1.1296|
;;;533        pFirst = WM_H2P(WM__FirstWin);
0004f4  48d0              LDR      r0,|L1.2104|
0004f6  f9b00000          LDRSH    r0,[r0,#0]  ; WM__FirstWin
0004fa  f7fffffe          BL       GUI_ALLOC_h2p
0004fe  4606              MOV      r6,r0
;;;534        pNew   = WM_H2P(hNew);
000500  4620              MOV      r0,r4
000502  f7fffffe          BL       GUI_ALLOC_h2p
000506  4605              MOV      r5,r0
;;;535        pNew->hNextLin = pFirst->hNextLin;
000508  8ab0              LDRH     r0,[r6,#0x14]
00050a  82a8              STRH     r0,[r5,#0x14]
;;;536        pFirst->hNextLin = hNew;
00050c  82b4              STRH     r4,[r6,#0x14]
00050e  e001              B        |L1.1300|
                  |L1.1296|
;;;537      } else {
;;;538        WM__FirstWin = hNew;
000510  48c9              LDR      r0,|L1.2104|
000512  8004              STRH     r4,[r0,#0]
                  |L1.1300|
;;;539      }
;;;540    }
000514  bd70              POP      {r4-r6,pc}
;;;541    
                          ENDP

                  _Findy1 PROC
;;;561    */
;;;562    static void _Findy1(WM_HWIN iWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
000516  e92d47fc          PUSH     {r2-r10,lr}
00051a  4606              MOV      r6,r0
00051c  460c              MOV      r4,r1
00051e  4617              MOV      r7,r2
;;;563      WM_Obj* pWin;
;;;564      for (; iWin; iWin = pWin->hNext) { 
000520  e04d              B        |L1.1470|
                  |L1.1314|
;;;565        int Status = (pWin = WM_H2P(iWin))->Status;
000522  4630              MOV      r0,r6
000524  f7fffffe          BL       GUI_ALLOC_h2p
000528  4605              MOV      r5,r0
00052a  f8b0801c          LDRH     r8,[r0,#0x1c]
;;;566        /* Check if this window affects us at all */    
;;;567        if (Status & WM_SF_ISVIS) {
00052e  f0180f02          TST      r8,#2
000532  d042              BEQ      |L1.1466|
;;;568          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;569          if (pParentRect) {
000534  b12f              CBZ      r7,|L1.1346|
;;;570            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
000536  463a              MOV      r2,r7
000538  4629              MOV      r1,r5
00053a  4668              MOV      r0,sp
00053c  f7fffffe          BL       GUI__IntersectRects
000540  e003              B        |L1.1354|
                  |L1.1346|
;;;571          } else {
;;;572            rWinClipped = pWin->Rect;
000542  e9d50100          LDRD     r0,r1,[r5,#0]
000546  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L1.1354|
;;;573          }
;;;574          /* Check if this window affects us at all */    
;;;575          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
00054a  4669              MOV      r1,sp
00054c  4620              MOV      r0,r4
00054e  f7fffffe          BL       GUI_RectsIntersect
000552  b388              CBZ      r0,|L1.1464|
;;;576            if ((Status & WM_SF_HASTRANS) == 0) {
000554  f0180f01          TST      r8,#1
000558  d11c              BNE      |L1.1428|
;;;577              if (pWin->Rect.y0 > pRect->y0) {
00055a  f9b50002          LDRSH    r0,[r5,#2]
00055e  f9b41002          LDRSH    r1,[r4,#2]
000562  4288              CMP      r0,r1
000564  dd0c              BLE      |L1.1408|
;;;578                ASSIGN_IF_LESS(pRect->y1, rWinClipped.y0 - 1);      /* Check upper border of window */
000566  f9bd0002          LDRSH    r0,[sp,#2]
00056a  1e40              SUBS     r0,r0,#1
00056c  f9b41006          LDRSH    r1,[r4,#6]
000570  4288              CMP      r0,r1
000572  da21              BGE      |L1.1464|
000574  f8bd0002          LDRH     r0,[sp,#2]
000578  1e40              SUBS     r0,r0,#1
00057a  b200              SXTH     r0,r0
00057c  80e0              STRH     r0,[r4,#6]
00057e  e01b              B        |L1.1464|
                  |L1.1408|
;;;579              } else {
;;;580                ASSIGN_IF_LESS(pRect->y1, rWinClipped.y1);        /* Check lower border of window */
000580  f9bd0006          LDRSH    r0,[sp,#6]
000584  f9b41006          LDRSH    r1,[r4,#6]
000588  4288              CMP      r0,r1
00058a  da15              BGE      |L1.1464|
00058c  f8bd0006          LDRH     r0,[sp,#6]
000590  80e0              STRH     r0,[r4,#6]
000592  e011              B        |L1.1464|
                  |L1.1428|
;;;581              }
;;;582            } else {
;;;583              /* Check all children*/ 
;;;584              WM_HWIN hChild;
;;;585              WM_Obj* pChild;
;;;586              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
000594  f9b59018          LDRSH    r9,[r5,#0x18]
000598  e00a              B        |L1.1456|
                  |L1.1434|
;;;587                pChild = WM_H2P(hChild);
00059a  4648              MOV      r0,r9
00059c  f7fffffe          BL       GUI_ALLOC_h2p
0005a0  4682              MOV      r10,r0
;;;588                _Findy1(hChild, pRect, &rWinClipped);
0005a2  466a              MOV      r2,sp
0005a4  4621              MOV      r1,r4
0005a6  4648              MOV      r0,r9
0005a8  f7fffffe          BL       _Findy1
0005ac  f9ba901a          LDRSH    r9,[r10,#0x1a]        ;586
                  |L1.1456|
0005b0  f1b90f00          CMP      r9,#0                 ;586
0005b4  d1f1              BNE      |L1.1434|
;;;589              }
;;;590            }
0005b6  bf00              NOP      
                  |L1.1464|
;;;591          }
;;;592        }
0005b8  bf00              NOP      
                  |L1.1466|
0005ba  f9b5601a          LDRSH    r6,[r5,#0x1a]         ;564
                  |L1.1470|
0005be  2e00              CMP      r6,#0                 ;564
0005c0  d1af              BNE      |L1.1314|
;;;593      }
;;;594    }
0005c2  e8bd87fc          POP      {r2-r10,pc}
;;;595    
                          ENDP

                  _Findx0 PROC
;;;599    */
;;;600    static int _Findx0(WM_HWIN hWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
0005c6  e92d5ffc          PUSH     {r2-r12,lr}
0005ca  4606              MOV      r6,r0
0005cc  460d              MOV      r5,r1
0005ce  4617              MOV      r7,r2
;;;601      WM_Obj* pWin;
;;;602      int r = 0;
0005d0  f04f0b00          MOV      r11,#0
;;;603      for (; hWin; hWin = pWin->hNext) { 
0005d4  e03b              B        |L1.1614|
                  |L1.1494|
;;;604        int Status = (pWin = WM_H2P(hWin))->Status;
0005d6  4630              MOV      r0,r6
0005d8  f7fffffe          BL       GUI_ALLOC_h2p
0005dc  4604              MOV      r4,r0
0005de  f8b0801c          LDRH     r8,[r0,#0x1c]
;;;605        if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
0005e2  f0180f02          TST      r8,#2
0005e6  d030              BEQ      |L1.1610|
;;;606          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;607          if (pParentRect) {
0005e8  b12f              CBZ      r7,|L1.1526|
;;;608            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
0005ea  463a              MOV      r2,r7
0005ec  4621              MOV      r1,r4
0005ee  4668              MOV      r0,sp
0005f0  f7fffffe          BL       GUI__IntersectRects
0005f4  e003              B        |L1.1534|
                  |L1.1526|
;;;609          } else {
;;;610            rWinClipped = pWin->Rect;
0005f6  e9d40100          LDRD     r0,r1,[r4,#0]
0005fa  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L1.1534|
;;;611          }
;;;612          /* Check if this window affects us at all */    
;;;613          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
0005fe  4669              MOV      r1,sp
000600  4628              MOV      r0,r5
000602  f7fffffe          BL       GUI_RectsIntersect
000606  b1f8              CBZ      r0,|L1.1608|
;;;614            if ((Status & WM_SF_HASTRANS) == 0) {
000608  f0180f01          TST      r8,#1
00060c  d107              BNE      |L1.1566|
;;;615              pRect->x0 = rWinClipped.x1+1;
00060e  f8bd0004          LDRH     r0,[sp,#4]
000612  1c40              ADDS     r0,r0,#1
000614  b200              SXTH     r0,r0
000616  8028              STRH     r0,[r5,#0]
;;;616              r = 1;
000618  f04f0b01          MOV      r11,#1
00061c  e014              B        |L1.1608|
                  |L1.1566|
;;;617            } else {
;;;618              /* Check all children */
;;;619              WM_HWIN hChild;
;;;620              WM_Obj* pChild;
;;;621              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
00061e  f9b49018          LDRSH    r9,[r4,#0x18]
000622  e00d              B        |L1.1600|
                  |L1.1572|
;;;622                pChild = WM_H2P(hChild);
000624  4648              MOV      r0,r9
000626  f7fffffe          BL       GUI_ALLOC_h2p
00062a  4682              MOV      r10,r0
;;;623                if (_Findx0(hChild, pRect, &rWinClipped)) {
00062c  466a              MOV      r2,sp
00062e  4629              MOV      r1,r5
000630  4648              MOV      r0,r9
000632  f7fffffe          BL       _Findx0
000636  b108              CBZ      r0,|L1.1596|
;;;624                  r = 1;
000638  f04f0b01          MOV      r11,#1
                  |L1.1596|
00063c  f9ba901a          LDRSH    r9,[r10,#0x1a]        ;621
                  |L1.1600|
000640  f1b90f00          CMP      r9,#0                 ;621
000644  d1ee              BNE      |L1.1572|
;;;625                }
;;;626              }
;;;627            }
000646  bf00              NOP      
                  |L1.1608|
;;;628          }
;;;629        }
000648  bf00              NOP      
                  |L1.1610|
00064a  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;603
                  |L1.1614|
00064e  2e00              CMP      r6,#0                 ;603
000650  d1c1              BNE      |L1.1494|
;;;630      }
;;;631      return r;
000652  4658              MOV      r0,r11
;;;632    }
000654  e8bd9ffc          POP      {r2-r12,pc}
;;;633    
                          ENDP

                  _Findx1 PROC
;;;637    */
;;;638    static void _Findx1(WM_HWIN hWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
000658  e92d47fc          PUSH     {r2-r10,lr}
00065c  4606              MOV      r6,r0
00065e  460d              MOV      r5,r1
000660  4617              MOV      r7,r2
;;;639      WM_Obj* pWin;
;;;640      for (; hWin; hWin = pWin->hNext) { 
000662  e036              B        |L1.1746|
                  |L1.1636|
;;;641        int Status = (pWin = WM_H2P(hWin))->Status;
000664  4630              MOV      r0,r6
000666  f7fffffe          BL       GUI_ALLOC_h2p
00066a  4604              MOV      r4,r0
00066c  f8b0801c          LDRH     r8,[r0,#0x1c]
;;;642        if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
000670  f0180f02          TST      r8,#2
000674  d02b              BEQ      |L1.1742|
;;;643          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;644          if (pParentRect) {
000676  b12f              CBZ      r7,|L1.1668|
;;;645            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
000678  463a              MOV      r2,r7
00067a  4621              MOV      r1,r4
00067c  4668              MOV      r0,sp
00067e  f7fffffe          BL       GUI__IntersectRects
000682  e003              B        |L1.1676|
                  |L1.1668|
;;;646          } else {
;;;647            rWinClipped = pWin->Rect;
000684  e9d40100          LDRD     r0,r1,[r4,#0]
000688  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L1.1676|
;;;648          }
;;;649          /* Check if this window affects us at all */    
;;;650          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
00068c  4669              MOV      r1,sp
00068e  4628              MOV      r0,r5
000690  f7fffffe          BL       GUI_RectsIntersect
000694  b1d0              CBZ      r0,|L1.1740|
;;;651            if ((Status & WM_SF_HASTRANS) == 0) {
000696  f0180f01          TST      r8,#1
00069a  d105              BNE      |L1.1704|
;;;652              pRect->x1 = rWinClipped.x0-1;
00069c  f8bd0000          LDRH     r0,[sp,#0]
0006a0  1e40              SUBS     r0,r0,#1
0006a2  b200              SXTH     r0,r0
0006a4  80a8              STRH     r0,[r5,#4]
0006a6  e011              B        |L1.1740|
                  |L1.1704|
;;;653            } else {
;;;654              /* Check all children */
;;;655              WM_HWIN hChild;
;;;656              WM_Obj* pChild;
;;;657              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
0006a8  f9b49018          LDRSH    r9,[r4,#0x18]
0006ac  e00a              B        |L1.1732|
                  |L1.1710|
;;;658                pChild = WM_H2P(hChild);
0006ae  4648              MOV      r0,r9
0006b0  f7fffffe          BL       GUI_ALLOC_h2p
0006b4  4682              MOV      r10,r0
;;;659                _Findx1(hChild, pRect, &rWinClipped);
0006b6  466a              MOV      r2,sp
0006b8  4629              MOV      r1,r5
0006ba  4648              MOV      r0,r9
0006bc  f7fffffe          BL       _Findx1
0006c0  f9ba901a          LDRSH    r9,[r10,#0x1a]        ;657
                  |L1.1732|
0006c4  f1b90f00          CMP      r9,#0                 ;657
0006c8  d1f1              BNE      |L1.1710|
;;;660              }
;;;661            }
0006ca  bf00              NOP      
                  |L1.1740|
;;;662          }
;;;663        }
0006cc  bf00              NOP      
                  |L1.1742|
0006ce  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;640
                  |L1.1746|
0006d2  2e00              CMP      r6,#0                 ;640
0006d4  d1c6              BNE      |L1.1636|
;;;664      }
;;;665    }
0006d6  e8bd87fc          POP      {r2-r10,pc}
;;;666    
                          ENDP

                  WM__GetClientRectWin PROC
;;;707    */
;;;708    void WM__GetClientRectWin(const WM_Obj* pWin, GUI_RECT* pRect) {
0006da  2200              MOVS     r2,#0
;;;709      pRect->x0 = pRect->y0 = 0;
0006dc  804a              STRH     r2,[r1,#2]
0006de  800a              STRH     r2,[r1,#0]
;;;710      pRect->x1 = pWin->Rect.x1 - pWin->Rect.x0;
0006e0  8882              LDRH     r2,[r0,#4]
0006e2  8803              LDRH     r3,[r0,#0]
0006e4  1ad2              SUBS     r2,r2,r3
0006e6  b212              SXTH     r2,r2
0006e8  808a              STRH     r2,[r1,#4]
;;;711      pRect->y1 = pWin->Rect.y1 - pWin->Rect.y0;
0006ea  88c2              LDRH     r2,[r0,#6]
0006ec  8843              LDRH     r3,[r0,#2]
0006ee  1ad2              SUBS     r2,r2,r3
0006f0  b212              SXTH     r2,r2
0006f2  80ca              STRH     r2,[r1,#6]
;;;712    }
0006f4  4770              BX       lr
;;;713    
                          ENDP

                  WM__GetInvalidRectAbs PROC
;;;717    */
;;;718    static void WM__GetInvalidRectAbs(WM_Obj* pWin, GUI_RECT* pRect) {
0006f6  6882              LDR      r2,[r0,#8]
;;;719      *pRect = pWin->InvalidRect;
0006f8  600a              STR      r2,[r1,#0]
0006fa  68c2              LDR      r2,[r0,#0xc]
0006fc  604a              STR      r2,[r1,#4]
;;;720    }
0006fe  4770              BX       lr
;;;721    
                          ENDP

                  WM_InvalidateRect PROC
;;;735    */
;;;736    void WM_InvalidateRect(WM_HWIN hWin, const GUI_RECT*pRect) {
000700  e92d41ff          PUSH     {r0-r8,lr}
000704  4605              MOV      r5,r0
000706  460e              MOV      r6,r1
;;;737      GUI_RECT r;
;;;738      WM_Obj* pWin;
;;;739      int Status;
;;;740      if (hWin) {
000708  b385              CBZ      r5,|L1.1900|
;;;741        WM_LOCK();
00070a  f7fffffe          BL       GUI_Lock
;;;742        pWin = WM_H2P(hWin);
00070e  4628              MOV      r0,r5
000710  f7fffffe          BL       GUI_ALLOC_h2p
000714  4604              MOV      r4,r0
;;;743        Status = pWin->Status;
000716  8ba7              LDRH     r7,[r4,#0x1c]
;;;744        if (Status & WM_SF_ISVIS) {
000718  f0170f02          TST      r7,#2
00071c  d024              BEQ      |L1.1896|
;;;745          r = pWin->Rect;
00071e  e9d40100          LDRD     r0,r1,[r4,#0]
000722  e9cd0102          STRD     r0,r1,[sp,#8]
;;;746          if (pRect) {
000726  b166              CBZ      r6,|L1.1858|
;;;747            GUI_RECT rPara;
;;;748            rPara = *pRect;
000728  6830              LDR      r0,[r6,#0]
00072a  9000              STR      r0,[sp,#0]
00072c  6870              LDR      r0,[r6,#4]
00072e  9001              STR      r0,[sp,#4]
;;;749            WM__Client2Screen(pWin, &rPara);
000730  4669              MOV      r1,sp
000732  4620              MOV      r0,r4
000734  f7fffffe          BL       WM__Client2Screen
;;;750            GUI__IntersectRect(&r, &rPara);
000738  4669              MOV      r1,sp
00073a  a802              ADD      r0,sp,#8
00073c  f7fffffe          BL       GUI__IntersectRect
;;;751          }
000740  bf00              NOP      
                  |L1.1858|
;;;752          if (WM__ClipAtParentBorders(&r, hWin)) {      /* Optimization that saves invalidation if window area is not visible ... Not required */
000742  4629              MOV      r1,r5
000744  a802              ADD      r0,sp,#8
000746  f7fffffe          BL       WM__ClipAtParentBorders
00074a  b168              CBZ      r0,|L1.1896|
;;;753            if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
00074c  f6400001          MOV      r0,#0x801
000750  4038              ANDS     r0,r0,r7
000752  2801              CMP      r0,#1
000754  d104              BNE      |L1.1888|
;;;754              WM__InvalidateAreaBelow(&r, hWin);        /* Can be optimized to spare windows above */
000756  4629              MOV      r1,r5
000758  a802              ADD      r0,sp,#8
00075a  f7fffffe          BL       WM__InvalidateAreaBelow
00075e  e003              B        |L1.1896|
                  |L1.1888|
;;;755            } else {
;;;756              _Invalidate1Abs(hWin, &r);
000760  a902              ADD      r1,sp,#8
000762  4628              MOV      r0,r5
000764  f7fffffe          BL       _Invalidate1Abs
                  |L1.1896|
;;;757            }
;;;758          }
;;;759        }
;;;760        WM_UNLOCK();
000768  f7fffffe          BL       GUI_Unlock
                  |L1.1900|
;;;761      }
;;;762    }
00076c  e8bd81ff          POP      {r0-r8,pc}
;;;763    
                          ENDP

                  WM_InvalidateWindow PROC
;;;769    */
;;;770    void WM_InvalidateWindow(WM_HWIN hWin) {
000770  b510              PUSH     {r4,lr}
000772  4604              MOV      r4,r0
;;;771      WM_InvalidateRect(hWin, NULL);
000774  2100              MOVS     r1,#0
000776  4620              MOV      r0,r4
000778  f7fffffe          BL       WM_InvalidateRect
;;;772    }
00077c  bd10              POP      {r4,pc}
;;;773    
                          ENDP

                  WM_CreateWindowAsChild PROC
;;;801    */
;;;802    WM_HWIN WM_CreateWindowAsChild( int x0, int y0, int width, int height
00077e  e92d4fff          PUSH     {r0-r11,lr}
;;;803                                   ,WM_HWIN hParent, U16 Style, WM_CALLBACK* cb
;;;804                                   ,int NumExtraBytes) {
000782  b081              SUB      sp,sp,#4
000784  4680              MOV      r8,r0
000786  4689              MOV      r9,r1
000788  4692              MOV      r10,r2
00078a  469b              MOV      r11,r3
00078c  e9dd750e          LDRD     r7,r5,[sp,#0x38]
;;;805      WM_Obj* pWin;
;;;806      WM_HWIN hWin;
;;;807      WM_ASSERT_NOT_IN_PAINT();
;;;808      WM_LOCK();
000790  f7fffffe          BL       GUI_Lock
;;;809      Style |= WM__CreateFlags;
000794  4929              LDR      r1,|L1.2108|
000796  8809              LDRH     r1,[r1,#0]  ; WM__CreateFlags
000798  430d              ORRS     r5,r5,r1
;;;810      /* Default parent is Desktop 0 */
;;;811      if (!hParent) {
00079a  b92f              CBNZ     r7,|L1.1960|
;;;812        if (WM__NumWindows) {
00079c  4825              LDR      r0,|L1.2100|
00079e  8800              LDRH     r0,[r0,#0]  ; WM__NumWindows
0007a0  b110              CBZ      r0,|L1.1960|
;;;813        #if GUI_NUM_LAYERS == 1
;;;814          hParent = WM__ahDesktopWin[0];
0007a2  4827              LDR      r0,|L1.2112|
0007a4  f9b07000          LDRSH    r7,[r0,#0]  ; WM__ahDesktopWin
                  |L1.1960|
;;;815        #else
;;;816          hParent = WM__ahDesktopWin[GUI_Context.SelLayer];
;;;817        #endif
;;;818        }
;;;819      }
;;;820      if (hParent == WM_UNATTACHED) {
0007a8  1c78              ADDS     r0,r7,#1
0007aa  d100              BNE      |L1.1966|
;;;821        hParent = WM_HWIN_NULL;
0007ac  2700              MOVS     r7,#0
                  |L1.1966|
;;;822      }  
;;;823      if (hParent) {
0007ae  b1f7              CBZ      r7,|L1.2030|
;;;824        WM_Obj* pParent = WM_H2P(hParent);
0007b0  4638              MOV      r0,r7
0007b2  f7fffffe          BL       GUI_ALLOC_h2p
0007b6  4606              MOV      r6,r0
;;;825        x0 += pParent->Rect.x0;
0007b8  f9b60000          LDRSH    r0,[r6,#0]
0007bc  4480              ADD      r8,r8,r0
;;;826        y0 += pParent->Rect.y0;
0007be  f9b60002          LDRSH    r0,[r6,#2]
0007c2  4481              ADD      r9,r9,r0
;;;827        if (width==0) {
0007c4  f1ba0f00          CMP      r10,#0
0007c8  d106              BNE      |L1.2008|
;;;828          width = pParent->Rect.x1 - pParent->Rect.x0+1;
0007ca  f9b60004          LDRSH    r0,[r6,#4]
0007ce  f9b61000          LDRSH    r1,[r6,#0]
0007d2  1a40              SUBS     r0,r0,r1
0007d4  f1000a01          ADD      r10,r0,#1
                  |L1.2008|
;;;829        }
;;;830        if (height==0) {
0007d8  f1bb0f00          CMP      r11,#0
0007dc  d106              BNE      |L1.2028|
;;;831          height = pParent->Rect.y1 - pParent->Rect.y0+1;
0007de  f9b60006          LDRSH    r0,[r6,#6]
0007e2  f9b61002          LDRSH    r1,[r6,#2]
0007e6  1a40              SUBS     r0,r0,r1
0007e8  f1000b01          ADD      r11,r0,#1
                  |L1.2028|
;;;832        }
;;;833      }
0007ec  bf00              NOP      
                  |L1.2030|
;;;834      if ((hWin = (WM_HWIN) GUI_ALLOC_AllocZero(NumExtraBytes + sizeof(WM_Obj))) == 0) {
0007ee  9811              LDR      r0,[sp,#0x44]
0007f0  3020              ADDS     r0,r0,#0x20
0007f2  b200              SXTH     r0,r0
0007f4  f7fffffe          BL       GUI_ALLOC_AllocZero
0007f8  9000              STR      r0,[sp,#0]
0007fa  b3e8              CBZ      r0,|L1.2168|
;;;835        GUI_DEBUG_ERROROUT("WM_CreateWindow: No memory to create window");
;;;836      } else {
;;;837        WM__NumWindows++;
0007fc  480d              LDR      r0,|L1.2100|
0007fe  8800              LDRH     r0,[r0,#0]  ; WM__NumWindows
000800  1c40              ADDS     r0,r0,#1
000802  490c              LDR      r1,|L1.2100|
000804  8008              STRH     r0,[r1,#0]
;;;838        pWin = WM_H2P(hWin);
000806  9800              LDR      r0,[sp,#0]
000808  f7fffffe          BL       GUI_ALLOC_h2p
00080c  4604              MOV      r4,r0
;;;839        pWin->Rect.x0 = x0;
00080e  fa0ff088          SXTH     r0,r8
000812  8020              STRH     r0,[r4,#0]
;;;840        pWin->Rect.y0 = y0;
000814  fa0ff089          SXTH     r0,r9
000818  8060              STRH     r0,[r4,#2]
;;;841        pWin->Rect.x1 = x0 + width - 1;
00081a  eb08000a          ADD      r0,r8,r10
00081e  1e40              SUBS     r0,r0,#1
000820  b200              SXTH     r0,r0
000822  e00f              B        |L1.2116|
                  |L1.2084|
                          DCD      WM__hWinFocus
                  |L1.2088|
                          DCD      WM__hCapture
                  |L1.2092|
                          DCD      WM__TransWindowCnt
                  |L1.2096|
                          DCD      WM__NumInvalidWindows
                  |L1.2100|
                          DCD      WM__NumWindows
                  |L1.2104|
                          DCD      WM__FirstWin
                  |L1.2108|
                          DCD      WM__CreateFlags
                  |L1.2112|
                          DCD      WM__ahDesktopWin
                  |L1.2116|
000844  80a0              STRH     r0,[r4,#4]
;;;842        pWin->Rect.y1 = y0 + height - 1;
000846  eb09000b          ADD      r0,r9,r11
00084a  1e40              SUBS     r0,r0,#1
00084c  b200              SXTH     r0,r0
00084e  80e0              STRH     r0,[r4,#6]
;;;843        pWin->cb = cb;
000850  9810              LDR      r0,[sp,#0x40]
000852  6120              STR      r0,[r4,#0x10]
;;;844        /* Copy the flags which can simply be accepted */
;;;845        pWin->Status |= (Style & (WM_CF_SHOW |
000854  8ba0              LDRH     r0,[r4,#0x1c]
000856  f643718f          MOV      r1,#0x3f8f
00085a  4029              ANDS     r1,r1,r5
00085c  4308              ORRS     r0,r0,r1
00085e  83a0              STRH     r0,[r4,#0x1c]
;;;846                                  WM_SF_MEMDEV |
;;;847                                  WM_CF_MEMDEV_ON_REDRAW |
;;;848                                  WM_SF_STAYONTOP |
;;;849                                  WM_SF_CONST_OUTLINE |
;;;850                                  WM_SF_HASTRANS |
;;;851                                  WM_CF_ANCHOR_RIGHT |
;;;852                                  WM_CF_ANCHOR_BOTTOM |
;;;853                                  WM_CF_ANCHOR_LEFT |
;;;854                                  WM_CF_ANCHOR_TOP |
;;;855                                  WM_CF_LATE_CLIP));
;;;856        /* Add to linked lists */
;;;857        _AddToLinList(hWin);
000860  9800              LDR      r0,[sp,#0]
000862  f7fffffe          BL       _AddToLinList
;;;858        WM__InsertWindowIntoList(hWin, hParent);
000866  4639              MOV      r1,r7
000868  9800              LDR      r0,[sp,#0]
00086a  f7fffffe          BL       WM__InsertWindowIntoList
;;;859        /* Activate window if WM_CF_ACTIVATE is specified */
;;;860        if (Style & WM_CF_ACTIVATE) {
00086e  f0150f20          TST      r5,#0x20
000872  d004              BEQ      |L1.2174|
;;;861          WM_SelectWindow(hWin);  /* This is not needed if callbacks are being used, but it does not cost a lot and makes life easier ... */
000874  9800              LDR      r0,[sp,#0]
000876  e000              B        |L1.2170|
                  |L1.2168|
000878  e01d              B        |L1.2230|
                  |L1.2170|
00087a  f7fffffe          BL       WM_SelectWindow
                  |L1.2174|
;;;862        }
;;;863        /* Handle the Style flags, one at a time */
;;;864        #if WM_SUPPORT_TRANSPARENCY
;;;865          if (Style & WM_SF_HASTRANS) {
00087e  f0150f01          TST      r5,#1
000882  d004              BEQ      |L1.2190|
;;;866            WM__TransWindowCnt++;          /* Increment counter for transparency windows */
000884  48ff              LDR      r0,|L1.3204|
000886  6800              LDR      r0,[r0,#0]  ; WM__TransWindowCnt
000888  1c40              ADDS     r0,r0,#1
00088a  49fe              LDR      r1,|L1.3204|
00088c  6008              STR      r0,[r1,#0]  ; WM__TransWindowCnt
                  |L1.2190|
;;;867          }
;;;868        #endif
;;;869        if (Style & WM_CF_BGND) {
00088e  f0150f40          TST      r5,#0x40
000892  d002              BEQ      |L1.2202|
;;;870          WM_BringToBottom(hWin);
000894  9800              LDR      r0,[sp,#0]
000896  f7fffffe          BL       WM_BringToBottom
                  |L1.2202|
;;;871        }
;;;872        if (Style & WM_CF_SHOW) {
00089a  f0150f02          TST      r5,#2
00089e  d006              BEQ      |L1.2222|
;;;873          pWin->Status |= WM_SF_ISVIS;  /* Set Visibility flag */
0008a0  8ba0              LDRH     r0,[r4,#0x1c]
0008a2  f0400002          ORR      r0,r0,#2
0008a6  83a0              STRH     r0,[r4,#0x1c]
;;;874          WM_InvalidateWindow(hWin);    /* Mark content as invalid */
0008a8  9800              LDR      r0,[sp,#0]
0008aa  f7fffffe          BL       WM_InvalidateWindow
                  |L1.2222|
;;;875        }
;;;876        WM__SendMsgNoData(hWin, WM_CREATE);
0008ae  2101              MOVS     r1,#1
0008b0  9800              LDR      r0,[sp,#0]
0008b2  f7fffffe          BL       WM__SendMsgNoData
                  |L1.2230|
;;;877      }
;;;878      WM_UNLOCK();
0008b6  f7fffffe          BL       GUI_Unlock
;;;879      return hWin;
0008ba  9800              LDR      r0,[sp,#0]
;;;880    }
0008bc  b005              ADD      sp,sp,#0x14
0008be  e8bd8ff0          POP      {r4-r11,pc}
;;;881    
                          ENDP

                  WM_CreateWindow PROC
;;;885    */
;;;886    WM_HWIN WM_CreateWindow(int x0, int y0, int width, int height, U16 Style, WM_CALLBACK* cb, int NumExtraBytes) {
0008c2  e92d47ff          PUSH     {r0-r10,lr}
0008c6  4604              MOV      r4,r0
0008c8  460d              MOV      r5,r1
0008ca  4616              MOV      r6,r2
0008cc  461f              MOV      r7,r3
0008ce  e9dd9a0d          LDRD     r9,r10,[sp,#0x34]
0008d2  f8dd8030          LDR      r8,[sp,#0x30]
;;;887      return WM_CreateWindowAsChild(x0,y0,width,height, 0 /* No parent */,  Style, cb, NumExtraBytes);
0008d6  2000              MOVS     r0,#0
0008d8  463b              MOV      r3,r7
0008da  4632              MOV      r2,r6
0008dc  4629              MOV      r1,r5
0008de  e88d0701          STM      sp,{r0,r8-r10}
0008e2  4620              MOV      r0,r4
0008e4  f7fffffe          BL       WM_CreateWindowAsChild
;;;888    }
0008e8  b004              ADD      sp,sp,#0x10
0008ea  e8bd87f0          POP      {r4-r10,pc}
;;;889    
                          ENDP

                  WM_GetActiveWindow PROC
;;;993    */
;;;994    WM_HWIN WM_GetActiveWindow(void) {
0008ee  48e6              LDR      r0,|L1.3208|
;;;995      return GUI_Context.hAWin;
0008f0  f9b0003c          LDRSH    r0,[r0,#0x3c]  ; GUI_Context
;;;996    }
0008f4  4770              BX       lr
;;;997    
                          ENDP

                  _FindNext_IVR PROC
;;;1028   #if WM_SUPPORT_OBSTRUCT
;;;1029   static int _FindNext_IVR(void) {
0008f6  b57c              PUSH     {r2-r6,lr}
;;;1030     WM_HMEM hParent;
;;;1031     GUI_RECT r;
;;;1032     WM_Obj* pAWin;
;;;1033     WM_Obj* pParent;
;;;1034     r = _ClipContext.CurRect;  /* temps  so we do not have to work with pointers too much */
0008f8  49e4              LDR      r1,|L1.3212|
0008fa  e9d10102          LDRD     r0,r1,[r1,#8]
0008fe  e9cd0100          STRD     r0,r1,[sp,#0]
;;;1035     /*
;;;1036        STEP 1:
;;;1037          Set the next position which could be part of the next IVR
;;;1038          This will be the first unhandle pixel in reading order, i.e. next one to the right
;;;1039          or next one down if we are at the right border.
;;;1040     */
;;;1041     if (_ClipContext.Cnt == 0) {       /* First IVR starts in upper left */
000902  48e2              LDR      r0,|L1.3212|
000904  6900              LDR      r0,[r0,#0x10]  ; _ClipContext
000906  b940              CBNZ     r0,|L1.2330|
;;;1042       r.x0 = _ClipContext.ClientRect.x0;
000908  48e0              LDR      r0,|L1.3212|
00090a  8800              LDRH     r0,[r0,#0]  ; _ClipContext
00090c  f8ad0000          STRH     r0,[sp,#0]
;;;1043       r.y0 = _ClipContext.ClientRect.y0;
000910  48de              LDR      r0,|L1.3212|
000912  8840              LDRH     r0,[r0,#2]  ; _ClipContext
000914  f8ad0002          STRH     r0,[sp,#2]
000918  e01b              B        |L1.2386|
                  |L1.2330|
;;;1044     } else {
;;;1045       r.x0 = _ClipContext.CurRect.x1+1;
00091a  48dc              LDR      r0,|L1.3212|
00091c  8980              LDRH     r0,[r0,#0xc]
00091e  1c40              ADDS     r0,r0,#1
000920  b200              SXTH     r0,r0
000922  f8ad0000          STRH     r0,[sp,#0]
;;;1046       r.y0 = _ClipContext.CurRect.y0;
000926  48d9              LDR      r0,|L1.3212|
000928  8940              LDRH     r0,[r0,#0xa]
00092a  f8ad0002          STRH     r0,[sp,#2]
;;;1047       if (r.x0 > _ClipContext.ClientRect.x1) {
00092e  f9bd0000          LDRSH    r0,[sp,#0]
000932  49d6              LDR      r1,|L1.3212|
000934  f9b11004          LDRSH    r1,[r1,#4]  ; _ClipContext
000938  4288              CMP      r0,r1
00093a  dd0a              BLE      |L1.2386|
;;;1048   NextStripe:  /* go down to next stripe */
00093c  bf00              NOP      
                  |L1.2366|
;;;1049         r.x0 = _ClipContext.ClientRect.x0;
00093e  48d3              LDR      r0,|L1.3212|
000940  8800              LDRH     r0,[r0,#0]  ; _ClipContext
000942  f8ad0000          STRH     r0,[sp,#0]
;;;1050         r.y0 = _ClipContext.CurRect.y1+1;
000946  48d1              LDR      r0,|L1.3212|
000948  89c0              LDRH     r0,[r0,#0xe]
00094a  1c40              ADDS     r0,r0,#1
00094c  b200              SXTH     r0,r0
00094e  f8ad0002          STRH     r0,[sp,#2]
                  |L1.2386|
;;;1051       }
;;;1052     }
;;;1053     /*
;;;1054        STEP 2:
;;;1055          Check if we are done completely.
;;;1056     */
;;;1057     if (r.y0 >_ClipContext.ClientRect.y1) {
000952  f9bd0002          LDRSH    r0,[sp,#2]
000956  49cd              LDR      r1,|L1.3212|
000958  f9b11006          LDRSH    r1,[r1,#6]  ; _ClipContext
00095c  4288              CMP      r0,r1
00095e  dd01              BLE      |L1.2404|
;;;1058       return 0;
000960  2000              MOVS     r0,#0
                  |L1.2402|
;;;1059     }
;;;1060     /* STEP 3:
;;;1061          Find out the max. height (r.y1) if we are at the left border.
;;;1062          Since we are using the same height for all IVRs at the same y0,
;;;1063          we do this only for the leftmost one.
;;;1064     */
;;;1065     pAWin = WM_H2P(GUI_Context.hAWin);
;;;1066     if (r.x0 == _ClipContext.ClientRect.x0) {
;;;1067       r.y1 = _ClipContext.ClientRect.y1;
;;;1068       r.x1 = _ClipContext.ClientRect.x1;
;;;1069       /* Iterate over all windows which are above */
;;;1070       /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
;;;1071       for (hParent = GUI_Context.hAWin; hParent; hParent = pParent->hParent) {
;;;1072         pParent = WM_H2P(hParent);
;;;1073         _Findy1(pParent->hNext, &r, NULL);
;;;1074       }
;;;1075       /* Check all children */
;;;1076       _Findy1(pAWin->hFirstChild, &r, NULL);
;;;1077     }
;;;1078     /* 
;;;1079       STEP 4
;;;1080         Find out x0 for the given y0, y1 by iterating over windows above.
;;;1081         if we find one that intersects, adjust x0 to the right.
;;;1082     */
;;;1083   Find_x0:
;;;1084     r.x1 = r.x0;
;;;1085     /* Iterate over all windows which are above */
;;;1086     /* Check all siblings above (siblings of window, siblings of parents, etc ...) */
;;;1087     #if 0   /* This is a planned, but not yet released optimization */
;;;1088       if (Status & WM_SF_DONT_CLIP_SIBLINGS)
;;;1089       {
;;;1090         hParent = pAWin->hParent;
;;;1091       } else
;;;1092     #endif
;;;1093     {
;;;1094       hParent = GUI_Context.hAWin;
;;;1095     }
;;;1096     for (; hParent; hParent = pParent->hParent) {
;;;1097       pParent = WM_H2P(hParent);
;;;1098       if (_Findx0(pParent->hNext, &r, NULL)) {
;;;1099         goto Find_x0;
;;;1100       }
;;;1101     }
;;;1102     /* Check all children */
;;;1103     if (_Findx0(pAWin->hFirstChild, &r, NULL)) {
;;;1104       goto Find_x0;
;;;1105     }
;;;1106     /* 
;;;1107      STEP 5:
;;;1108        If r.x0 out of right border, this stripe is done. Set next stripe and goto STEP 2
;;;1109        Find out x1 for the given x0, y0, y1
;;;1110     */
;;;1111     r.x1 = _ClipContext.ClientRect.x1;
;;;1112     if (r.x1 < r.x0) {/* horizontal border reached ? */
;;;1113       _ClipContext.CurRect = r;
;;;1114       goto NextStripe;
;;;1115     }    
;;;1116     /* 
;;;1117      STEP 6:
;;;1118        Find r.x1. We have to Iterate over all windows which are above
;;;1119     */
;;;1120     /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
;;;1121     #if 0   /* This is a planned, but not yet released optimization */
;;;1122       if (Status & WM_SF_DONT_CLIP_SIBLINGS)
;;;1123       {
;;;1124         hParent = pAWin->hParent;
;;;1125       } else
;;;1126     #endif
;;;1127     {
;;;1128       hParent = GUI_Context.hAWin;
;;;1129     }
;;;1130     for (; hParent; hParent = pParent->hParent) {
;;;1131       pParent = WM_H2P(hParent);
;;;1132       _Findx1(pParent->hNext, &r, NULL);
;;;1133     }
;;;1134     /* Check all children */
;;;1135     _Findx1(pAWin->hFirstChild, &r, NULL);
;;;1136     /* We are done. Return the rectangle we found in the _ClipContext. */
;;;1137     if (_ClipContext.Cnt >200) {
;;;1138       return 0;  /* error !!! This should not happen !*/
;;;1139     }
;;;1140     _ClipContext.CurRect = r;
;;;1141     return 1;  /* IVR is valid ! */
;;;1142   }
000962  bd7c              POP      {r2-r6,pc}
                  |L1.2404|
000964  49c8              LDR      r1,|L1.3208|
000966  f9b1003c          LDRSH    r0,[r1,#0x3c]         ;1065  ; GUI_Context
00096a  f7fffffe          BL       GUI_ALLOC_h2p
00096e  4605              MOV      r5,r0                 ;1065
000970  f9bd0000          LDRSH    r0,[sp,#0]            ;1066
000974  49c5              LDR      r1,|L1.3212|
000976  f9b11000          LDRSH    r1,[r1,#0]            ;1066  ; _ClipContext
00097a  4288              CMP      r0,r1                 ;1066
00097c  d11f              BNE      |L1.2494|
00097e  48c3              LDR      r0,|L1.3212|
000980  88c0              LDRH     r0,[r0,#6]            ;1067  ; _ClipContext
000982  f8ad0006          STRH     r0,[sp,#6]            ;1067
000986  48c1              LDR      r0,|L1.3212|
000988  8880              LDRH     r0,[r0,#4]            ;1068  ; _ClipContext
00098a  f8ad0004          STRH     r0,[sp,#4]            ;1068
00098e  48be              LDR      r0,|L1.3208|
000990  f9b0603c          LDRSH    r6,[r0,#0x3c]         ;1071  ; GUI_Context
000994  e00b              B        |L1.2478|
                  |L1.2454|
000996  4630              MOV      r0,r6                 ;1072
000998  f7fffffe          BL       GUI_ALLOC_h2p
00099c  4604              MOV      r4,r0                 ;1072
00099e  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1073
0009a2  2200              MOVS     r2,#0                 ;1073
0009a4  4669              MOV      r1,sp                 ;1073
0009a6  f7fffffe          BL       _Findy1
0009aa  f9b46016          LDRSH    r6,[r4,#0x16]         ;1071
                  |L1.2478|
0009ae  2e00              CMP      r6,#0                 ;1071
0009b0  d1f1              BNE      |L1.2454|
0009b2  f9b50018          LDRSH    r0,[r5,#0x18]         ;1076
0009b6  2200              MOVS     r2,#0                 ;1076
0009b8  4669              MOV      r1,sp                 ;1076
0009ba  f7fffffe          BL       _Findy1
                  |L1.2494|
0009be  bf00              NOP                            ;1083
                  |L1.2496|
0009c0  f8bd0000          LDRH     r0,[sp,#0]            ;1084
0009c4  f8ad0004          STRH     r0,[sp,#4]            ;1084
0009c8  48af              LDR      r0,|L1.3208|
0009ca  f9b0603c          LDRSH    r6,[r0,#0x3c]         ;1094  ; GUI_Context
0009ce  e00d              B        |L1.2540|
                  |L1.2512|
0009d0  4630              MOV      r0,r6                 ;1097
0009d2  f7fffffe          BL       GUI_ALLOC_h2p
0009d6  4604              MOV      r4,r0                 ;1097
0009d8  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1098
0009dc  2200              MOVS     r2,#0                 ;1098
0009de  4669              MOV      r1,sp                 ;1098
0009e0  f7fffffe          BL       _Findx0
0009e4  b100              CBZ      r0,|L1.2536|
0009e6  e7eb              B        |L1.2496|
                  |L1.2536|
0009e8  f9b46016          LDRSH    r6,[r4,#0x16]         ;1096
                  |L1.2540|
0009ec  2e00              CMP      r6,#0                 ;1096
0009ee  d1ef              BNE      |L1.2512|
0009f0  f9b50018          LDRSH    r0,[r5,#0x18]         ;1103
0009f4  2200              MOVS     r2,#0                 ;1103
0009f6  4669              MOV      r1,sp                 ;1103
0009f8  f7fffffe          BL       _Findx0
0009fc  b100              CBZ      r0,|L1.2560|
0009fe  e7df              B        |L1.2496|
                  |L1.2560|
000a00  48a2              LDR      r0,|L1.3212|
000a02  8880              LDRH     r0,[r0,#4]            ;1111  ; _ClipContext
000a04  f8ad0004          STRH     r0,[sp,#4]            ;1111
000a08  f9bd0004          LDRSH    r0,[sp,#4]            ;1112
000a0c  f9bd1000          LDRSH    r1,[sp,#0]            ;1112
000a10  4288              CMP      r0,r1                 ;1112
000a12  da05              BGE      |L1.2592|
000a14  489d              LDR      r0,|L1.3212|
000a16  e9dd1200          LDRD     r1,r2,[sp,#0]         ;1113
000a1a  e9c01202          STRD     r1,r2,[r0,#8]         ;1113
000a1e  e78e              B        |L1.2366|
                  |L1.2592|
000a20  4899              LDR      r0,|L1.3208|
000a22  f9b0603c          LDRSH    r6,[r0,#0x3c]         ;1128  ; GUI_Context
000a26  e00b              B        |L1.2624|
                  |L1.2600|
000a28  4630              MOV      r0,r6                 ;1131
000a2a  f7fffffe          BL       GUI_ALLOC_h2p
000a2e  4604              MOV      r4,r0                 ;1131
000a30  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1132
000a34  2200              MOVS     r2,#0                 ;1132
000a36  4669              MOV      r1,sp                 ;1132
000a38  f7fffffe          BL       _Findx1
000a3c  f9b46016          LDRSH    r6,[r4,#0x16]         ;1130
                  |L1.2624|
000a40  2e00              CMP      r6,#0                 ;1130
000a42  d1f1              BNE      |L1.2600|
000a44  f9b50018          LDRSH    r0,[r5,#0x18]         ;1135
000a48  2200              MOVS     r2,#0                 ;1135
000a4a  4669              MOV      r1,sp                 ;1135
000a4c  f7fffffe          BL       _Findx1
000a50  488e              LDR      r0,|L1.3212|
000a52  6900              LDR      r0,[r0,#0x10]         ;1137  ; _ClipContext
000a54  28c8              CMP      r0,#0xc8              ;1137
000a56  dd01              BLE      |L1.2652|
000a58  2000              MOVS     r0,#0                 ;1138
000a5a  e782              B        |L1.2402|
                  |L1.2652|
000a5c  488b              LDR      r0,|L1.3212|
000a5e  e9dd1200          LDRD     r1,r2,[sp,#0]         ;1140
000a62  e9c01202          STRD     r1,r2,[r0,#8]         ;1140
000a66  2001              MOVS     r0,#1                 ;1141
000a68  e77b              B        |L1.2402|
;;;1143   
                          ENDP

                  WM__GetNextIVR PROC
;;;1167   */
;;;1168   int  WM__GetNextIVR(void) {
000a6a  b510              PUSH     {r4,lr}
;;;1169     #if GUI_SUPPORT_CURSOR
;;;1170       static char _CursorHidden;
;;;1171     #endif
;;;1172     /* If WM is not active, we have no rectangles to return */
;;;1173     if (WM_IsActive==0) {
000a6c  4888              LDR      r0,|L1.3216|
000a6e  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
000a70  b908              CBNZ     r0,|L1.2678|
;;;1174       return 0;
000a72  2000              MOVS     r0,#0
                  |L1.2676|
;;;1175     }
;;;1176     if (_ClipContext.EntranceCnt > 1) {
;;;1177       _ClipContext.EntranceCnt--;
;;;1178       return 0;
;;;1179     }
;;;1180     #if GUI_SUPPORT_CURSOR
;;;1181       if (_CursorHidden) {
;;;1182         _CursorHidden = 0;
;;;1183         (*GUI_CURSOR_pfTempUnhide) ();
;;;1184       }
;;;1185     #endif
;;;1186     ++_ClipContext.Cnt;
;;;1187     /* Find next rectangle and use it as ClipRect */
;;;1188     if (!_FindNext_IVR()) {
;;;1189       _ClipContext.EntranceCnt--;  /* This search is over ! */
;;;1190       return 0;        /* Could not find an other one ! */
;;;1191     }
;;;1192     WM__ActivateClipRect();
;;;1193     /* Hide cursor if necessary */
;;;1194     #if GUI_SUPPORT_CURSOR
;;;1195       if (GUI_CURSOR_pfTempHide) {
;;;1196         _CursorHidden = (*GUI_CURSOR_pfTempHide) ( &_ClipContext.CurRect);
;;;1197       }
;;;1198     #endif
;;;1199     return 1;
;;;1200   }
000a74  bd10              POP      {r4,pc}
                  |L1.2678|
000a76  4885              LDR      r0,|L1.3212|
000a78  6940              LDR      r0,[r0,#0x14]         ;1176  ; _ClipContext
000a7a  2801              CMP      r0,#1                 ;1176
000a7c  dd06              BLE      |L1.2700|
000a7e  4883              LDR      r0,|L1.3212|
000a80  6940              LDR      r0,[r0,#0x14]         ;1177  ; _ClipContext
000a82  1e40              SUBS     r0,r0,#1              ;1177
000a84  4981              LDR      r1,|L1.3212|
000a86  6148              STR      r0,[r1,#0x14]         ;1177  ; _ClipContext
000a88  2000              MOVS     r0,#0                 ;1178
000a8a  e7f3              B        |L1.2676|
                  |L1.2700|
000a8c  4881              LDR      r0,|L1.3220|
000a8e  7800              LDRB     r0,[r0,#0]            ;1181  ; _CursorHidden
000a90  b128              CBZ      r0,|L1.2718|
000a92  2000              MOVS     r0,#0                 ;1182
000a94  497f              LDR      r1,|L1.3220|
000a96  7008              STRB     r0,[r1,#0]            ;1182
000a98  487f              LDR      r0,|L1.3224|
000a9a  6800              LDR      r0,[r0,#0]            ;1183  ; GUI_CURSOR_pfTempUnhide
000a9c  4780              BLX      r0                    ;1183
                  |L1.2718|
000a9e  487b              LDR      r0,|L1.3212|
000aa0  6900              LDR      r0,[r0,#0x10]         ;1186  ; _ClipContext
000aa2  1c40              ADDS     r0,r0,#1              ;1186
000aa4  4979              LDR      r1,|L1.3212|
000aa6  6108              STR      r0,[r1,#0x10]         ;1186  ; _ClipContext
000aa8  f7fffffe          BL       _FindNext_IVR
000aac  b930              CBNZ     r0,|L1.2748|
000aae  4877              LDR      r0,|L1.3212|
000ab0  6940              LDR      r0,[r0,#0x14]         ;1189  ; _ClipContext
000ab2  1e40              SUBS     r0,r0,#1              ;1189
000ab4  4975              LDR      r1,|L1.3212|
000ab6  6148              STR      r0,[r1,#0x14]         ;1189  ; _ClipContext
000ab8  2000              MOVS     r0,#0                 ;1190
000aba  e7db              B        |L1.2676|
                  |L1.2748|
000abc  f7fffffe          BL       WM__ActivateClipRect
000ac0  4876              LDR      r0,|L1.3228|
000ac2  6800              LDR      r0,[r0,#0]            ;1195  ; GUI_CURSOR_pfTempHide
000ac4  b130              CBZ      r0,|L1.2772|
000ac6  4871              LDR      r0,|L1.3212|
000ac8  3008              ADDS     r0,r0,#8              ;1196
000aca  4974              LDR      r1,|L1.3228|
000acc  6809              LDR      r1,[r1,#0]            ;1196  ; GUI_CURSOR_pfTempHide
000ace  4788              BLX      r1                    ;1196
000ad0  4970              LDR      r1,|L1.3220|
000ad2  7008              STRB     r0,[r1,#0]            ;1196
                  |L1.2772|
000ad4  2001              MOVS     r0,#1                 ;1199
000ad6  e7cd              B        |L1.2676|
;;;1201   
                          ENDP

                  WM__InitIVRSearch PROC
;;;1213   */
;;;1214   int WM__InitIVRSearch(const GUI_RECT* pMaxRect) {
000ad8  b57f              PUSH     {r0-r6,lr}
000ada  4605              MOV      r5,r0
;;;1215     GUI_RECT r;
;;;1216     WM_Obj* pAWin;
;;;1217     GUI_ASSERT_LOCK();   /* GUI_LOCK must have been "called" before entering this (normally done indrawing routine) */
;;;1218      /* If WM is not active -> nothing to do, leave cliprect alone */
;;;1219     if (WM_IsActive==0) {
000adc  486c              LDR      r0,|L1.3216|
000ade  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
000ae0  b920              CBNZ     r0,|L1.2796|
;;;1220       WM__ActivateClipRect();
000ae2  f7fffffe          BL       WM__ActivateClipRect
;;;1221       return 1;
000ae6  2001              MOVS     r0,#1
                  |L1.2792|
;;;1222     }
;;;1223     /* If we entered multiple times, leave Cliprect alone */
;;;1224     if (++_ClipContext.EntranceCnt > 1)
;;;1225       return 1;
;;;1226     pAWin = WM_H2P(GUI_Context.hAWin);
;;;1227     _ClipContext.Cnt        = -1;
;;;1228    /* When using callback mechanism, it is legal to reduce drawing
;;;1229       area to the invalid area ! */
;;;1230     if (WM__PaintCallbackCnt) {
;;;1231       WM__GetInvalidRectAbs(pAWin, &r);
;;;1232     } else {  /* Not using callback mechanism, therefor allow entire rectangle */
;;;1233       if (pAWin->Status & WM_SF_ISVIS) {
;;;1234         r = pAWin->Rect;
;;;1235       } else {
;;;1236         --_ClipContext.EntranceCnt;
;;;1237         return 0;  /* window is not even visible ! */
;;;1238       }
;;;1239     }
;;;1240     /* If the drawing routine has specified a rectangle, use it to reduce the rectangle */
;;;1241     if (pMaxRect) {
;;;1242       GUI__IntersectRect(&r, pMaxRect);
;;;1243     }
;;;1244     /* If user has reduced the cliprect size, reduce the rectangle */
;;;1245     if (GUI_Context.WM__pUserClipRect) {
;;;1246       WM_Obj* pWin = pAWin;
;;;1247       GUI_RECT rUser = *(GUI_Context.WM__pUserClipRect);
;;;1248       #if WM_SUPPORT_TRANSPARENCY
;;;1249         if (WM__hATransWindow) {
;;;1250           pWin = WM_H2P(WM__hATransWindow);
;;;1251         }   
;;;1252       #endif
;;;1253       WM__Client2Screen(pWin, &rUser);
;;;1254       GUI__IntersectRect(&r, &rUser);
;;;1255     }
;;;1256     /* For transparent windows, we need to further reduce the rectangle */
;;;1257     #if WM_SUPPORT_TRANSPARENCY
;;;1258       if (WM__hATransWindow) {
;;;1259         if (WM__ClipAtParentBorders(&r, WM__hATransWindow) == 0) {
;;;1260           --_ClipContext.EntranceCnt;
;;;1261           return 0;           /* Nothing to draw */
;;;1262         }
;;;1263       }
;;;1264     #endif
;;;1265     /* Iterate over all ancestors and clip at their borders. If there is no visible part, we are done */
;;;1266     if (WM__ClipAtParentBorders(&r, GUI_Context.hAWin) == 0) {
;;;1267       --_ClipContext.EntranceCnt;
;;;1268       return 0;           /* Nothing to draw */
;;;1269     }
;;;1270     /* Store the rectangle and find the first rectangle of the area */
;;;1271     _ClipContext.ClientRect = r;
;;;1272     return WM__GetNextIVR();
;;;1273   }
000ae8  b004              ADD      sp,sp,#0x10
000aea  bd70              POP      {r4-r6,pc}
                  |L1.2796|
000aec  4867              LDR      r0,|L1.3212|
000aee  6940              LDR      r0,[r0,#0x14]         ;1224  ; _ClipContext
000af0  1c40              ADDS     r0,r0,#1              ;1224
000af2  4966              LDR      r1,|L1.3212|
000af4  6148              STR      r0,[r1,#0x14]         ;1224  ; _ClipContext
000af6  2801              CMP      r0,#1                 ;1224
000af8  dd01              BLE      |L1.2814|
000afa  2001              MOVS     r0,#1                 ;1225
000afc  e7f4              B        |L1.2792|
                  |L1.2814|
000afe  4962              LDR      r1,|L1.3208|
000b00  f9b1003c          LDRSH    r0,[r1,#0x3c]         ;1226  ; GUI_Context
000b04  f7fffffe          BL       GUI_ALLOC_h2p
000b08  4604              MOV      r4,r0                 ;1226
000b0a  f04f30ff          MOV      r0,#0xffffffff        ;1227
000b0e  495f              LDR      r1,|L1.3212|
000b10  6108              STR      r0,[r1,#0x10]         ;1227  ; _ClipContext
000b12  4863              LDR      r0,|L1.3232|
000b14  7800              LDRB     r0,[r0,#0]            ;1230  ; WM__PaintCallbackCnt
000b16  b120              CBZ      r0,|L1.2850|
000b18  a902              ADD      r1,sp,#8              ;1231
000b1a  4620              MOV      r0,r4                 ;1231
000b1c  f7fffffe          BL       WM__GetInvalidRectAbs
000b20  e00f              B        |L1.2882|
                  |L1.2850|
000b22  8ba0              LDRH     r0,[r4,#0x1c]         ;1233
000b24  f0100f02          TST      r0,#2                 ;1233
000b28  d004              BEQ      |L1.2868|
000b2a  e9d40100          LDRD     r0,r1,[r4,#0]         ;1234
000b2e  e9cd0102          STRD     r0,r1,[sp,#8]         ;1234
000b32  e006              B        |L1.2882|
                  |L1.2868|
000b34  4855              LDR      r0,|L1.3212|
000b36  6940              LDR      r0,[r0,#0x14]         ;1236  ; _ClipContext
000b38  1e40              SUBS     r0,r0,#1              ;1236
000b3a  4954              LDR      r1,|L1.3212|
000b3c  6148              STR      r0,[r1,#0x14]         ;1236  ; _ClipContext
000b3e  2000              MOVS     r0,#0                 ;1237
000b40  e7d2              B        |L1.2792|
                  |L1.2882|
000b42  b11d              CBZ      r5,|L1.2892|
000b44  4629              MOV      r1,r5                 ;1242
000b46  a802              ADD      r0,sp,#8              ;1242
000b48  f7fffffe          BL       GUI__IntersectRect
                  |L1.2892|
000b4c  484e              LDR      r0,|L1.3208|
000b4e  6b80              LDR      r0,[r0,#0x38]         ;1245  ; GUI_Context
000b50  b1c0              CBZ      r0,|L1.2948|
000b52  4626              MOV      r6,r4                 ;1246
000b54  484c              LDR      r0,|L1.3208|
000b56  6b80              LDR      r0,[r0,#0x38]         ;1247  ; GUI_Context
000b58  6801              LDR      r1,[r0,#0]            ;1247
000b5a  9100              STR      r1,[sp,#0]            ;1247
000b5c  6840              LDR      r0,[r0,#4]            ;1247
000b5e  9001              STR      r0,[sp,#4]            ;1247
000b60  4850              LDR      r0,|L1.3236|
000b62  8800              LDRH     r0,[r0,#0]            ;1249  ; WM__hATransWindow
000b64  b128              CBZ      r0,|L1.2930|
000b66  484f              LDR      r0,|L1.3236|
000b68  f9b00000          LDRSH    r0,[r0,#0]            ;1250  ; WM__hATransWindow
000b6c  f7fffffe          BL       GUI_ALLOC_h2p
000b70  4606              MOV      r6,r0                 ;1250
                  |L1.2930|
000b72  4669              MOV      r1,sp                 ;1253
000b74  4630              MOV      r0,r6                 ;1253
000b76  f7fffffe          BL       WM__Client2Screen
000b7a  4669              MOV      r1,sp                 ;1254
000b7c  a802              ADD      r0,sp,#8              ;1254
000b7e  f7fffffe          BL       GUI__IntersectRect
000b82  bf00              NOP                            ;1255
                  |L1.2948|
000b84  4847              LDR      r0,|L1.3236|
000b86  8800              LDRH     r0,[r0,#0]            ;1258  ; WM__hATransWindow
000b88  b168              CBZ      r0,|L1.2982|
000b8a  4846              LDR      r0,|L1.3236|
000b8c  f9b01000          LDRSH    r1,[r0,#0]            ;1259  ; WM__hATransWindow
000b90  a802              ADD      r0,sp,#8              ;1259
000b92  f7fffffe          BL       WM__ClipAtParentBorders
000b96  b930              CBNZ     r0,|L1.2982|
000b98  483c              LDR      r0,|L1.3212|
000b9a  6940              LDR      r0,[r0,#0x14]         ;1260  ; _ClipContext
000b9c  1e40              SUBS     r0,r0,#1              ;1260
000b9e  493b              LDR      r1,|L1.3212|
000ba0  6148              STR      r0,[r1,#0x14]         ;1260  ; _ClipContext
000ba2  2000              MOVS     r0,#0                 ;1261
000ba4  e7a0              B        |L1.2792|
                  |L1.2982|
000ba6  4838              LDR      r0,|L1.3208|
000ba8  f9b0103c          LDRSH    r1,[r0,#0x3c]         ;1266  ; GUI_Context
000bac  a802              ADD      r0,sp,#8              ;1266
000bae  f7fffffe          BL       WM__ClipAtParentBorders
000bb2  b930              CBNZ     r0,|L1.3010|
000bb4  4835              LDR      r0,|L1.3212|
000bb6  6940              LDR      r0,[r0,#0x14]         ;1267  ; _ClipContext
000bb8  1e40              SUBS     r0,r0,#1              ;1267
000bba  4934              LDR      r1,|L1.3212|
000bbc  6148              STR      r0,[r1,#0x14]         ;1267  ; _ClipContext
000bbe  2000              MOVS     r0,#0                 ;1268
000bc0  e792              B        |L1.2792|
                  |L1.3010|
000bc2  4832              LDR      r0,|L1.3212|
000bc4  e9dd1202          LDRD     r1,r2,[sp,#8]         ;1271
000bc8  c006              STM      r0!,{r1,r2}           ;1271
000bca  f7fffffe          BL       WM__GetNextIVR
000bce  e78b              B        |L1.2792|
;;;1274   
                          ENDP

                  WM_SetDefault PROC
;;;1283   */
;;;1284   void WM_SetDefault(void) {
000bd0  b510              PUSH     {r4,lr}
;;;1285     GL_SetDefault();
000bd2  f7fffffe          BL       GL_SetDefault
;;;1286     GUI_Context.WM__pUserClipRect = NULL;   /* No add. clipping */
000bd6  2000              MOVS     r0,#0
000bd8  492b              LDR      r1,|L1.3208|
000bda  6388              STR      r0,[r1,#0x38]  ; GUI_Context
;;;1287   }
000bdc  bd10              POP      {r4,pc}
;;;1288   
                          ENDP

                  _Paint1 PROC
;;;1292   */
;;;1293   static void _Paint1(WM_HWIN hWin, WM_Obj* pWin) {
000bde  b5fe              PUSH     {r1-r7,lr}
000be0  4605              MOV      r5,r0
000be2  460c              MOV      r4,r1
;;;1294     int Status = pWin->Status;
000be4  8ba6              LDRH     r6,[r4,#0x1c]
;;;1295     /* Send WM_PAINT if window is visible and a callback is defined */
;;;1296     if ((pWin->cb != NULL)  && (Status & WM_SF_ISVIS)) {
000be6  6920              LDR      r0,[r4,#0x10]
000be8  b3a8              CBZ      r0,|L1.3158|
000bea  f0160f02          TST      r6,#2
000bee  d032              BEQ      |L1.3158|
;;;1297       WM_MESSAGE Msg;
;;;1298       WM__PaintCallbackCnt++;
000bf0  482b              LDR      r0,|L1.3232|
000bf2  7800              LDRB     r0,[r0,#0]  ; WM__PaintCallbackCnt
000bf4  1c40              ADDS     r0,r0,#1
000bf6  492a              LDR      r1,|L1.3232|
000bf8  7008              STRB     r0,[r1,#0]
;;;1299       if (Status & WM_SF_LATE_CLIP) {
000bfa  f4165f80          TST      r6,#0x1000
000bfe  d00d              BEQ      |L1.3100|
;;;1300         Msg.hWin   = hWin;
000c00  f8ad5004          STRH     r5,[sp,#4]
;;;1301         Msg.MsgId  = WM_PAINT;
000c04  200f              MOVS     r0,#0xf
000c06  9000              STR      r0,[sp,#0]
;;;1302         Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
000c08  f1040008          ADD      r0,r4,#8
000c0c  9002              STR      r0,[sp,#8]
;;;1303         WM_SetDefault();
000c0e  f7fffffe          BL       WM_SetDefault
;;;1304         WM_SendMessage(hWin, &Msg);
000c12  4669              MOV      r1,sp
000c14  4628              MOV      r0,r5
000c16  f7fffffe          BL       WM_SendMessage
000c1a  e016              B        |L1.3146|
                  |L1.3100|
;;;1305       } else {
;;;1306         WM_ITERATE_START(&pWin->InvalidRect) {
000c1c  f1040008          ADD      r0,r4,#8
000c20  f7fffffe          BL       WM__InitIVRSearch
000c24  b188              CBZ      r0,|L1.3146|
000c26  bf00              NOP      
                  |L1.3112|
;;;1307           Msg.hWin   = hWin;
000c28  f8ad5004          STRH     r5,[sp,#4]
;;;1308           Msg.MsgId  = WM_PAINT;
000c2c  200f              MOVS     r0,#0xf
000c2e  9000              STR      r0,[sp,#0]
;;;1309           Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
000c30  f1040008          ADD      r0,r4,#8
000c34  9002              STR      r0,[sp,#8]
;;;1310           WM_SetDefault();
000c36  f7fffffe          BL       WM_SetDefault
;;;1311           WM_SendMessage(hWin, &Msg);
000c3a  4669              MOV      r1,sp
000c3c  4628              MOV      r0,r5
000c3e  f7fffffe          BL       WM_SendMessage
;;;1312         } WM_ITERATE_END();
000c42  f7fffffe          BL       WM__GetNextIVR
000c46  2800              CMP      r0,#0
000c48  d1ee              BNE      |L1.3112|
                  |L1.3146|
;;;1313       }
;;;1314       WM__PaintCallbackCnt--;
000c4a  4815              LDR      r0,|L1.3232|
000c4c  7800              LDRB     r0,[r0,#0]  ; WM__PaintCallbackCnt
000c4e  1e40              SUBS     r0,r0,#1
000c50  4913              LDR      r1,|L1.3232|
000c52  7008              STRB     r0,[r1,#0]
;;;1315     }
000c54  bf00              NOP      
                  |L1.3158|
;;;1316   }
000c56  bdfe              POP      {r1-r7,pc}
;;;1317   /*********************************************************************
                          ENDP

                  _Paint1Trans PROC
;;;1339   #if WM_SUPPORT_TRANSPARENCY
;;;1340   static int _Paint1Trans(WM_HWIN hWin, WM_Obj* pWin) {
000c58  e92d41f0          PUSH     {r4-r8,lr}
000c5c  4605              MOV      r5,r0
000c5e  460c              MOV      r4,r1
;;;1341     int xPrev, yPrev;
;;;1342     WM_Obj* pAWin = WM_H2P(GUI_Context.hAWin);
000c60  4909              LDR      r1,|L1.3208|
000c62  f9b1003c          LDRSH    r0,[r1,#0x3c]  ; GUI_Context
000c66  f7fffffe          BL       GUI_ALLOC_h2p
000c6a  4680              MOV      r8,r0
;;;1343     /* Check if we need to do any drawing */
;;;1344     if (GUI_RectsIntersect(&pAWin->InvalidRect, &pWin->Rect)) {
000c6c  4621              MOV      r1,r4
000c6e  f1080008          ADD      r0,r8,#8
000c72  f7fffffe          BL       GUI_RectsIntersect
000c76  b390              CBZ      r0,|L1.3294|
;;;1345       /* Save old values */
;;;1346       xPrev = GUI_Context.xOff;
000c78  4803              LDR      r0,|L1.3208|
000c7a  6c06              LDR      r6,[r0,#0x40]  ; GUI_Context
;;;1347       yPrev = GUI_Context.yOff;
000c7c  6c47              LDR      r7,[r0,#0x44]  ; GUI_Context
;;;1348       /* Set values for the current (transparent) window, rather than the one below */
;;;1349       GUI__IntersectRects(&pWin->InvalidRect, &pWin->Rect, &pAWin->InvalidRect);
000c7e  f1080208          ADD      r2,r8,#8
000c82  e011              B        |L1.3240|
                  |L1.3204|
                          DCD      WM__TransWindowCnt
                  |L1.3208|
                          DCD      GUI_Context
                  |L1.3212|
                          DCD      _ClipContext
                  |L1.3216|
                          DCD      WM_IsActive
                  |L1.3220|
                          DCD      _CursorHidden
                  |L1.3224|
                          DCD      GUI_CURSOR_pfTempUnhide
                  |L1.3228|
                          DCD      GUI_CURSOR_pfTempHide
                  |L1.3232|
                          DCD      WM__PaintCallbackCnt
                  |L1.3236|
                          DCD      WM__hATransWindow
                  |L1.3240|
000ca8  4621              MOV      r1,r4
000caa  f1040008          ADD      r0,r4,#8
000cae  f7fffffe          BL       GUI__IntersectRects
;;;1350       WM__hATransWindow = hWin;
000cb2  48d8              LDR      r0,|L1.4116|
000cb4  8005              STRH     r5,[r0,#0]
;;;1351       GUI_Context.xOff = pWin->Rect.x0;
000cb6  f9b40000          LDRSH    r0,[r4,#0]
000cba  49d7              LDR      r1,|L1.4120|
000cbc  6408              STR      r0,[r1,#0x40]  ; GUI_Context
;;;1352       GUI_Context.yOff = pWin->Rect.y0;
000cbe  f9b40002          LDRSH    r0,[r4,#2]
000cc2  6448              STR      r0,[r1,#0x44]  ; GUI_Context
;;;1353       /* Do the actual drawing ... */
;;;1354       _Paint1(hWin, pWin);
000cc4  4621              MOV      r1,r4
000cc6  4628              MOV      r0,r5
000cc8  f7fffffe          BL       _Paint1
;;;1355       /* Restore settings */
;;;1356       WM__hATransWindow = 0;
000ccc  2000              MOVS     r0,#0
000cce  49d1              LDR      r1,|L1.4116|
000cd0  8008              STRH     r0,[r1,#0]
;;;1357       GUI_Context.xOff = xPrev;
000cd2  48d1              LDR      r0,|L1.4120|
000cd4  6406              STR      r6,[r0,#0x40]  ; GUI_Context
;;;1358       GUI_Context.yOff = yPrev;
000cd6  6447              STR      r7,[r0,#0x44]  ; GUI_Context
;;;1359       return 1;                       /* Some drawing took place */
000cd8  2001              MOVS     r0,#1
                  |L1.3290|
;;;1360     }
;;;1361     return 0;                         /* No invalid area, so nothing was drawn */
;;;1362   }
000cda  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3294|
000cde  e7ff              B        |L1.3296|
                  |L1.3296|
000ce0  2000              MOVS     r0,#0                 ;1361
000ce2  e7fa              B        |L1.3290|
;;;1363   #endif
                          ENDP

                  _PaintTransChildren PROC
;;;1376   #if WM_SUPPORT_TRANSPARENCY
;;;1377   static void _PaintTransChildren(WM_Obj* pWin) {
000ce4  b57c              PUSH     {r2-r6,lr}
000ce6  4604              MOV      r4,r0
;;;1378     WM_HWIN hChild;
;;;1379     WM_Obj* pChild;
;;;1380     if (pWin->Status & WM_SF_ISVIS) {
000ce8  8ba0              LDRH     r0,[r4,#0x1c]
000cea  f0100f02          TST      r0,#2
000cee  d026              BEQ      |L1.3390|
;;;1381       for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
000cf0  f9b46018          LDRSH    r6,[r4,#0x18]
000cf4  e021              B        |L1.3386|
                  |L1.3318|
;;;1382         pChild = WM_H2P(hChild);
000cf6  4630              MOV      r0,r6
000cf8  f7fffffe          BL       GUI_ALLOC_h2p
000cfc  4605              MOV      r5,r0
;;;1383         if ((pChild->Status & (WM_SF_HASTRANS | WM_SF_ISVIS))   /* Transparent & visible ? */
000cfe  8ba8              LDRH     r0,[r5,#0x1c]
000d00  f0000003          AND      r0,r0,#3
000d04  2803              CMP      r0,#3
000d06  d116              BNE      |L1.3382|
;;;1384   		                ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
;;;1385           /* Set invalid area of the window to draw */
;;;1386           if (GUI_RectsIntersect(&pChild->Rect, &pWin->InvalidRect)) {
000d08  f1040108          ADD      r1,r4,#8
000d0c  4628              MOV      r0,r5
000d0e  f7fffffe          BL       GUI_RectsIntersect
000d12  b180              CBZ      r0,|L1.3382|
;;;1387             GUI_RECT InvalidRectPrev;
;;;1388             InvalidRectPrev = pWin->InvalidRect;
000d14  68a0              LDR      r0,[r4,#8]
000d16  9000              STR      r0,[sp,#0]
000d18  68e0              LDR      r0,[r4,#0xc]
000d1a  9001              STR      r0,[sp,#4]
;;;1389             if(_Paint1Trans(hChild, pChild)) {
000d1c  4629              MOV      r1,r5
000d1e  4630              MOV      r0,r6
000d20  f7fffffe          BL       _Paint1Trans
000d24  b110              CBZ      r0,|L1.3372|
;;;1390               _PaintTransChildren(pChild);
000d26  4628              MOV      r0,r5
000d28  f7fffffe          BL       _PaintTransChildren
                  |L1.3372|
;;;1391             }
;;;1392             pWin->InvalidRect = InvalidRectPrev;
000d2c  9800              LDR      r0,[sp,#0]
000d2e  60a0              STR      r0,[r4,#8]
000d30  9801              LDR      r0,[sp,#4]
000d32  60e0              STR      r0,[r4,#0xc]
;;;1393           }
000d34  bf00              NOP      
                  |L1.3382|
000d36  f9b5601a          LDRSH    r6,[r5,#0x1a]         ;1381
                  |L1.3386|
000d3a  2e00              CMP      r6,#0                 ;1381
000d3c  d1db              BNE      |L1.3318|
                  |L1.3390|
;;;1394         }
;;;1395       }
;;;1396     }
;;;1397   }
000d3e  bd7c              POP      {r2-r6,pc}
;;;1398   #endif
                          ENDP

                  _PaintTransTopSiblings PROC
;;;1411   #if WM_SUPPORT_TRANSPARENCY
;;;1412   static void _PaintTransTopSiblings(WM_HWIN hWin, WM_Obj* pWin) {
000d40  e92d41f0          PUSH     {r4-r8,lr}
000d44  4606              MOV      r6,r0
000d46  460c              MOV      r4,r1
;;;1413     WM_HWIN hParent;
;;;1414     WM_Obj* pParent;
;;;1415     hParent = pWin->hParent;
000d48  f9b47016          LDRSH    r7,[r4,#0x16]
;;;1416     hWin = pWin->hNext;
000d4c  f9b4601a          LDRSH    r6,[r4,#0x1a]
;;;1417     while (hParent) { /* Go hierarchy up to desktop window */
000d50  e01c              B        |L1.3468|
                  |L1.3410|
;;;1418       for (; hWin; hWin = pWin->hNext) {
000d52  e011              B        |L1.3448|
                  |L1.3412|
;;;1419         pWin = WM_H2P(hWin);
000d54  4630              MOV      r0,r6
000d56  f7fffffe          BL       GUI_ALLOC_h2p
000d5a  4604              MOV      r4,r0
;;;1420         /* paint window if it is transparent & visible */
;;;1421         if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_ISVIS)) ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
000d5c  8ba0              LDRH     r0,[r4,#0x1c]
000d5e  f0000003          AND      r0,r0,#3
000d62  2803              CMP      r0,#3
000d64  d103              BNE      |L1.3438|
;;;1422           _Paint1Trans(hWin, pWin);
000d66  4621              MOV      r1,r4
000d68  4630              MOV      r0,r6
000d6a  f7fffffe          BL       _Paint1Trans
                  |L1.3438|
;;;1423         }
;;;1424         /* paint transparent & visible children */
;;;1425         _PaintTransChildren(pWin);
000d6e  4620              MOV      r0,r4
000d70  f7fffffe          BL       _PaintTransChildren
000d74  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;1418
                  |L1.3448|
000d78  2e00              CMP      r6,#0                 ;1418
000d7a  d1eb              BNE      |L1.3412|
;;;1426       }
;;;1427       pParent = WM_H2P(hParent);
000d7c  4638              MOV      r0,r7
000d7e  f7fffffe          BL       GUI_ALLOC_h2p
000d82  4605              MOV      r5,r0
;;;1428       hWin = pParent->hNext;
000d84  f9b5601a          LDRSH    r6,[r5,#0x1a]
;;;1429       hParent = pParent->hParent;
000d88  f9b57016          LDRSH    r7,[r5,#0x16]
                  |L1.3468|
000d8c  2f00              CMP      r7,#0                 ;1417
000d8e  d1e0              BNE      |L1.3410|
;;;1430     }
;;;1431   }
000d90  e8bd81f0          POP      {r4-r8,pc}
;;;1432   #endif
                          ENDP

                  WM__PaintWinAndOverlays PROC
;;;1453   */
;;;1454   void WM__PaintWinAndOverlays(WM_PAINTINFO* pInfo) {
000d94  b570              PUSH     {r4-r6,lr}
000d96  4604              MOV      r4,r0
;;;1455     WM_HWIN hWin;
;;;1456     WM_Obj* pWin;
;;;1457     hWin = pInfo->hWin;
000d98  f9b46000          LDRSH    r6,[r4,#0]
;;;1458     pWin = pInfo->pWin;
000d9c  6865              LDR      r5,[r4,#4]
;;;1459     #if WM_SUPPORT_TRANSPARENCY
;;;1460       /* Transparent windows without const outline are drawn as part of the background and can be skipped. */
;;;1461       if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) != WM_SF_HASTRANS) {
000d9e  8ba8              LDRH     r0,[r5,#0x1c]
000da0  f6400101          MOV      r1,#0x801
000da4  4008              ANDS     r0,r0,r1
000da6  2801              CMP      r0,#1
000da8  d003              BEQ      |L1.3506|
;;;1462     #endif
;;;1463     _Paint1(hWin, pWin);    /* Draw the window itself */
000daa  4629              MOV      r1,r5
000dac  4630              MOV      r0,r6
000dae  f7fffffe          BL       _Paint1
                  |L1.3506|
;;;1464     #if WM_SUPPORT_TRANSPARENCY
;;;1465       }
;;;1466       if (WM__TransWindowCnt != 0) {
000db2  489a              LDR      r0,|L1.4124|
000db4  6800              LDR      r0,[r0,#0]  ; WM__TransWindowCnt
000db6  b130              CBZ      r0,|L1.3526|
;;;1467         _PaintTransChildren(pWin);       /* Draw all transparent children */
000db8  4628              MOV      r0,r5
000dba  f7fffffe          BL       _PaintTransChildren
;;;1468         _PaintTransTopSiblings(hWin, pWin);    /* Draw all transparent top level siblings */
000dbe  4629              MOV      r1,r5
000dc0  4630              MOV      r0,r6
000dc2  f7fffffe          BL       _PaintTransTopSiblings
                  |L1.3526|
;;;1469       }
;;;1470     #endif
;;;1471   }
000dc6  bd70              POP      {r4-r6,pc}
;;;1472   
                          ENDP

                  _Paint PROC
;;;1502   */
;;;1503   static int _Paint(WM_HWIN hWin, WM_Obj* pWin) {
000dc8  b57c              PUSH     {r2-r6,lr}
000dca  4605              MOV      r5,r0
000dcc  460c              MOV      r4,r1
;;;1504     int Ret = 0;
000dce  2600              MOVS     r6,#0
;;;1505     if (pWin->Status & WM_SF_INVALID) {
000dd0  8ba0              LDRH     r0,[r4,#0x1c]
000dd2  f0100f20          TST      r0,#0x20
000dd6  d023              BEQ      |L1.3616|
;;;1506       if (pWin->cb) {
000dd8  6920              LDR      r0,[r4,#0x10]
000dda  b180              CBZ      r0,|L1.3582|
;;;1507         if (WM__ClipAtParentBorders(&pWin->InvalidRect, hWin)) {
000ddc  4629              MOV      r1,r5
000dde  f1040008          ADD      r0,r4,#8
000de2  f7fffffe          BL       WM__ClipAtParentBorders
000de6  b150              CBZ      r0,|L1.3582|
;;;1508           WM_PAINTINFO Info;
;;;1509           Info.hWin = hWin;
000de8  f8ad5000          STRH     r5,[sp,#0]
;;;1510           Info.pWin = pWin;
000dec  9401              STR      r4,[sp,#4]
;;;1511           WM_SelectWindow(hWin);
000dee  4628              MOV      r0,r5
000df0  f7fffffe          BL       WM_SelectWindow
;;;1512           #if GUI_SUPPORT_MEMDEV
;;;1513             if (pWin->Status & WM_SF_MEMDEV) {
;;;1514               int Flags;
;;;1515               GUI_RECT r = pWin->InvalidRect;
;;;1516               Flags = (pWin->Status & WM_SF_HASTRANS) ? GUI_MEMDEV_HASTRANS : GUI_MEMDEV_NOTRANS;
;;;1517               /*
;;;1518                * Currently we treat a desktop window as transparent, because per default it does not repaint itself.
;;;1519                */
;;;1520               if (pWin->hParent == 0) {
;;;1521                 Flags = GUI_MEMDEV_HASTRANS;
;;;1522               }
;;;1523               GUI_MEMDEV_Draw(&r, _cbPaintMemDev, &Info, 0, Flags);
;;;1524             } else
;;;1525           #endif
;;;1526           {
;;;1527             WM__PaintWinAndOverlays(&Info);
000df4  4668              MOV      r0,sp
000df6  f7fffffe          BL       WM__PaintWinAndOverlays
;;;1528             Ret = 1;    /* Something has been done */
000dfa  2601              MOVS     r6,#1
;;;1529           }
;;;1530         }
000dfc  bf00              NOP      
                  |L1.3582|
;;;1531       }
;;;1532       /* We purposly clear the invalid flag after painting so we can still query the invalid rectangle while painting */
;;;1533       pWin->Status &=  ~WM_SF_INVALID; /* Clear invalid flag */
000dfe  8ba0              LDRH     r0,[r4,#0x1c]
000e00  f0200020          BIC      r0,r0,#0x20
000e04  83a0              STRH     r0,[r4,#0x1c]
;;;1534       if (pWin->Status & WM_CF_MEMDEV_ON_REDRAW) {
000e06  8ba0              LDRH     r0,[r4,#0x1c]
000e08  f4105f00          TST      r0,#0x2000
000e0c  d003              BEQ      |L1.3606|
;;;1535         pWin->Status |= WM_CF_MEMDEV;
000e0e  8ba0              LDRH     r0,[r4,#0x1c]
000e10  f0400004          ORR      r0,r0,#4
000e14  83a0              STRH     r0,[r4,#0x1c]
                  |L1.3606|
;;;1536       }
;;;1537       WM__NumInvalidWindows--;
000e16  4882              LDR      r0,|L1.4128|
000e18  8800              LDRH     r0,[r0,#0]  ; WM__NumInvalidWindows
000e1a  1e40              SUBS     r0,r0,#1
000e1c  4980              LDR      r1,|L1.4128|
000e1e  8008              STRH     r0,[r1,#0]
                  |L1.3616|
;;;1538     }
;;;1539     return Ret;      /* Nothing done */
000e20  4630              MOV      r0,r6
;;;1540   }
000e22  bd7c              POP      {r2-r6,pc}
;;;1541   
                          ENDP

                  _DrawNext PROC
;;;1545   */
;;;1546   static void _DrawNext(void) {
000e24  b570              PUSH     {r4-r6,lr}
000e26  b092              SUB      sp,sp,#0x48
;;;1547     int UpdateRem = 1;
000e28  2601              MOVS     r6,#1
;;;1548     WM_HWIN iWin = (NextDrawWin == WM_HWIN_NULL) ? WM__FirstWin : NextDrawWin;
000e2a  487e              LDR      r0,|L1.4132|
000e2c  8800              LDRH     r0,[r0,#0]  ; NextDrawWin
000e2e  b918              CBNZ     r0,|L1.3640|
000e30  487d              LDR      r0,|L1.4136|
000e32  f9b00000          LDRSH    r0,[r0,#0]  ; WM__FirstWin
000e36  e002              B        |L1.3646|
                  |L1.3640|
000e38  487a              LDR      r0,|L1.4132|
000e3a  f9b00000          LDRSH    r0,[r0,#0]  ; NextDrawWin
                  |L1.3646|
000e3e  b204              SXTH     r4,r0
;;;1549     GUI_CONTEXT ContextOld;
;;;1550     GUI_SaveContext(&ContextOld);
000e40  4668              MOV      r0,sp
000e42  f7fffffe          BL       GUI_SaveContext_W
;;;1551     /* Make sure the next window to redraw is valid */
;;;1552     for (; iWin && UpdateRem; ) {
000e46  e00c              B        |L1.3682|
                  |L1.3656|
;;;1553       WM_Obj* pWin = WM_H2P(iWin);
000e48  4620              MOV      r0,r4
000e4a  f7fffffe          BL       GUI_ALLOC_h2p
000e4e  4605              MOV      r5,r0
;;;1554       if (_Paint(iWin, pWin)) {
000e50  4629              MOV      r1,r5
000e52  4620              MOV      r0,r4
000e54  f7fffffe          BL       _Paint
000e58  b100              CBZ      r0,|L1.3676|
;;;1555         UpdateRem--;  /* Only the given number of windows at a time ... */
000e5a  1e76              SUBS     r6,r6,#1
                  |L1.3676|
;;;1556       }
;;;1557       iWin = pWin->hNextLin;
000e5c  f9b54014          LDRSH    r4,[r5,#0x14]
;;;1558     }  
000e60  bf00              NOP      
                  |L1.3682|
000e62  b10c              CBZ      r4,|L1.3688|
000e64  2e00              CMP      r6,#0                 ;1552
000e66  d1ef              BNE      |L1.3656|
                  |L1.3688|
;;;1559     NextDrawWin = iWin;   /* Remember the window */
000e68  486e              LDR      r0,|L1.4132|
000e6a  8004              STRH     r4,[r0,#0]
;;;1560     GUI_RestoreContext(&ContextOld);
000e6c  4668              MOV      r0,sp
000e6e  f7fffffe          BL       GUI_RestoreContext
;;;1561   }
000e72  b012              ADD      sp,sp,#0x48
000e74  bd70              POP      {r4-r6,pc}
;;;1562   
                          ENDP

                  WM_Exec1 PROC
;;;1566   */
;;;1567   int WM_Exec1(void) {
000e76  b510              PUSH     {r4,lr}
;;;1568     /* Poll PID if necessary */
;;;1569     if (WM_pfPollPID) {
000e78  486c              LDR      r0,|L1.4140|
000e7a  6800              LDR      r0,[r0,#0]  ; WM_pfPollPID
000e7c  b110              CBZ      r0,|L1.3716|
;;;1570       WM_pfPollPID();
000e7e  486b              LDR      r0,|L1.4140|
000e80  6800              LDR      r0,[r0,#0]  ; WM_pfPollPID
000e82  4780              BLX      r0
                  |L1.3716|
;;;1571     }
;;;1572     if (WM_pfHandlePID) {
000e84  486a              LDR      r0,|L1.4144|
000e86  6800              LDR      r0,[r0,#0]  ; WM_pfHandlePID
000e88  b128              CBZ      r0,|L1.3734|
;;;1573       if (WM_pfHandlePID())
000e8a  4869              LDR      r0,|L1.4144|
000e8c  6800              LDR      r0,[r0,#0]  ; WM_pfHandlePID
000e8e  4780              BLX      r0
000e90  b108              CBZ      r0,|L1.3734|
;;;1574         return 1;               /* We have done something ... */
000e92  2001              MOVS     r0,#1
                  |L1.3732|
;;;1575     }
;;;1576     if (GUI_PollKeyMsg()) {
;;;1577       return 1;               /* We have done something ... */
;;;1578     }
;;;1579     if (WM_IsActive && WM__NumInvalidWindows) {
;;;1580       WM_LOCK();
;;;1581       _DrawNext();
;;;1582       WM_UNLOCK();
;;;1583       return 1;               /* We have done something ... */
;;;1584     }
;;;1585     return 0;                  /* There was nothing to do ... */
;;;1586   }
000e94  bd10              POP      {r4,pc}
                  |L1.3734|
000e96  f7fffffe          BL       GUI_PollKeyMsg
000e9a  b108              CBZ      r0,|L1.3744|
000e9c  2001              MOVS     r0,#1                 ;1577
000e9e  e7f9              B        |L1.3732|
                  |L1.3744|
000ea0  4864              LDR      r0,|L1.4148|
000ea2  7800              LDRB     r0,[r0,#0]            ;1579  ; WM_IsActive
000ea4  b150              CBZ      r0,|L1.3772|
000ea6  485e              LDR      r0,|L1.4128|
000ea8  8800              LDRH     r0,[r0,#0]            ;1579  ; WM__NumInvalidWindows
000eaa  b138              CBZ      r0,|L1.3772|
000eac  f7fffffe          BL       GUI_Lock
000eb0  f7fffffe          BL       _DrawNext
000eb4  f7fffffe          BL       GUI_Unlock
000eb8  2001              MOVS     r0,#1                 ;1583
000eba  e7eb              B        |L1.3732|
                  |L1.3772|
000ebc  2000              MOVS     r0,#0                 ;1585
000ebe  e7e9              B        |L1.3732|
;;;1587   
                          ENDP

                  WM_Exec PROC
;;;1591   */
;;;1592   int WM_Exec(void) {
000ec0  b510              PUSH     {r4,lr}
;;;1593     int r = 0;
000ec2  2400              MOVS     r4,#0
;;;1594     while (WM_Exec1()) {
000ec4  e000              B        |L1.3784|
                  |L1.3782|
;;;1595       r = 1;                  /* We have done something */
000ec6  2401              MOVS     r4,#1
                  |L1.3784|
000ec8  f7fffffe          BL       WM_Exec1
000ecc  2800              CMP      r0,#0                 ;1594
000ece  d1fa              BNE      |L1.3782|
;;;1596     }
;;;1597     return r;
000ed0  4620              MOV      r0,r4
;;;1598   }
000ed2  bd10              POP      {r4,pc}
;;;1599   
                          ENDP

                  WM_DefaultProc PROC
;;;1663   */
;;;1664   void WM_DefaultProc(WM_MESSAGE* pMsg) {
000ed4  e92d41f0          PUSH     {r4-r8,lr}
000ed8  4604              MOV      r4,r0
;;;1665     WM_HWIN hWin = pMsg->hWin;
000eda  f9b45004          LDRSH    r5,[r4,#4]
;;;1666     const void *p = pMsg->Data.p;
000ede  68a6              LDR      r6,[r4,#8]
;;;1667     WM_Obj* pWin = WM_H2P(hWin);
000ee0  4628              MOV      r0,r5
000ee2  f7fffffe          BL       GUI_ALLOC_h2p
000ee6  4607              MOV      r7,r0
;;;1668     /* Exec message */
;;;1669     switch (pMsg->MsgId) {
000ee8  6820              LDR      r0,[r4,#0]
000eea  2817              CMP      r0,#0x17
000eec  d00f              BEQ      |L1.3854|
000eee  dc04              BGT      |L1.3834|
000ef0  280e              CMP      r0,#0xe
000ef2  d00f              BEQ      |L1.3860|
000ef4  2814              CMP      r0,#0x14
000ef6  d11a              BNE      |L1.3886|
000ef8  e004              B        |L1.3844|
                  |L1.3834|
000efa  2822              CMP      r0,#0x22
000efc  d00f              BEQ      |L1.3870|
000efe  2828              CMP      r0,#0x28
000f00  d115              BNE      |L1.3886|
000f02  e010              B        |L1.3878|
                  |L1.3844|
;;;1670     case WM_GET_INSIDE_RECT:      /* return client window in absolute (screen) coordinates */
;;;1671       WM__GetClientRectWin(pWin, (GUI_RECT*)p);
000f04  4631              MOV      r1,r6
000f06  4638              MOV      r0,r7
000f08  f7fffffe          BL       WM__GetClientRectWin
;;;1672       break;
000f0c  e00f              B        |L1.3886|
                  |L1.3854|
;;;1673     case WM_GET_CLIENT_WINDOW:      /* return handle to client window. For most windows, there is no seperate client window, so it is the same handle */
;;;1674       pMsg->Data.v = (int)hWin;
000f0e  60a5              STR      r5,[r4,#8]
                  |L1.3856|
;;;1675       return;                       /* Message handled */
;;;1676     case WM_KEY:
;;;1677       WM_SendToParent(hWin, pMsg);
;;;1678       return;                       /* Message handled */
;;;1679      case WM_GET_BKCOLOR:
;;;1680       pMsg->Data.Color = GUI_INVALID_COLOR;
;;;1681       return;                       /* Message handled */
;;;1682     case WM_NOTIFY_ENABLE:
;;;1683       WM_InvalidateWindow(hWin);    
;;;1684       return;                       /* Message handled */
;;;1685     }
;;;1686     /* Message not handled. If it queries something, we return 0 to be on the safe side. */
;;;1687     pMsg->Data.v = 0;
;;;1688     pMsg->Data.p = 0;
;;;1689   }
000f10  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3860|
000f14  4621              MOV      r1,r4                 ;1677
000f16  4628              MOV      r0,r5                 ;1677
000f18  f7fffffe          BL       WM_SendToParent
000f1c  e7f8              B        |L1.3856|
                  |L1.3870|
000f1e  f06f4070          MVN      r0,#0xf0000000        ;1680
000f22  60a0              STR      r0,[r4,#8]            ;1680
000f24  e7f4              B        |L1.3856|
                  |L1.3878|
000f26  4628              MOV      r0,r5                 ;1683
000f28  f7fffffe          BL       WM_InvalidateWindow
000f2c  e7f0              B        |L1.3856|
                  |L1.3886|
000f2e  bf00              NOP                            ;1672
000f30  2000              MOVS     r0,#0                 ;1687
000f32  60a0              STR      r0,[r4,#8]            ;1687
000f34  60a0              STR      r0,[r4,#8]            ;1688
000f36  bf00              NOP      
000f38  e7ea              B        |L1.3856|
;;;1690   
                          ENDP

                  cbBackWin PROC
;;;1607   */
;;;1608   static void cbBackWin( WM_MESSAGE* pMsg) {
000f3a  b570              PUSH     {r4-r6,lr}
000f3c  4604              MOV      r4,r0
;;;1609     const WM_KEY_INFO* pKeyInfo;
;;;1610     switch (pMsg->MsgId) {
000f3e  6820              LDR      r0,[r4,#0]
000f40  280e              CMP      r0,#0xe
000f42  d002              BEQ      |L1.3914|
000f44  280f              CMP      r0,#0xf
000f46  d118              BNE      |L1.3962|
000f48  e007              B        |L1.3930|
                  |L1.3914|
;;;1611     case WM_KEY:
;;;1612       pKeyInfo = (const WM_KEY_INFO*)pMsg->Data.p;
000f4a  68a5              LDR      r5,[r4,#8]
;;;1613       if (pKeyInfo->PressedCnt == 1) {
000f4c  6868              LDR      r0,[r5,#4]
000f4e  2801              CMP      r0,#1
000f50  d102              BNE      |L1.3928|
;;;1614         GUI_StoreKey(pKeyInfo->Key);
000f52  6828              LDR      r0,[r5,#0]
000f54  f7fffffe          BL       GUI_StoreKey
                  |L1.3928|
;;;1615       }
;;;1616       break;
000f58  e013              B        |L1.3970|
                  |L1.3930|
;;;1617     case WM_PAINT:
;;;1618       {
;;;1619         int LayerIndex;
;;;1620         #if GUI_NUM_LAYERS > 1
;;;1621           LayerIndex = _DesktopHandle2Index(pMsg->hWin);
;;;1622         #else
;;;1623           LayerIndex = 0;
000f5a  2600              MOVS     r6,#0
;;;1624         #endif
;;;1625         if (WM__aBkColor[LayerIndex] != GUI_INVALID_COLOR) {
000f5c  4836              LDR      r0,|L1.4152|
000f5e  f8500026          LDR      r0,[r0,r6,LSL #2]
000f62  f06f4170          MVN      r1,#0xf0000000
000f66  4288              CMP      r0,r1
000f68  d006              BEQ      |L1.3960|
;;;1626           GUI_SetBkColor(WM__aBkColor[LayerIndex]);
000f6a  4933              LDR      r1,|L1.4152|
000f6c  f8510026          LDR      r0,[r1,r6,LSL #2]
000f70  f7fffffe          BL       GUI_SetBkColor
;;;1627           GUI_Clear();
000f74  f7fffffe          BL       GUI_Clear
                  |L1.3960|
;;;1628         }
;;;1629       }
;;;1630     default:
000f78  bf00              NOP      
                  |L1.3962|
;;;1631       WM_DefaultProc(pMsg);
000f7a  4620              MOV      r0,r4
000f7c  f7fffffe          BL       WM_DefaultProc
000f80  bf00              NOP                            ;1610
                  |L1.3970|
000f82  bf00              NOP                            ;1616
;;;1632     }
;;;1633   }
000f84  bd70              POP      {r4-r6,pc}
;;;1634   
                          ENDP

                  WM_Activate PROC
;;;1638   */
;;;1639   void WM_Activate(void) {
000f86  2001              MOVS     r0,#1
;;;1640     WM_IsActive = 1;       /* Running */
000f88  492a              LDR      r1,|L1.4148|
000f8a  7008              STRB     r0,[r1,#0]
;;;1641   }
000f8c  4770              BX       lr
;;;1642   
                          ENDP

                  WM_Deactivate PROC
;;;1646   */
;;;1647   void WM_Deactivate(void) {
000f8e  b510              PUSH     {r4,lr}
;;;1648     WM_IsActive = 0;       /* No clipping performed by WM */
000f90  2000              MOVS     r0,#0
000f92  4928              LDR      r1,|L1.4148|
000f94  7008              STRB     r0,[r1,#0]
;;;1649     WM_LOCK();
000f96  f7fffffe          BL       GUI_Lock
;;;1650     LCD_SetClipRectMax();
000f9a  f7fffffe          BL       LCD_SetClipRectMax
;;;1651     WM_UNLOCK();
000f9e  f7fffffe          BL       GUI_Unlock
;;;1652   }
000fa2  bd10              POP      {r4,pc}
;;;1653   
                          ENDP

                  WM_Init PROC
;;;1694   */
;;;1695   void WM_Init(void) {
000fa4  b50e              PUSH     {r1-r3,lr}
;;;1696   	if (!_IsInited) {
000fa6  4825              LDR      r0,|L1.4156|
000fa8  7800              LDRB     r0,[r0,#0]  ; _IsInited
000faa  bb88              CBNZ     r0,|L1.4112|
;;;1697   	  NextDrawWin = WM__FirstWin = WM_HWIN_NULL;
000fac  2000              MOVS     r0,#0
000fae  491e              LDR      r1,|L1.4136|
000fb0  8008              STRH     r0,[r1,#0]
000fb2  491c              LDR      r1,|L1.4132|
000fb4  8008              STRH     r0,[r1,#0]
;;;1698   	  GUI_Context.WM__pUserClipRect = NULL;
000fb6  4918              LDR      r1,|L1.4120|
000fb8  6388              STR      r0,[r1,#0x38]  ; GUI_Context
;;;1699   	  WM__NumWindows = WM__NumInvalidWindows =0;
000fba  4919              LDR      r1,|L1.4128|
000fbc  8008              STRH     r0,[r1,#0]
000fbe  4920              LDR      r1,|L1.4160|
000fc0  8008              STRH     r0,[r1,#0]
;;;1700   	  /* Make sure we have at least one window. This greatly simplifies the
;;;1701   		  drawing routines as they do not have to check if the window is valid.
;;;1702   	  */
;;;1703       #if GUI_NUM_LAYERS == 1
;;;1704         WM__ahDesktopWin[0] = WM_CreateWindow(0, 0, GUI_XMAX, GUI_YMAX, WM_CF_SHOW, cbBackWin, 0);
000fc2  2300              MOVS     r3,#0
000fc4  4a1f              LDR      r2,|L1.4164|
000fc6  2102              MOVS     r1,#2
000fc8  e88d000e          STM      sp,{r1-r3}
000fcc  f64073ff          MOV      r3,#0xfff
000fd0  461a              MOV      r2,r3
000fd2  2100              MOVS     r1,#0
000fd4  4608              MOV      r0,r1
000fd6  f7fffffe          BL       WM_CreateWindow
000fda  491b              LDR      r1,|L1.4168|
000fdc  8008              STRH     r0,[r1,#0]
;;;1705         WM__aBkColor[0] = GUI_INVALID_COLOR;
000fde  f06f4070          MVN      r0,#0xf0000000
000fe2  4915              LDR      r1,|L1.4152|
000fe4  6008              STR      r0,[r1,#0]  ; WM__aBkColor
;;;1706         WM_InvalidateWindow(WM__ahDesktopWin[0]); /* Required because a desktop window has no parent. */
000fe6  4918              LDR      r1,|L1.4168|
000fe8  f9b10000          LDRSH    r0,[r1,#0]  ; WM__ahDesktopWin
000fec  f7fffffe          BL       WM_InvalidateWindow
;;;1707       #else
;;;1708       {
;;;1709         int i;
;;;1710         for (i = 0; i < GUI_NUM_LAYERS; i++) {
;;;1711           WM__ahDesktopWin[i] = WM_CreateWindowAsChild(0, 0, GUI_XMAX, GUI_YMAX, WM_UNATTACHED, WM_CF_SHOW, cbBackWin, 0);
;;;1712           WM__aBkColor[i] = GUI_INVALID_COLOR;
;;;1713           WM_InvalidateWindow(WM__ahDesktopWin[i]); /* Required because a desktop window has no parent. */
;;;1714         }
;;;1715       }
;;;1716       #endif
;;;1717       /* Register the critical handles ... Note: This could be moved into the module setting the Window handle */
;;;1718       WM__AddCriticalHandle(&WM__CHWinModal);
000ff0  4816              LDR      r0,|L1.4172|
000ff2  f7fffffe          BL       WM__AddCriticalHandle
;;;1719       WM__AddCriticalHandle(&WM__CHWinLast);
000ff6  4816              LDR      r0,|L1.4176|
000ff8  f7fffffe          BL       WM__AddCriticalHandle
;;;1720   
;;;1721       WM_SelectWindow(WM__ahDesktopWin[0]);
000ffc  4912              LDR      r1,|L1.4168|
000ffe  f9b10000          LDRSH    r0,[r1,#0]  ; WM__ahDesktopWin
001002  f7fffffe          BL       WM_SelectWindow
;;;1722   	  WM_Activate();
001006  f7fffffe          BL       WM_Activate
;;;1723       _IsInited =1;
00100a  2001              MOVS     r0,#1
00100c  490b              LDR      r1,|L1.4156|
00100e  7008              STRB     r0,[r1,#0]
                  |L1.4112|
;;;1724   	}
;;;1725   }
001010  bd0e              POP      {r1-r3,pc}
;;;1726   
                          ENDP

001012  0000              DCW      0x0000
                  |L1.4116|
                          DCD      WM__hATransWindow
                  |L1.4120|
                          DCD      GUI_Context
                  |L1.4124|
                          DCD      WM__TransWindowCnt
                  |L1.4128|
                          DCD      WM__NumInvalidWindows
                  |L1.4132|
                          DCD      NextDrawWin
                  |L1.4136|
                          DCD      WM__FirstWin
                  |L1.4140|
                          DCD      WM_pfPollPID
                  |L1.4144|
                          DCD      WM_pfHandlePID
                  |L1.4148|
                          DCD      WM_IsActive
                  |L1.4152|
                          DCD      WM__aBkColor
                  |L1.4156|
                          DCD      _IsInited
                  |L1.4160|
                          DCD      WM__NumWindows
                  |L1.4164|
                          DCD      cbBackWin
                  |L1.4168|
                          DCD      WM__ahDesktopWin
                  |L1.4172|
                          DCD      WM__CHWinModal
                  |L1.4176|
                          DCD      WM__CHWinLast

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  WM_PID__StateLast
                          %        12
                  _ClipContext
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  _CursorHidden
000000  0000              DCB      0x00,0x00
                  WM__NumWindows
000002  0000              DCB      0x00,0x00
                  WM__NumInvalidWindows
000004  0000              DCB      0x00,0x00
                  WM__FirstWin
000006  0000              DCB      0x00,0x00
                  WM__pFirstCriticalHandle
                          DCD      0x00000000
                  WM__ahDesktopWin
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  WM__aBkColor
                          DCD      0x00000000
                  WM_IsActive
000014  0000              DCB      0x00,0x00
                  WM__CreateFlags
000016  0000              DCB      0x00,0x00
                  WM__hCapture
000018  0000              DCB      0x00,0x00
                  WM__hWinFocus
00001a  0000              DCB      0x00,0x00
                  WM__CaptureReleaseAuto
00001c  00000000          DCB      0x00,0x00,0x00,0x00
                  WM_pfPollPID
                          DCD      0x00000000
                  WM__PaintCallbackCnt
000024  00000000          DCB      0x00,0x00,0x00,0x00
                  WM__TransWindowCnt
                          DCD      0x00000000
                  WM__hATransWindow
00002c  0000              DCB      0x00,0x00
                  NextDrawWin
00002e  0000              DCB      0x00,0x00
                  _IsInited
000030  00                DCB      0x00
