; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\Obj\os_tmr.o --depend=.\Obj\os_tmr.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\BaseDrive -I..\Ucosii -I..\Ucosii\Port -I..\Ucosii\Src -I..\Ucosii\Include -I..\Ucgui -I..\Ucgui\Config -I..\Ucgui\GUI_X -I..\Ucgui\GUI -I..\Ucgui\GUI\ConvertColor -I..\Ucgui\GUI\ConvertMono -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\LCDDriver -I..\Ucgui\GUI\MultiLayer -I..\Ucgui\GUI\Widget -I..\Ucgui\GUI\WM -I..\ExternalDrive\Lcd -I..\ExternalDrive\Touch -I..\Panel -ID:\Keil\ARM\INC -ID:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\os_tmr.crf ..\Ucosii\Src\os_tmr.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  OSTmr_Unlock PROC
;;;1057   #if OS_TMR_EN > 0
;;;1058   static  void  OSTmr_Unlock (void)
000000  b510              PUSH     {r4,lr}
;;;1059   {
;;;1060       (void)OSSemPost(OSTmrSem);
000002  48fa              LDR      r0,|L1.1004|
000004  6800              LDR      r0,[r0,#0]  ; OSTmrSem
000006  f7fffffe          BL       OSSemPost
;;;1061   }
00000a  bd10              POP      {r4,pc}
;;;1062   #endif
                          ENDP

                  OSTmr_Alloc PROC
;;;734    #if OS_TMR_EN > 0
;;;735    static  OS_TMR  *OSTmr_Alloc (void)
00000c  48f8              LDR      r0,|L1.1008|
;;;736    {
;;;737        OS_TMR *ptmr;
;;;738    
;;;739    
;;;740        if (OSTmrFreeList == (OS_TMR *)0) {
00000e  6800              LDR      r0,[r0,#0]  ; OSTmrFreeList
000010  b908              CBNZ     r0,|L1.22|
;;;741            return ((OS_TMR *)0);
000012  2000              MOVS     r0,#0
                  |L1.20|
;;;742        }
;;;743        ptmr            = (OS_TMR *)OSTmrFreeList;
;;;744        OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
;;;745        ptmr->OSTmrNext = (OS_TCB *)0;
;;;746        ptmr->OSTmrPrev = (OS_TCB *)0;
;;;747        OSTmrUsed++;
;;;748        OSTmrFree--;
;;;749        return (ptmr);
;;;750    }
000014  4770              BX       lr
                  |L1.22|
000016  48f6              LDR      r0,|L1.1008|
000018  6801              LDR      r1,[r0,#0]            ;743  ; OSTmrFreeList
00001a  4af5              LDR      r2,|L1.1008|
00001c  68c8              LDR      r0,[r1,#0xc]          ;744
00001e  6010              STR      r0,[r2,#0]            ;744  ; OSTmrFreeList
000020  2000              MOVS     r0,#0                 ;745
000022  60c8              STR      r0,[r1,#0xc]          ;745
000024  6108              STR      r0,[r1,#0x10]         ;746
000026  48f3              LDR      r0,|L1.1012|
000028  8800              LDRH     r0,[r0,#0]            ;747  ; OSTmrUsed
00002a  1c40              ADDS     r0,r0,#1              ;747
00002c  4af1              LDR      r2,|L1.1012|
00002e  8010              STRH     r0,[r2,#0]            ;747
000030  48f1              LDR      r0,|L1.1016|
000032  8800              LDRH     r0,[r0,#0]            ;748  ; OSTmrFree
000034  1e40              SUBS     r0,r0,#1              ;748
000036  4af0              LDR      r2,|L1.1016|
000038  8010              STRH     r0,[r2,#0]            ;748
00003a  4608              MOV      r0,r1                 ;749
00003c  e7ea              B        |L1.20|
;;;751    #endif
                          ENDP

                  OSTmr_Lock PROC
;;;1044   #if OS_TMR_EN > 0
;;;1045   static  void  OSTmr_Lock (void)
00003e  b508              PUSH     {r3,lr}
;;;1046   {
;;;1047       INT8U  err;
;;;1048   
;;;1049   
;;;1050       OSSemPend(OSTmrSem, 0, &err);
000040  466a              MOV      r2,sp
000042  2100              MOVS     r1,#0
000044  48e9              LDR      r0,|L1.1004|
000046  6800              LDR      r0,[r0,#0]  ; OSTmrSem
000048  f7fffffe          BL       OSSemPend
;;;1051       (void)err;
;;;1052   }
00004c  bd08              POP      {r3,pc}
;;;1053   #endif
                          ENDP

                  OSTmrCreate PROC
;;;112    #if OS_TMR_EN > 0
;;;113    OS_TMR  *OSTmrCreate (INT32U           dly,
00004e  e92d5fff          PUSH     {r0-r12,lr}
;;;114                          INT32U           period,
;;;115                          INT8U            opt,
;;;116                          OS_TMR_CALLBACK  callback,
;;;117                          void            *callback_arg,
;;;118                          INT8U           *pname,
;;;119                          INT8U           *perr)
;;;120    {
000052  4606              MOV      r6,r0
000054  460f              MOV      r7,r1
000056  4690              MOV      r8,r2
000058  469b              MOV      r11,r3
00005a  e9dd950f          LDRD     r9,r5,[sp,#0x3c]
;;;121        OS_TMR   *ptmr;
;;;122    #if OS_TMR_CFG_NAME_SIZE > 0
;;;123        INT8U     len;
;;;124    #endif
;;;125    
;;;126    
;;;127    #if OS_ARG_CHK_EN > 0
;;;128        if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
00005e  b91d              CBNZ     r5,|L1.104|
;;;129            return ((OS_TMR *)0);
000060  2000              MOVS     r0,#0
                  |L1.98|
;;;130        }
;;;131        switch (opt) {
;;;132            case OS_TMR_OPT_PERIODIC:
;;;133                 if (period == 0) {
;;;134                     *perr = OS_ERR_TMR_INVALID_PERIOD;
;;;135                     return ((OS_TMR *)0);
;;;136                 }
;;;137                 break;
;;;138    
;;;139            case OS_TMR_OPT_ONE_SHOT:
;;;140                 if (dly == 0) {
;;;141                     *perr = OS_ERR_TMR_INVALID_DLY;
;;;142                     return ((OS_TMR *)0);
;;;143                 }
;;;144                 break;
;;;145    
;;;146            default:
;;;147                 *perr = OS_ERR_TMR_INVALID_OPT;
;;;148                 return ((OS_TMR *)0);
;;;149        }
;;;150    #endif
;;;151        if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
;;;152            *perr  = OS_ERR_TMR_ISR;
;;;153            return ((OS_TMR *)0);
;;;154        }
;;;155        OSTmr_Lock();
;;;156        ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
;;;157        if (ptmr == (OS_TMR *)0) {
;;;158            OSTmr_Unlock();
;;;159            *perr = OS_ERR_TMR_NON_AVAIL;
;;;160            return ((OS_TMR *)0);
;;;161        }
;;;162        ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
;;;163        ptmr->OSTmrDly         = dly;
;;;164        ptmr->OSTmrPeriod      = period;
;;;165        ptmr->OSTmrOpt         = opt;
;;;166        ptmr->OSTmrCallback    = callback;
;;;167        ptmr->OSTmrCallbackArg = callback_arg;
;;;168    #if OS_TMR_CFG_NAME_SIZE > 0
;;;169        if (pname !=(INT8U *)0) {
;;;170            len = OS_StrLen(pname);                             /* Copy timer name                                        */
;;;171            if (len < OS_TMR_CFG_NAME_SIZE) {
;;;172                (void)OS_StrCopy(ptmr->OSTmrName, pname);
;;;173            } else {
;;;174    #if OS_TMR_CFG_NAME_SIZE > 1
;;;175                ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
;;;176                ptmr->OSTmrName[1] = OS_ASCII_NUL;
;;;177    #endif
;;;178                *perr              = OS_ERR_TMR_NAME_TOO_LONG;
;;;179                OSTmr_Unlock();
;;;180                return (ptmr);
;;;181            }
;;;182        }
;;;183    #endif
;;;184        OSTmr_Unlock();
;;;185        *perr = OS_ERR_NONE;
;;;186        return (ptmr);
;;;187    }
000062  b004              ADD      sp,sp,#0x10
000064  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.104|
000068  f1b80f01          CMP      r8,#1                 ;131
00006c  d008              BEQ      |L1.128|
00006e  f1b80f02          CMP      r8,#2                 ;131
000072  d10b              BNE      |L1.140|
000074  b91f              CBNZ     r7,|L1.126|
000076  2083              MOVS     r0,#0x83              ;134
000078  7028              STRB     r0,[r5,#0]            ;134
00007a  2000              MOVS     r0,#0                 ;135
00007c  e7f1              B        |L1.98|
                  |L1.126|
00007e  e009              B        |L1.148|
                  |L1.128|
000080  b91e              CBNZ     r6,|L1.138|
000082  2082              MOVS     r0,#0x82              ;141
000084  7028              STRB     r0,[r5,#0]            ;141
000086  2000              MOVS     r0,#0                 ;142
000088  e7eb              B        |L1.98|
                  |L1.138|
00008a  e003              B        |L1.148|
                  |L1.140|
00008c  2084              MOVS     r0,#0x84              ;147
00008e  7028              STRB     r0,[r5,#0]            ;147
000090  2000              MOVS     r0,#0                 ;148
000092  e7e6              B        |L1.98|
                  |L1.148|
000094  bf00              NOP                            ;137
000096  48d9              LDR      r0,|L1.1020|
000098  7800              LDRB     r0,[r0,#0]            ;151  ; OSIntNesting
00009a  2800              CMP      r0,#0                 ;151
00009c  dd03              BLE      |L1.166|
00009e  208b              MOVS     r0,#0x8b              ;152
0000a0  7028              STRB     r0,[r5,#0]            ;152
0000a2  2000              MOVS     r0,#0                 ;153
0000a4  e7dd              B        |L1.98|
                  |L1.166|
0000a6  f7fffffe          BL       OSTmr_Lock
0000aa  f7fffffe          BL       OSTmr_Alloc
0000ae  4604              MOV      r4,r0                 ;156
0000b0  b92c              CBNZ     r4,|L1.190|
0000b2  f7fffffe          BL       OSTmr_Unlock
0000b6  2086              MOVS     r0,#0x86              ;159
0000b8  7028              STRB     r0,[r5,#0]            ;159
0000ba  2000              MOVS     r0,#0                 ;160
0000bc  e7d1              B        |L1.98|
                  |L1.190|
0000be  2001              MOVS     r0,#1                 ;162
0000c0  f8840031          STRB     r0,[r4,#0x31]         ;162
0000c4  61a6              STR      r6,[r4,#0x18]         ;163
0000c6  61e7              STR      r7,[r4,#0x1c]         ;164
0000c8  f8848030          STRB     r8,[r4,#0x30]         ;165
0000cc  f8c4b004          STR      r11,[r4,#4]           ;166
0000d0  980e              LDR      r0,[sp,#0x38]         ;167
0000d2  60a0              STR      r0,[r4,#8]            ;167
0000d4  f1b90f00          CMP      r9,#0                 ;169
0000d8  d018              BEQ      |L1.268|
0000da  4648              MOV      r0,r9                 ;170
0000dc  f7fffffe          BL       OS_StrLen
0000e0  4682              MOV      r10,r0                ;170
0000e2  f1ba0f10          CMP      r10,#0x10             ;171
0000e6  da05              BGE      |L1.244|
0000e8  4649              MOV      r1,r9                 ;172
0000ea  f1040020          ADD      r0,r4,#0x20           ;172
0000ee  f7fffffe          BL       OS_StrCopy
0000f2  e00b              B        |L1.268|
                  |L1.244|
0000f4  2023              MOVS     r0,#0x23              ;175
0000f6  f8840020          STRB     r0,[r4,#0x20]         ;175
0000fa  2100              MOVS     r1,#0                 ;176
0000fc  2021              MOVS     r0,#0x21              ;176
0000fe  5501              STRB     r1,[r0,r4]            ;176
000100  208c              MOVS     r0,#0x8c              ;178
000102  7028              STRB     r0,[r5,#0]            ;178
000104  f7fffffe          BL       OSTmr_Unlock
000108  4620              MOV      r0,r4                 ;180
00010a  e7aa              B        |L1.98|
                  |L1.268|
00010c  f7fffffe          BL       OSTmr_Unlock
000110  2000              MOVS     r0,#0                 ;185
000112  7028              STRB     r0,[r5,#0]            ;185
000114  4620              MOV      r0,r4                 ;186
000116  e7a4              B        |L1.98|
;;;188    #endif
                          ENDP

                  OSTmr_Free PROC
;;;766    #if OS_TMR_EN > 0
;;;767    static  void  OSTmr_Free (OS_TMR *ptmr)
000118  2100              MOVS     r1,#0
;;;768    {
;;;769        ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
00011a  f8801031          STRB     r1,[r0,#0x31]
;;;770        ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
00011e  f8801030          STRB     r1,[r0,#0x30]
;;;771        ptmr->OSTmrPeriod      = 0;
000122  61c1              STR      r1,[r0,#0x1c]
;;;772        ptmr->OSTmrMatch       = 0;
000124  6141              STR      r1,[r0,#0x14]
;;;773        ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
000126  6041              STR      r1,[r0,#4]
;;;774        ptmr->OSTmrCallbackArg = (void *)0;
000128  6081              STR      r1,[r0,#8]
;;;775    #if OS_TMR_CFG_NAME_SIZE > 1
;;;776        ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
00012a  213f              MOVS     r1,#0x3f
00012c  f8801020          STRB     r1,[r0,#0x20]
;;;777        ptmr->OSTmrName[1]     = OS_ASCII_NUL;
000130  2200              MOVS     r2,#0
000132  2121              MOVS     r1,#0x21
000134  540a              STRB     r2,[r1,r0]
;;;778    #endif
;;;779    
;;;780        ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
000136  2100              MOVS     r1,#0
000138  6101              STR      r1,[r0,#0x10]
;;;781        ptmr->OSTmrNext        = OSTmrFreeList;
00013a  49ad              LDR      r1,|L1.1008|
00013c  6809              LDR      r1,[r1,#0]  ; OSTmrFreeList
00013e  60c1              STR      r1,[r0,#0xc]
;;;782        OSTmrFreeList          = ptmr;
000140  49ab              LDR      r1,|L1.1008|
000142  6008              STR      r0,[r1,#0]  ; OSTmrFreeList
;;;783    
;;;784        OSTmrUsed--;                                       /* Update timer object statistics                              */
000144  49ab              LDR      r1,|L1.1012|
000146  8809              LDRH     r1,[r1,#0]  ; OSTmrUsed
000148  1e49              SUBS     r1,r1,#1
00014a  4aaa              LDR      r2,|L1.1012|
00014c  8011              STRH     r1,[r2,#0]
;;;785        OSTmrFree++;
00014e  49aa              LDR      r1,|L1.1016|
000150  8809              LDRH     r1,[r1,#0]  ; OSTmrFree
000152  1c49              ADDS     r1,r1,#1
000154  4aa8              LDR      r2,|L1.1016|
000156  8011              STRH     r1,[r2,#0]
;;;786    }
000158  4770              BX       lr
;;;787    #endif
                          ENDP

                  OSTmr_Unlink PROC
;;;998    #if OS_TMR_EN > 0
;;;999    static  void  OSTmr_Unlink (OS_TMR *ptmr)
00015a  b530              PUSH     {r4,r5,lr}
;;;1000   {
;;;1001       OS_TMR        *ptmr1;
;;;1002       OS_TMR        *ptmr2;
;;;1003       OS_TMR_WHEEL  *pspoke;
;;;1004       INT16U         spoke;
;;;1005   
;;;1006   
;;;1007       spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
00015c  6945              LDR      r5,[r0,#0x14]
00015e  f0050407          AND      r4,r5,#7
;;;1008       pspoke = &OSTmrWheelTbl[spoke];
000162  4da7              LDR      r5,|L1.1024|
000164  eb0503c4          ADD      r3,r5,r4,LSL #3
;;;1009   
;;;1010       if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
000168  681d              LDR      r5,[r3,#0]
00016a  4285              CMP      r5,r0
00016c  d105              BNE      |L1.378|
;;;1011           ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
00016e  68c1              LDR      r1,[r0,#0xc]
;;;1012           pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
000170  6019              STR      r1,[r3,#0]
;;;1013           if (ptmr1 != (OS_TMR *)0) {
000172  b139              CBZ      r1,|L1.388|
;;;1014               ptmr1->OSTmrPrev = (void *)0;
000174  2500              MOVS     r5,#0
000176  610d              STR      r5,[r1,#0x10]
000178  e004              B        |L1.388|
                  |L1.378|
;;;1015           }
;;;1016       } else {
;;;1017           ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
00017a  6901              LDR      r1,[r0,#0x10]
;;;1018           ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
00017c  68c2              LDR      r2,[r0,#0xc]
;;;1019           ptmr1->OSTmrNext = ptmr2;
00017e  60ca              STR      r2,[r1,#0xc]
;;;1020           if (ptmr2 != (OS_TMR *)0) {
000180  b102              CBZ      r2,|L1.388|
;;;1021               ptmr2->OSTmrPrev = (void *)ptmr1;
000182  6111              STR      r1,[r2,#0x10]
                  |L1.388|
;;;1022           }
;;;1023       }
;;;1024       ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
000184  2501              MOVS     r5,#1
000186  f8805031          STRB     r5,[r0,#0x31]
;;;1025       ptmr->OSTmrNext  = (void *)0;
00018a  2500              MOVS     r5,#0
00018c  60c5              STR      r5,[r0,#0xc]
;;;1026       ptmr->OSTmrPrev  = (void *)0;
00018e  6105              STR      r5,[r0,#0x10]
;;;1027       pspoke->OSTmrEntries--;
000190  889d              LDRH     r5,[r3,#4]
000192  1e6d              SUBS     r5,r5,#1
000194  809d              STRH     r5,[r3,#4]
;;;1028   }
000196  bd30              POP      {r4,r5,pc}
;;;1029   #endif
                          ENDP

                  OSTmrDel PROC
;;;212    #if OS_TMR_EN > 0
;;;213    BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
000198  b570              PUSH     {r4-r6,lr}
;;;214                       INT8U   *perr)
;;;215    {
00019a  4605              MOV      r5,r0
00019c  460c              MOV      r4,r1
;;;216    #if OS_ARG_CHK_EN > 0
;;;217        if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
00019e  b90c              CBNZ     r4,|L1.420|
;;;218            return (OS_FALSE);
0001a0  2000              MOVS     r0,#0
                  |L1.418|
;;;219        }
;;;220        if (ptmr == (OS_TMR *)0) {
;;;221            *perr = OS_ERR_TMR_INVALID;
;;;222            return (OS_FALSE);
;;;223        }
;;;224    #endif
;;;225        if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
;;;226            *perr = OS_ERR_TMR_INVALID_TYPE;
;;;227            return (OS_FALSE);
;;;228        }
;;;229        if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
;;;230            *perr  = OS_ERR_TMR_ISR;
;;;231            return (OS_FALSE);
;;;232        }
;;;233        OSTmr_Lock();
;;;234        switch (ptmr->OSTmrState) {
;;;235            case OS_TMR_STATE_RUNNING:
;;;236                 OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
;;;237                 OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
;;;238                 OSTmr_Unlock();
;;;239                 *perr = OS_ERR_NONE;
;;;240                 return (OS_TRUE);
;;;241    
;;;242            case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
;;;243            case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
;;;244                 OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
;;;245                 OSTmr_Unlock();
;;;246                 *perr = OS_ERR_NONE;
;;;247                 return (OS_TRUE);
;;;248    
;;;249            case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
;;;250                 OSTmr_Unlock();
;;;251                 *perr = OS_ERR_TMR_INACTIVE;
;;;252                 return (OS_FALSE);
;;;253    
;;;254            default:
;;;255                 OSTmr_Unlock();
;;;256                 *perr = OS_ERR_TMR_INVALID_STATE;
;;;257                 return (OS_FALSE);
;;;258        }
;;;259    }
0001a2  bd70              POP      {r4-r6,pc}
                  |L1.420|
0001a4  b91d              CBNZ     r5,|L1.430|
0001a6  208a              MOVS     r0,#0x8a              ;221
0001a8  7020              STRB     r0,[r4,#0]            ;221
0001aa  2000              MOVS     r0,#0                 ;222
0001ac  e7f9              B        |L1.418|
                  |L1.430|
0001ae  7828              LDRB     r0,[r5,#0]            ;225
0001b0  2864              CMP      r0,#0x64              ;225
0001b2  d003              BEQ      |L1.444|
0001b4  2089              MOVS     r0,#0x89              ;226
0001b6  7020              STRB     r0,[r4,#0]            ;226
0001b8  2000              MOVS     r0,#0                 ;227
0001ba  e7f2              B        |L1.418|
                  |L1.444|
0001bc  488f              LDR      r0,|L1.1020|
0001be  7800              LDRB     r0,[r0,#0]            ;229  ; OSIntNesting
0001c0  2800              CMP      r0,#0                 ;229
0001c2  dd03              BLE      |L1.460|
0001c4  208b              MOVS     r0,#0x8b              ;230
0001c6  7020              STRB     r0,[r4,#0]            ;230
0001c8  2000              MOVS     r0,#0                 ;231
0001ca  e7ea              B        |L1.418|
                  |L1.460|
0001cc  f7fffffe          BL       OSTmr_Lock
0001d0  f8950031          LDRB     r0,[r5,#0x31]         ;234
0001d4  b1d8              CBZ      r0,|L1.526|
0001d6  2801              CMP      r0,#1                 ;234
0001d8  d00f              BEQ      |L1.506|
0001da  2802              CMP      r0,#2                 ;234
0001dc  d00e              BEQ      |L1.508|
0001de  2803              CMP      r0,#3                 ;234
0001e0  d11b              BNE      |L1.538|
0001e2  4628              MOV      r0,r5                 ;236
0001e4  f7fffffe          BL       OSTmr_Unlink
0001e8  4628              MOV      r0,r5                 ;237
0001ea  f7fffffe          BL       OSTmr_Free
0001ee  f7fffffe          BL       OSTmr_Unlock
0001f2  2000              MOVS     r0,#0                 ;239
0001f4  7020              STRB     r0,[r4,#0]            ;239
0001f6  2001              MOVS     r0,#1                 ;240
0001f8  e7d3              B        |L1.418|
                  |L1.506|
0001fa  bf00              NOP                            ;243
                  |L1.508|
0001fc  4628              MOV      r0,r5                 ;244
0001fe  f7fffffe          BL       OSTmr_Free
000202  f7fffffe          BL       OSTmr_Unlock
000206  2000              MOVS     r0,#0                 ;246
000208  7020              STRB     r0,[r4,#0]            ;246
00020a  2001              MOVS     r0,#1                 ;247
00020c  e7c9              B        |L1.418|
                  |L1.526|
00020e  f7fffffe          BL       OSTmr_Unlock
000212  2087              MOVS     r0,#0x87              ;251
000214  7020              STRB     r0,[r4,#0]            ;251
000216  2000              MOVS     r0,#0                 ;252
000218  e7c3              B        |L1.418|
                  |L1.538|
00021a  f7fffffe          BL       OSTmr_Unlock
00021e  208d              MOVS     r0,#0x8d              ;256
000220  7020              STRB     r0,[r4,#0]            ;256
000222  2000              MOVS     r0,#0                 ;257
000224  e7bd              B        |L1.418|
;;;260    #endif
                          ENDP

                  OSTmrNameGet PROC
;;;287    #if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
;;;288    INT8U  OSTmrNameGet (OS_TMR  *ptmr,
000226  e92d41f0          PUSH     {r4-r8,lr}
;;;289                         INT8U   *pdest,
;;;290                         INT8U   *perr)
;;;291    {
00022a  4605              MOV      r5,r0
00022c  460e              MOV      r6,r1
00022e  4614              MOV      r4,r2
;;;292        INT8U  len;
;;;293    
;;;294    
;;;295    #if OS_ARG_CHK_EN > 0
;;;296        if (perr == (INT8U *)0) {
000230  b914              CBNZ     r4,|L1.568|
;;;297            return (0);
000232  2000              MOVS     r0,#0
                  |L1.564|
;;;298        }
;;;299        if (pdest == (INT8U *)0) {
;;;300            *perr = OS_ERR_TMR_INVALID_DEST;
;;;301            return (0);
;;;302        }
;;;303        if (ptmr == (OS_TMR *)0) {
;;;304            *perr = OS_ERR_TMR_INVALID;
;;;305            return (0);
;;;306        }
;;;307    #endif
;;;308        if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
;;;309            *perr = OS_ERR_TMR_INVALID_TYPE;
;;;310            return (0);
;;;311        }
;;;312        if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
;;;313            *perr = OS_ERR_NAME_GET_ISR;
;;;314            return (0);
;;;315        }
;;;316        OSTmr_Lock();
;;;317        switch (ptmr->OSTmrState) {
;;;318            case OS_TMR_STATE_RUNNING:
;;;319            case OS_TMR_STATE_STOPPED:
;;;320            case OS_TMR_STATE_COMPLETED:
;;;321                 len   = OS_StrCopy(pdest, ptmr->OSTmrName);
;;;322                 OSTmr_Unlock();
;;;323                 *perr = OS_ERR_NONE;
;;;324                 return (len);
;;;325    
;;;326            case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
;;;327                 OSTmr_Unlock();
;;;328                 *perr = OS_ERR_TMR_INACTIVE;
;;;329                 return (0);
;;;330    
;;;331            default:
;;;332                 OSTmr_Unlock();
;;;333                 *perr = OS_ERR_TMR_INVALID_STATE;
;;;334                 return (0);
;;;335        }
;;;336    }
000234  e8bd81f0          POP      {r4-r8,pc}
                  |L1.568|
000238  b91e              CBNZ     r6,|L1.578|
00023a  2088              MOVS     r0,#0x88              ;300
00023c  7020              STRB     r0,[r4,#0]            ;300
00023e  2000              MOVS     r0,#0                 ;301
000240  e7f8              B        |L1.564|
                  |L1.578|
000242  b91d              CBNZ     r5,|L1.588|
000244  208a              MOVS     r0,#0x8a              ;304
000246  7020              STRB     r0,[r4,#0]            ;304
000248  2000              MOVS     r0,#0                 ;305
00024a  e7f3              B        |L1.564|
                  |L1.588|
00024c  7828              LDRB     r0,[r5,#0]            ;308
00024e  2864              CMP      r0,#0x64              ;308
000250  d003              BEQ      |L1.602|
000252  2089              MOVS     r0,#0x89              ;309
000254  7020              STRB     r0,[r4,#0]            ;309
000256  2000              MOVS     r0,#0                 ;310
000258  e7ec              B        |L1.564|
                  |L1.602|
00025a  4868              LDR      r0,|L1.1020|
00025c  7800              LDRB     r0,[r0,#0]            ;312  ; OSIntNesting
00025e  2800              CMP      r0,#0                 ;312
000260  dd03              BLE      |L1.618|
000262  2011              MOVS     r0,#0x11              ;313
000264  7020              STRB     r0,[r4,#0]            ;313
000266  2000              MOVS     r0,#0                 ;314
000268  e7e4              B        |L1.564|
                  |L1.618|
00026a  f7fffffe          BL       OSTmr_Lock
00026e  f8950031          LDRB     r0,[r5,#0x31]         ;317
000272  b198              CBZ      r0,|L1.668|
000274  2801              CMP      r0,#1                 ;317
000276  d004              BEQ      |L1.642|
000278  2802              CMP      r0,#2                 ;317
00027a  d003              BEQ      |L1.644|
00027c  2803              CMP      r0,#3                 ;317
00027e  d113              BNE      |L1.680|
000280  bf00              NOP                            ;319
                  |L1.642|
000282  bf00              NOP                            ;320
                  |L1.644|
000284  f1050120          ADD      r1,r5,#0x20           ;321
000288  4630              MOV      r0,r6                 ;321
00028a  f7fffffe          BL       OS_StrCopy
00028e  4607              MOV      r7,r0                 ;321
000290  f7fffffe          BL       OSTmr_Unlock
000294  2000              MOVS     r0,#0                 ;323
000296  7020              STRB     r0,[r4,#0]            ;323
000298  4638              MOV      r0,r7                 ;324
00029a  e7cb              B        |L1.564|
                  |L1.668|
00029c  f7fffffe          BL       OSTmr_Unlock
0002a0  2087              MOVS     r0,#0x87              ;328
0002a2  7020              STRB     r0,[r4,#0]            ;328
0002a4  2000              MOVS     r0,#0                 ;329
0002a6  e7c5              B        |L1.564|
                  |L1.680|
0002a8  f7fffffe          BL       OSTmr_Unlock
0002ac  208d              MOVS     r0,#0x8d              ;333
0002ae  7020              STRB     r0,[r4,#0]            ;333
0002b0  2000              MOVS     r0,#0                 ;334
0002b2  e7bf              B        |L1.564|
;;;337    #endif
                          ENDP

                  OSTmrRemainGet PROC
;;;362    #if OS_TMR_EN > 0
;;;363    INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
0002b4  b570              PUSH     {r4-r6,lr}
;;;364                            INT8U   *perr)
;;;365    {
0002b6  4605              MOV      r5,r0
0002b8  460c              MOV      r4,r1
;;;366        INT32U  remain;
;;;367    
;;;368    
;;;369    #if OS_ARG_CHK_EN > 0
;;;370        if (perr == (INT8U *)0) {
0002ba  b90c              CBNZ     r4,|L1.704|
;;;371            return (0);
0002bc  2000              MOVS     r0,#0
                  |L1.702|
;;;372        }
;;;373        if (ptmr == (OS_TMR *)0) {
;;;374            *perr = OS_ERR_TMR_INVALID;
;;;375            return (0);
;;;376        }
;;;377    #endif
;;;378        if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
;;;379            *perr = OS_ERR_TMR_INVALID_TYPE;
;;;380            return (0);
;;;381        }
;;;382        if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
;;;383            *perr = OS_ERR_TMR_ISR;
;;;384            return (0);
;;;385        }
;;;386        OSTmr_Lock();
;;;387        switch (ptmr->OSTmrState) {
;;;388            case OS_TMR_STATE_RUNNING:
;;;389                 remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
;;;390                 OSTmr_Unlock();
;;;391                 *perr  = OS_ERR_NONE;
;;;392                 return (remain);
;;;393    
;;;394            case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
;;;395                 switch (ptmr->OSTmrOpt) {
;;;396                     case OS_TMR_OPT_PERIODIC:
;;;397                          if (ptmr->OSTmrDly == 0) {
;;;398                              remain = ptmr->OSTmrPeriod;
;;;399                          } else {
;;;400                              remain = ptmr->OSTmrDly;
;;;401                          }
;;;402                          OSTmr_Unlock();
;;;403                          *perr  = OS_ERR_NONE;
;;;404                          break;
;;;405    
;;;406                     case OS_TMR_OPT_ONE_SHOT:
;;;407                     default:
;;;408                          remain = ptmr->OSTmrDly;
;;;409                          OSTmr_Unlock();
;;;410                          *perr  = OS_ERR_NONE;
;;;411                          break;
;;;412                 }
;;;413                 return (remain);
;;;414    
;;;415            case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
;;;416                 OSTmr_Unlock();
;;;417                 *perr = OS_ERR_NONE;
;;;418                 return (0);
;;;419    
;;;420            case OS_TMR_STATE_UNUSED:
;;;421                 OSTmr_Unlock();
;;;422                 *perr = OS_ERR_TMR_INACTIVE;
;;;423                 return (0);
;;;424    
;;;425            default:
;;;426                 OSTmr_Unlock();
;;;427                 *perr = OS_ERR_TMR_INVALID_STATE;
;;;428                 return (0);
;;;429        }
;;;430    }
0002be  bd70              POP      {r4-r6,pc}
                  |L1.704|
0002c0  b91d              CBNZ     r5,|L1.714|
0002c2  208a              MOVS     r0,#0x8a              ;374
0002c4  7020              STRB     r0,[r4,#0]            ;374
0002c6  2000              MOVS     r0,#0                 ;375
0002c8  e7f9              B        |L1.702|
                  |L1.714|
0002ca  7828              LDRB     r0,[r5,#0]            ;378
0002cc  2864              CMP      r0,#0x64              ;378
0002ce  d003              BEQ      |L1.728|
0002d0  2089              MOVS     r0,#0x89              ;379
0002d2  7020              STRB     r0,[r4,#0]            ;379
0002d4  2000              MOVS     r0,#0                 ;380
0002d6  e7f2              B        |L1.702|
                  |L1.728|
0002d8  4848              LDR      r0,|L1.1020|
0002da  7800              LDRB     r0,[r0,#0]            ;382  ; OSIntNesting
0002dc  2800              CMP      r0,#0                 ;382
0002de  dd03              BLE      |L1.744|
0002e0  208b              MOVS     r0,#0x8b              ;383
0002e2  7020              STRB     r0,[r4,#0]            ;383
0002e4  2000              MOVS     r0,#0                 ;384
0002e6  e7ea              B        |L1.702|
                  |L1.744|
0002e8  f7fffffe          BL       OSTmr_Lock
0002ec  f8950031          LDRB     r0,[r5,#0x31]         ;387
0002f0  b370              CBZ      r0,|L1.848|
0002f2  2801              CMP      r0,#1                 ;387
0002f4  d00d              BEQ      |L1.786|
0002f6  2802              CMP      r0,#2                 ;387
0002f8  d025              BEQ      |L1.838|
0002fa  2803              CMP      r0,#3                 ;387
0002fc  d12e              BNE      |L1.860|
0002fe  4941              LDR      r1,|L1.1028|
000300  6968              LDR      r0,[r5,#0x14]         ;389
000302  6809              LDR      r1,[r1,#0]            ;389  ; OSTmrTime
000304  1a46              SUBS     r6,r0,r1              ;389
000306  f7fffffe          BL       OSTmr_Unlock
00030a  2000              MOVS     r0,#0                 ;391
00030c  7020              STRB     r0,[r4,#0]            ;391
00030e  4630              MOV      r0,r6                 ;392
000310  e7d5              B        |L1.702|
                  |L1.786|
000312  f8950030          LDRB     r0,[r5,#0x30]         ;395
000316  2801              CMP      r0,#1                 ;395
000318  d00c              BEQ      |L1.820|
00031a  2802              CMP      r0,#2                 ;395
00031c  d109              BNE      |L1.818|
00031e  69a8              LDR      r0,[r5,#0x18]         ;397
000320  b908              CBNZ     r0,|L1.806|
000322  69ee              LDR      r6,[r5,#0x1c]         ;398
000324  e000              B        |L1.808|
                  |L1.806|
000326  69ae              LDR      r6,[r5,#0x18]         ;400
                  |L1.808|
000328  f7fffffe          BL       OSTmr_Unlock
00032c  2000              MOVS     r0,#0                 ;403
00032e  7020              STRB     r0,[r4,#0]            ;403
000330  e006              B        |L1.832|
                  |L1.818|
000332  bf00              NOP                            ;406
                  |L1.820|
000334  69ae              LDR      r6,[r5,#0x18]         ;408
000336  f7fffffe          BL       OSTmr_Unlock
00033a  2000              MOVS     r0,#0                 ;410
00033c  7020              STRB     r0,[r4,#0]            ;410
00033e  bf00              NOP                            ;411
                  |L1.832|
000340  bf00              NOP                            ;404
000342  4630              MOV      r0,r6                 ;413
000344  e7bb              B        |L1.702|
                  |L1.838|
000346  f7fffffe          BL       OSTmr_Unlock
00034a  2000              MOVS     r0,#0                 ;417
00034c  7020              STRB     r0,[r4,#0]            ;417
00034e  e7b6              B        |L1.702|
                  |L1.848|
000350  f7fffffe          BL       OSTmr_Unlock
000354  2087              MOVS     r0,#0x87              ;422
000356  7020              STRB     r0,[r4,#0]            ;422
000358  2000              MOVS     r0,#0                 ;423
00035a  e7b0              B        |L1.702|
                  |L1.860|
00035c  f7fffffe          BL       OSTmr_Unlock
000360  208d              MOVS     r0,#0x8d              ;427
000362  7020              STRB     r0,[r4,#0]            ;427
000364  2000              MOVS     r0,#0                 ;428
000366  e7aa              B        |L1.702|
;;;431    #endif
                          ENDP

                  OSTmrStateGet PROC
;;;459    #if OS_TMR_EN > 0
;;;460    INT8U  OSTmrStateGet (OS_TMR  *ptmr,
000368  b570              PUSH     {r4-r6,lr}
;;;461                          INT8U   *perr)
;;;462    {
00036a  4605              MOV      r5,r0
00036c  460c              MOV      r4,r1
;;;463        INT8U  state;
;;;464    
;;;465    
;;;466    #if OS_ARG_CHK_EN > 0
;;;467        if (perr == (INT8U *)0) {
00036e  b90c              CBNZ     r4,|L1.884|
;;;468            return (0);
000370  2000              MOVS     r0,#0
                  |L1.882|
;;;469        }
;;;470        if (ptmr == (OS_TMR *)0) {
;;;471            *perr = OS_ERR_TMR_INVALID;
;;;472            return (0);
;;;473        }
;;;474    #endif
;;;475        if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
;;;476            *perr = OS_ERR_TMR_INVALID_TYPE;
;;;477            return (0);
;;;478        }
;;;479        if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
;;;480            *perr = OS_ERR_TMR_ISR;
;;;481            return (0);
;;;482        }
;;;483        OSTmr_Lock();
;;;484        state = ptmr->OSTmrState;
;;;485        switch (state) {
;;;486            case OS_TMR_STATE_UNUSED:   
;;;487            case OS_TMR_STATE_STOPPED:  
;;;488            case OS_TMR_STATE_COMPLETED:
;;;489            case OS_TMR_STATE_RUNNING:  
;;;490                 *perr = OS_ERR_NONE;
;;;491                 break;
;;;492                 
;;;493            default:
;;;494                 *perr = OS_ERR_TMR_INVALID_STATE;
;;;495                 break;
;;;496        }
;;;497        OSTmr_Unlock();
;;;498        return (state);
;;;499    }
000372  bd70              POP      {r4-r6,pc}
                  |L1.884|
000374  b91d              CBNZ     r5,|L1.894|
000376  208a              MOVS     r0,#0x8a              ;471
000378  7020              STRB     r0,[r4,#0]            ;471
00037a  2000              MOVS     r0,#0                 ;472
00037c  e7f9              B        |L1.882|
                  |L1.894|
00037e  7828              LDRB     r0,[r5,#0]            ;475
000380  2864              CMP      r0,#0x64              ;475
000382  d003              BEQ      |L1.908|
000384  2089              MOVS     r0,#0x89              ;476
000386  7020              STRB     r0,[r4,#0]            ;476
000388  2000              MOVS     r0,#0                 ;477
00038a  e7f2              B        |L1.882|
                  |L1.908|
00038c  481b              LDR      r0,|L1.1020|
00038e  7800              LDRB     r0,[r0,#0]            ;479  ; OSIntNesting
000390  2800              CMP      r0,#0                 ;479
000392  dd03              BLE      |L1.924|
000394  208b              MOVS     r0,#0x8b              ;480
000396  7020              STRB     r0,[r4,#0]            ;480
000398  2000              MOVS     r0,#0                 ;481
00039a  e7ea              B        |L1.882|
                  |L1.924|
00039c  f7fffffe          BL       OSTmr_Lock
0003a0  f8956031          LDRB     r6,[r5,#0x31]         ;484
0003a4  b136              CBZ      r6,|L1.948|
0003a6  2e01              CMP      r6,#1                 ;485
0003a8  d005              BEQ      |L1.950|
0003aa  2e02              CMP      r6,#2                 ;485
0003ac  d004              BEQ      |L1.952|
0003ae  2e03              CMP      r6,#3                 ;485
0003b0  d106              BNE      |L1.960|
0003b2  e002              B        |L1.954|
                  |L1.948|
0003b4  bf00              NOP                            ;487
                  |L1.950|
0003b6  bf00              NOP                            ;488
                  |L1.952|
0003b8  bf00              NOP                            ;489
                  |L1.954|
0003ba  2000              MOVS     r0,#0                 ;490
0003bc  7020              STRB     r0,[r4,#0]            ;490
0003be  e002              B        |L1.966|
                  |L1.960|
0003c0  208d              MOVS     r0,#0x8d              ;494
0003c2  7020              STRB     r0,[r4,#0]            ;494
0003c4  bf00              NOP                            ;495
                  |L1.966|
0003c6  bf00              NOP                            ;491
0003c8  f7fffffe          BL       OSTmr_Unlock
0003cc  4630              MOV      r0,r6                 ;498
0003ce  e7d0              B        |L1.882|
;;;500    #endif
                          ENDP

                  OSTmr_Link PROC
;;;949    #if OS_TMR_EN > 0
;;;950    static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
0003d0  b570              PUSH     {r4-r6,lr}
;;;951    {
0003d2  460c              MOV      r4,r1
;;;952        OS_TMR       *ptmr1;
;;;953        OS_TMR_WHEEL *pspoke;
;;;954        INT16U        spoke;
;;;955    
;;;956    
;;;957        ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
0003d4  2503              MOVS     r5,#3
0003d6  f8805031          STRB     r5,[r0,#0x31]
;;;958        if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
0003da  2c01              CMP      r4,#1
0003dc  d114              BNE      |L1.1032|
;;;959            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
0003de  4e09              LDR      r6,|L1.1028|
0003e0  69c5              LDR      r5,[r0,#0x1c]
0003e2  6836              LDR      r6,[r6,#0]  ; OSTmrTime
0003e4  4435              ADD      r5,r5,r6
0003e6  6145              STR      r5,[r0,#0x14]
0003e8  e01b              B        |L1.1058|
0003ea  0000              DCW      0x0000
                  |L1.1004|
                          DCD      OSTmrSem
                  |L1.1008|
                          DCD      OSTmrFreeList
                  |L1.1012|
                          DCD      OSTmrUsed
                  |L1.1016|
                          DCD      OSTmrFree
                  |L1.1020|
                          DCD      OSIntNesting
                  |L1.1024|
                          DCD      OSTmrWheelTbl
                  |L1.1028|
                          DCD      OSTmrTime
                  |L1.1032|
;;;960        } else {
;;;961            if (ptmr->OSTmrDly == 0) {
000408  6985              LDR      r5,[r0,#0x18]
00040a  b92d              CBNZ     r5,|L1.1048|
;;;962                ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
00040c  4ebd              LDR      r6,|L1.1796|
00040e  69c5              LDR      r5,[r0,#0x1c]
000410  6836              LDR      r6,[r6,#0]  ; OSTmrTime
000412  4435              ADD      r5,r5,r6
000414  6145              STR      r5,[r0,#0x14]
000416  e004              B        |L1.1058|
                  |L1.1048|
;;;963            } else {
;;;964                ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
000418  4eba              LDR      r6,|L1.1796|
00041a  6985              LDR      r5,[r0,#0x18]
00041c  6836              LDR      r6,[r6,#0]  ; OSTmrTime
00041e  4435              ADD      r5,r5,r6
000420  6145              STR      r5,[r0,#0x14]
                  |L1.1058|
;;;965            }
;;;966        }
;;;967        spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
000422  6945              LDR      r5,[r0,#0x14]
000424  f0050307          AND      r3,r5,#7
;;;968        pspoke = &OSTmrWheelTbl[spoke];
000428  4db7              LDR      r5,|L1.1800|
00042a  eb0501c3          ADD      r1,r5,r3,LSL #3
;;;969    
;;;970        if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
00042e  680d              LDR      r5,[r1,#0]
000430  b92d              CBNZ     r5,|L1.1086|
;;;971            pspoke->OSTmrFirst   = ptmr;
000432  6008              STR      r0,[r1,#0]
;;;972            ptmr->OSTmrNext      = (OS_TMR *)0;
000434  2500              MOVS     r5,#0
000436  60c5              STR      r5,[r0,#0xc]
;;;973            pspoke->OSTmrEntries = 1;
000438  2501              MOVS     r5,#1
00043a  808d              STRH     r5,[r1,#4]
00043c  e006              B        |L1.1100|
                  |L1.1086|
;;;974        } else {
;;;975            ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
00043e  680a              LDR      r2,[r1,#0]
;;;976            pspoke->OSTmrFirst   = ptmr;
000440  6008              STR      r0,[r1,#0]
;;;977            ptmr->OSTmrNext      = (void *)ptmr1;
000442  60c2              STR      r2,[r0,#0xc]
;;;978            ptmr1->OSTmrPrev     = (void *)ptmr;
000444  6110              STR      r0,[r2,#0x10]
;;;979            pspoke->OSTmrEntries++;
000446  888d              LDRH     r5,[r1,#4]
000448  1c6d              ADDS     r5,r5,#1
00044a  808d              STRH     r5,[r1,#4]
                  |L1.1100|
;;;980        }
;;;981        ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
00044c  2500              MOVS     r5,#0
00044e  6105              STR      r5,[r0,#0x10]
;;;982    }
000450  bd70              POP      {r4-r6,pc}
;;;983    #endif
                          ENDP

                  OSTmrStart PROC
;;;524    #if OS_TMR_EN > 0
;;;525    BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
000452  b570              PUSH     {r4-r6,lr}
;;;526                         INT8U    *perr)
;;;527    {
000454  4605              MOV      r5,r0
000456  460c              MOV      r4,r1
;;;528    #if OS_ARG_CHK_EN > 0
;;;529        if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
000458  b90c              CBNZ     r4,|L1.1118|
;;;530            return (OS_FALSE);
00045a  2000              MOVS     r0,#0
                  |L1.1116|
;;;531        }
;;;532        if (ptmr == (OS_TMR *)0) {
;;;533            *perr = OS_ERR_TMR_INVALID;
;;;534            return (OS_FALSE);
;;;535        }
;;;536    #endif
;;;537        if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
;;;538            *perr = OS_ERR_TMR_INVALID_TYPE;
;;;539            return (OS_FALSE);
;;;540        }
;;;541        if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
;;;542            *perr  = OS_ERR_TMR_ISR;
;;;543            return (OS_FALSE);
;;;544        }
;;;545        OSTmr_Lock();
;;;546        switch (ptmr->OSTmrState) {
;;;547            case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
;;;548                 OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
;;;549                 OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
;;;550                 OSTmr_Unlock();
;;;551                 *perr = OS_ERR_NONE;
;;;552                 return (OS_TRUE);
;;;553    
;;;554            case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
;;;555            case OS_TMR_STATE_COMPLETED:
;;;556                 OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
;;;557                 OSTmr_Unlock();
;;;558                 *perr = OS_ERR_NONE;
;;;559                 return (OS_TRUE);
;;;560    
;;;561            case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
;;;562                 OSTmr_Unlock();
;;;563                 *perr = OS_ERR_TMR_INACTIVE;
;;;564                 return (OS_FALSE);
;;;565    
;;;566            default:
;;;567                 OSTmr_Unlock();
;;;568                 *perr = OS_ERR_TMR_INVALID_STATE;
;;;569                 return (OS_FALSE);
;;;570        }
;;;571    }
00045c  bd70              POP      {r4-r6,pc}
                  |L1.1118|
00045e  b91d              CBNZ     r5,|L1.1128|
000460  208a              MOVS     r0,#0x8a              ;533
000462  7020              STRB     r0,[r4,#0]            ;533
000464  2000              MOVS     r0,#0                 ;534
000466  e7f9              B        |L1.1116|
                  |L1.1128|
000468  7828              LDRB     r0,[r5,#0]            ;537
00046a  2864              CMP      r0,#0x64              ;537
00046c  d003              BEQ      |L1.1142|
00046e  2089              MOVS     r0,#0x89              ;538
000470  7020              STRB     r0,[r4,#0]            ;538
000472  2000              MOVS     r0,#0                 ;539
000474  e7f2              B        |L1.1116|
                  |L1.1142|
000476  48a5              LDR      r0,|L1.1804|
000478  7800              LDRB     r0,[r0,#0]            ;541  ; OSIntNesting
00047a  2800              CMP      r0,#0                 ;541
00047c  dd03              BLE      |L1.1158|
00047e  208b              MOVS     r0,#0x8b              ;542
000480  7020              STRB     r0,[r4,#0]            ;542
000482  2000              MOVS     r0,#0                 ;543
000484  e7ea              B        |L1.1116|
                  |L1.1158|
000486  f7fffffe          BL       OSTmr_Lock
00048a  f8950031          LDRB     r0,[r5,#0x31]         ;546
00048e  b1e8              CBZ      r0,|L1.1228|
000490  2801              CMP      r0,#1                 ;546
000492  d010              BEQ      |L1.1206|
000494  2802              CMP      r0,#2                 ;546
000496  d00f              BEQ      |L1.1208|
000498  2803              CMP      r0,#3                 ;546
00049a  d11d              BNE      |L1.1240|
00049c  4628              MOV      r0,r5                 ;548
00049e  f7fffffe          BL       OSTmr_Unlink
0004a2  2100              MOVS     r1,#0                 ;549
0004a4  4628              MOV      r0,r5                 ;549
0004a6  f7fffffe          BL       OSTmr_Link
0004aa  f7fffffe          BL       OSTmr_Unlock
0004ae  2000              MOVS     r0,#0                 ;551
0004b0  7020              STRB     r0,[r4,#0]            ;551
0004b2  2001              MOVS     r0,#1                 ;552
0004b4  e7d2              B        |L1.1116|
                  |L1.1206|
0004b6  bf00              NOP                            ;555
                  |L1.1208|
0004b8  2100              MOVS     r1,#0                 ;556
0004ba  4628              MOV      r0,r5                 ;556
0004bc  f7fffffe          BL       OSTmr_Link
0004c0  f7fffffe          BL       OSTmr_Unlock
0004c4  2000              MOVS     r0,#0                 ;558
0004c6  7020              STRB     r0,[r4,#0]            ;558
0004c8  2001              MOVS     r0,#1                 ;559
0004ca  e7c7              B        |L1.1116|
                  |L1.1228|
0004cc  f7fffffe          BL       OSTmr_Unlock
0004d0  2087              MOVS     r0,#0x87              ;563
0004d2  7020              STRB     r0,[r4,#0]            ;563
0004d4  2000              MOVS     r0,#0                 ;564
0004d6  e7c1              B        |L1.1116|
                  |L1.1240|
0004d8  f7fffffe          BL       OSTmr_Unlock
0004dc  208d              MOVS     r0,#0x8d              ;568
0004de  7020              STRB     r0,[r4,#0]            ;568
0004e0  2000              MOVS     r0,#0                 ;569
0004e2  e7bb              B        |L1.1116|
;;;572    #endif
                          ENDP

                  OSTmrStop PROC
;;;611    #if OS_TMR_EN > 0
;;;612    BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
0004e4  e92d41f0          PUSH     {r4-r8,lr}
;;;613                        INT8U    opt,
;;;614                        void    *callback_arg,
;;;615                        INT8U   *perr)
;;;616    {
0004e8  4605              MOV      r5,r0
0004ea  460f              MOV      r7,r1
0004ec  4690              MOV      r8,r2
0004ee  461c              MOV      r4,r3
;;;617        OS_TMR_CALLBACK  pfnct;
;;;618    
;;;619    
;;;620    #if OS_ARG_CHK_EN > 0
;;;621        if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
0004f0  b914              CBNZ     r4,|L1.1272|
;;;622            return (OS_FALSE);
0004f2  2000              MOVS     r0,#0
                  |L1.1268|
;;;623        }
;;;624        if (ptmr == (OS_TMR *)0) {
;;;625            *perr = OS_ERR_TMR_INVALID;
;;;626            return (OS_FALSE);
;;;627        }
;;;628    #endif
;;;629        if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
;;;630            *perr = OS_ERR_TMR_INVALID_TYPE;
;;;631            return (OS_FALSE);
;;;632        }
;;;633        if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
;;;634            *perr  = OS_ERR_TMR_ISR;
;;;635            return (OS_FALSE);
;;;636        }
;;;637        OSTmr_Lock();
;;;638        switch (ptmr->OSTmrState) {
;;;639            case OS_TMR_STATE_RUNNING:
;;;640                 OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
;;;641                 *perr = OS_ERR_NONE;
;;;642                 switch (opt) {
;;;643                     case OS_TMR_OPT_CALLBACK:
;;;644                          pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
;;;645                          if (pfnct != (OS_TMR_CALLBACK)0) {
;;;646                              (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
;;;647                          } else {
;;;648                              *perr = OS_ERR_TMR_NO_CALLBACK;
;;;649                          }
;;;650                          break;
;;;651    
;;;652                     case OS_TMR_OPT_CALLBACK_ARG:
;;;653                          pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
;;;654                          if (pfnct != (OS_TMR_CALLBACK)0) {
;;;655                              (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
;;;656                          } else {
;;;657                              *perr = OS_ERR_TMR_NO_CALLBACK;
;;;658                          }
;;;659                          break;
;;;660    
;;;661                     case OS_TMR_OPT_NONE:
;;;662                          break;
;;;663    
;;;664                     default:
;;;665                         *perr = OS_ERR_TMR_INVALID_OPT;
;;;666                         break;
;;;667                 }
;;;668                 OSTmr_Unlock();
;;;669                 return (OS_TRUE);
;;;670    
;;;671            case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
;;;672            case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
;;;673                 OSTmr_Unlock();
;;;674                 *perr = OS_ERR_TMR_STOPPED;
;;;675                 return (OS_TRUE);
;;;676    
;;;677            case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
;;;678                 OSTmr_Unlock();
;;;679                 *perr = OS_ERR_TMR_INACTIVE;
;;;680                 return (OS_FALSE);
;;;681    
;;;682            default:
;;;683                 OSTmr_Unlock();
;;;684                 *perr = OS_ERR_TMR_INVALID_STATE;
;;;685                 return (OS_FALSE);
;;;686        }
;;;687    }
0004f4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1272|
0004f8  b91d              CBNZ     r5,|L1.1282|
0004fa  208a              MOVS     r0,#0x8a              ;625
0004fc  7020              STRB     r0,[r4,#0]            ;625
0004fe  2000              MOVS     r0,#0                 ;626
000500  e7f8              B        |L1.1268|
                  |L1.1282|
000502  7828              LDRB     r0,[r5,#0]            ;629
000504  2864              CMP      r0,#0x64              ;629
000506  d003              BEQ      |L1.1296|
000508  2089              MOVS     r0,#0x89              ;630
00050a  7020              STRB     r0,[r4,#0]            ;630
00050c  2000              MOVS     r0,#0                 ;631
00050e  e7f1              B        |L1.1268|
                  |L1.1296|
000510  487e              LDR      r0,|L1.1804|
000512  7800              LDRB     r0,[r0,#0]            ;633  ; OSIntNesting
000514  2800              CMP      r0,#0                 ;633
000516  dd03              BLE      |L1.1312|
000518  208b              MOVS     r0,#0x8b              ;634
00051a  7020              STRB     r0,[r4,#0]            ;634
00051c  2000              MOVS     r0,#0                 ;635
00051e  e7e9              B        |L1.1268|
                  |L1.1312|
000520  f7fffffe          BL       OSTmr_Lock
000524  f8950031          LDRB     r0,[r5,#0x31]         ;638
000528  b390              CBZ      r0,|L1.1424|
00052a  2801              CMP      r0,#1                 ;638
00052c  d02a              BEQ      |L1.1412|
00052e  2802              CMP      r0,#2                 ;638
000530  d027              BEQ      |L1.1410|
000532  2803              CMP      r0,#3                 ;638
000534  d133              BNE      |L1.1438|
000536  4628              MOV      r0,r5                 ;640
000538  f7fffffe          BL       OSTmr_Unlink
00053c  2000              MOVS     r0,#0                 ;641
00053e  7020              STRB     r0,[r4,#0]            ;641
000540  b1b7              CBZ      r7,|L1.1392|
000542  2f03              CMP      r7,#3                 ;642
000544  d002              BEQ      |L1.1356|
000546  2f04              CMP      r7,#4                 ;642
000548  d113              BNE      |L1.1394|
00054a  e008              B        |L1.1374|
                  |L1.1356|
00054c  686e              LDR      r6,[r5,#4]            ;644
00054e  b11e              CBZ      r6,|L1.1368|
000550  4628              MOV      r0,r5                 ;646
000552  68a9              LDR      r1,[r5,#8]            ;646
000554  47b0              BLX      r6                    ;646
000556  e001              B        |L1.1372|
                  |L1.1368|
000558  208f              MOVS     r0,#0x8f              ;648
00055a  7020              STRB     r0,[r4,#0]            ;648
                  |L1.1372|
00055c  e00c              B        |L1.1400|
                  |L1.1374|
00055e  686e              LDR      r6,[r5,#4]            ;653
000560  b11e              CBZ      r6,|L1.1386|
000562  4641              MOV      r1,r8                 ;655
000564  4628              MOV      r0,r5                 ;655
000566  47b0              BLX      r6                    ;655
000568  e001              B        |L1.1390|
                  |L1.1386|
00056a  208f              MOVS     r0,#0x8f              ;657
00056c  7020              STRB     r0,[r4,#0]            ;657
                  |L1.1390|
00056e  e003              B        |L1.1400|
                  |L1.1392|
000570  e002              B        |L1.1400|
                  |L1.1394|
000572  2084              MOVS     r0,#0x84              ;665
000574  7020              STRB     r0,[r4,#0]            ;665
000576  bf00              NOP                            ;666
                  |L1.1400|
000578  bf00              NOP                            ;650
00057a  f7fffffe          BL       OSTmr_Unlock
00057e  2001              MOVS     r0,#1                 ;669
000580  e7b8              B        |L1.1268|
                  |L1.1410|
000582  bf00              NOP                            ;672
                  |L1.1412|
000584  f7fffffe          BL       OSTmr_Unlock
000588  208e              MOVS     r0,#0x8e              ;674
00058a  7020              STRB     r0,[r4,#0]            ;674
00058c  2001              MOVS     r0,#1                 ;675
00058e  e7b1              B        |L1.1268|
                  |L1.1424|
000590  e7ff              B        |L1.1426|
                  |L1.1426|
000592  f7fffffe          BL       OSTmr_Unlock
000596  2087              MOVS     r0,#0x87              ;679
000598  7020              STRB     r0,[r4,#0]            ;679
00059a  2000              MOVS     r0,#0                 ;680
00059c  e7aa              B        |L1.1268|
                  |L1.1438|
00059e  f7fffffe          BL       OSTmr_Unlock
0005a2  208d              MOVS     r0,#0x8d              ;684
0005a4  7020              STRB     r0,[r4,#0]            ;684
0005a6  2000              MOVS     r0,#0                 ;685
0005a8  e7a4              B        |L1.1268|
;;;688    #endif
                          ENDP

                  OSTmrSignal PROC
;;;710    #if OS_TMR_EN > 0
;;;711    INT8U  OSTmrSignal (void)
0005aa  b510              PUSH     {r4,lr}
;;;712    {
;;;713        INT8U  err;
;;;714    
;;;715    
;;;716        err = OSSemPost(OSTmrSemSignal);
0005ac  4858              LDR      r0,|L1.1808|
0005ae  6800              LDR      r0,[r0,#0]  ; OSTmrSemSignal
0005b0  f7fffffe          BL       OSSemPost
0005b4  4604              MOV      r4,r0
;;;717        return (err);
0005b6  4620              MOV      r0,r4
;;;718    }
0005b8  bd10              POP      {r4,pc}
;;;719    #endif
                          ENDP

                  OSTmr_Task PROC
;;;1077   #if OS_TMR_EN > 0
;;;1078   static  void  OSTmr_Task (void *p_arg)
0005ba  b508              PUSH     {r3,lr}
;;;1079   {
;;;1080       INT8U            err;
;;;1081       OS_TMR          *ptmr;
;;;1082       OS_TMR          *ptmr_next;
;;;1083       OS_TMR_CALLBACK  pfnct;
;;;1084       OS_TMR_WHEEL    *pspoke;
;;;1085       INT16U           spoke;
;;;1086   
;;;1087   
;;;1088       (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
;;;1089       for (;;) {
0005bc  bf00              NOP      
                  |L1.1470|
;;;1090           OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
0005be  466a              MOV      r2,sp
0005c0  2100              MOVS     r1,#0
0005c2  4853              LDR      r0,|L1.1808|
0005c4  6800              LDR      r0,[r0,#0]  ; OSTmrSemSignal
0005c6  f7fffffe          BL       OSSemPend
;;;1091           OSTmr_Lock();
0005ca  f7fffffe          BL       OSTmr_Lock
;;;1092           OSTmrTime++;                                             /* Increment the current time                        */
0005ce  484d              LDR      r0,|L1.1796|
0005d0  6800              LDR      r0,[r0,#0]  ; OSTmrTime
0005d2  1c40              ADDS     r0,r0,#1
0005d4  494b              LDR      r1,|L1.1796|
0005d6  6008              STR      r0,[r1,#0]  ; OSTmrTime
;;;1093           spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
0005d8  4608              MOV      r0,r1
0005da  6800              LDR      r0,[r0,#0]  ; OSTmrTime
0005dc  f0000607          AND      r6,r0,#7
;;;1094           pspoke = &OSTmrWheelTbl[spoke];
0005e0  4849              LDR      r0,|L1.1800|
0005e2  eb0008c6          ADD      r8,r0,r6,LSL #3
;;;1095           ptmr   = pspoke->OSTmrFirst;
0005e6  f8d84000          LDR      r4,[r8,#0]
;;;1096           while (ptmr != (OS_TMR *)0) {
0005ea  e01a              B        |L1.1570|
                  |L1.1516|
;;;1097               ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
0005ec  68e7              LDR      r7,[r4,#0xc]
;;;1098                                                                    /* ... timer could get unlinked from the wheel.      */
;;;1099               if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
0005ee  4945              LDR      r1,|L1.1796|
0005f0  6960              LDR      r0,[r4,#0x14]
0005f2  6809              LDR      r1,[r1,#0]  ; OSTmrTime
0005f4  4288              CMP      r0,r1
0005f6  d113              BNE      |L1.1568|
;;;1100                   pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
0005f8  6865              LDR      r5,[r4,#4]
;;;1101                   if (pfnct != (OS_TMR_CALLBACK)0) {
0005fa  b115              CBZ      r5,|L1.1538|
;;;1102                       (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
0005fc  4620              MOV      r0,r4
0005fe  68a1              LDR      r1,[r4,#8]
000600  47a8              BLX      r5
                  |L1.1538|
;;;1103                   }
;;;1104                   OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
000602  4620              MOV      r0,r4
000604  f7fffffe          BL       OSTmr_Unlink
;;;1105                   if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
000608  f8940030          LDRB     r0,[r4,#0x30]
00060c  2802              CMP      r0,#2
00060e  d104              BNE      |L1.1562|
;;;1106                       OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
000610  2101              MOVS     r1,#1
000612  4620              MOV      r0,r4
000614  f7fffffe          BL       OSTmr_Link
000618  e002              B        |L1.1568|
                  |L1.1562|
;;;1107                   } else {
;;;1108                       ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
00061a  2002              MOVS     r0,#2
00061c  f8840031          STRB     r0,[r4,#0x31]
                  |L1.1568|
;;;1109                   }
;;;1110               }
;;;1111               ptmr = ptmr_next;
000620  463c              MOV      r4,r7
                  |L1.1570|
000622  2c00              CMP      r4,#0                 ;1096
000624  d1e2              BNE      |L1.1516|
;;;1112           }
;;;1113           OSTmr_Unlock();
000626  f7fffffe          BL       OSTmr_Unlock
00062a  e7c8              B        |L1.1470|
;;;1114       }
;;;1115   }
;;;1116   #endif
                          ENDP

                  OSTmr_InitTask PROC
;;;877    #if OS_TMR_EN > 0
;;;878    static  void  OSTmr_InitTask (void)
00062c  b500              PUSH     {lr}
;;;879    {
00062e  b087              SUB      sp,sp,#0x1c
;;;880    #if OS_TASK_NAME_SIZE > 6
;;;881        INT8U  err;
;;;882    #endif
;;;883    
;;;884    
;;;885    #if OS_TASK_CREATE_EXT_EN > 0
;;;886        #if OS_STK_GROWTH == 1
;;;887        (void)OSTaskCreateExt(OSTmr_Task,
000630  2303              MOVS     r3,#3
000632  2200              MOVS     r2,#0
000634  2180              MOVS     r1,#0x80
000636  4837              LDR      r0,|L1.1812|
000638  e9cd2303          STRD     r2,r3,[sp,#0xc]
00063c  e9cd0101          STRD     r0,r1,[sp,#4]
000640  f64f73fd          MOV      r3,#0xfffd
000644  9300              STR      r3,[sp,#0]
000646  231d              MOVS     r3,#0x1d
000648  f50072fe          ADD      r2,r0,#0x1fc
00064c  2100              MOVS     r1,#0
00064e  4832              LDR      r0,|L1.1816|
000650  f7fffffe          BL       OSTaskCreateExt
;;;888                              (void *)0,                                       /* No arguments passed to OSTmrTask()      */
;;;889                              &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1],         /* Set Top-Of-Stack                        */
;;;890                              OS_TASK_TMR_PRIO,
;;;891                              OS_TASK_TMR_ID,
;;;892                              &OSTmrTaskStk[0],                                /* Set Bottom-Of-Stack                     */
;;;893                              OS_TASK_TMR_STK_SIZE,
;;;894                              (void *)0,                                       /* No TCB extension                        */
;;;895                              OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
;;;896        #else
;;;897        (void)OSTaskCreateExt(OSTmr_Task,
;;;898                              (void *)0,                                       /* No arguments passed to OSTmrTask()      */
;;;899                              &OSTmrTaskStk[0],                                /* Set Top-Of-Stack                        */
;;;900                              OS_TASK_TMR_PRIO,
;;;901                              OS_TASK_TMR_ID,
;;;902                              &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1],         /* Set Bottom-Of-Stack                     */
;;;903                              OS_TASK_TMR_STK_SIZE,
;;;904                              (void *)0,                                       /* No TCB extension                        */
;;;905                              OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
;;;906        #endif
;;;907    #else
;;;908        #if OS_STK_GROWTH == 1
;;;909        (void)OSTaskCreate(OSTmr_Task,
;;;910                           (void *)0,
;;;911                           &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1],
;;;912                           OS_TASK_TMR_PRIO);
;;;913        #else
;;;914        (void)OSTaskCreate(OSTmr_Task,
;;;915                           (void *)0,
;;;916                           &OSTmrTaskStk[0],
;;;917                           OS_TASK_TMR_PRIO);
;;;918        #endif
;;;919    #endif
;;;920    
;;;921    #if OS_TASK_NAME_SIZE > 12
;;;922        OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
000654  aa06              ADD      r2,sp,#0x18
000656  a131              ADR      r1,|L1.1820|
000658  201d              MOVS     r0,#0x1d
00065a  f7fffffe          BL       OSTaskNameSet
;;;923    #else
;;;924    #if OS_TASK_NAME_SIZE > 6
;;;925        OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
;;;926    #endif
;;;927    #endif
;;;928    }
00065e  b007              ADD      sp,sp,#0x1c
000660  bd00              POP      {pc}
;;;929    #endif
                          ENDP

                  OSTmr_Init PROC
;;;803    #if OS_TMR_EN > 0
;;;804    void  OSTmr_Init (void)
000662  b5f8              PUSH     {r3-r7,lr}
;;;805    {
;;;806    #if OS_EVENT_NAME_SIZE > 10
;;;807        INT8U    err;
;;;808    #endif
;;;809        INT16U   i;
;;;810        OS_TMR  *ptmr1;
;;;811        OS_TMR  *ptmr2;
;;;812    
;;;813    
;;;814        OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
000664  f44f7150          MOV      r1,#0x340
000668  4830              LDR      r0,|L1.1836|
00066a  f7fffffe          BL       OS_MemClr
;;;815        OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
00066e  2140              MOVS     r1,#0x40
000670  4825              LDR      r0,|L1.1800|
000672  f7fffffe          BL       OS_MemClr
;;;816    
;;;817        ptmr1 = &OSTmrTbl[0];
000676  4c2d              LDR      r4,|L1.1836|
;;;818        ptmr2 = &OSTmrTbl[1];
000678  f1040634          ADD      r6,r4,#0x34
;;;819        for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
00067c  2500              MOVS     r5,#0
00067e  e00f              B        |L1.1696|
                  |L1.1664|
;;;820            ptmr1->OSTmrType    = OS_TMR_TYPE;
000680  2064              MOVS     r0,#0x64
000682  7020              STRB     r0,[r4,#0]
;;;821            ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
000684  2000              MOVS     r0,#0
000686  f8840031          STRB     r0,[r4,#0x31]
;;;822            ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
00068a  60e6              STR      r6,[r4,#0xc]
;;;823    #if OS_TMR_CFG_NAME_SIZE > 1
;;;824            ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
00068c  203f              MOVS     r0,#0x3f
00068e  f8840020          STRB     r0,[r4,#0x20]
;;;825            ptmr1->OSTmrName[1] = OS_ASCII_NUL;
000692  2100              MOVS     r1,#0
000694  2021              MOVS     r0,#0x21
000696  5501              STRB     r1,[r0,r4]
;;;826    #endif
;;;827            ptmr1++;
000698  3434              ADDS     r4,r4,#0x34
;;;828            ptmr2++;
00069a  3634              ADDS     r6,r6,#0x34
00069c  1c68              ADDS     r0,r5,#1              ;819
00069e  b285              UXTH     r5,r0                 ;819
                  |L1.1696|
0006a0  2d0f              CMP      r5,#0xf               ;819
0006a2  dbed              BLT      |L1.1664|
;;;829        }
;;;830        ptmr1->OSTmrType    = OS_TMR_TYPE;
0006a4  2064              MOVS     r0,#0x64
0006a6  7020              STRB     r0,[r4,#0]
;;;831        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
0006a8  2000              MOVS     r0,#0
0006aa  f8840031          STRB     r0,[r4,#0x31]
;;;832        ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
0006ae  60e0              STR      r0,[r4,#0xc]
;;;833    #if OS_TMR_CFG_NAME_SIZE > 1
;;;834        ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
0006b0  203f              MOVS     r0,#0x3f
0006b2  f8840020          STRB     r0,[r4,#0x20]
;;;835        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
0006b6  2100              MOVS     r1,#0
0006b8  2021              MOVS     r0,#0x21
0006ba  5501              STRB     r1,[r0,r4]
;;;836    #endif
;;;837        OSTmrTime           = 0;
0006bc  2000              MOVS     r0,#0
0006be  4911              LDR      r1,|L1.1796|
0006c0  6008              STR      r0,[r1,#0]  ; OSTmrTime
;;;838        OSTmrUsed           = 0;
0006c2  491b              LDR      r1,|L1.1840|
0006c4  8008              STRH     r0,[r1,#0]
;;;839        OSTmrFree           = OS_TMR_CFG_MAX;
0006c6  2010              MOVS     r0,#0x10
0006c8  491a              LDR      r1,|L1.1844|
0006ca  8008              STRH     r0,[r1,#0]
;;;840        OSTmrFreeList       = &OSTmrTbl[0];
0006cc  4817              LDR      r0,|L1.1836|
0006ce  491a              LDR      r1,|L1.1848|
0006d0  6008              STR      r0,[r1,#0]  ; OSTmrFreeList
;;;841        OSTmrSem            = OSSemCreate(1);
0006d2  2001              MOVS     r0,#1
0006d4  f7fffffe          BL       OSSemCreate
0006d8  4918              LDR      r1,|L1.1852|
0006da  6008              STR      r0,[r1,#0]  ; OSTmrSem
;;;842        OSTmrSemSignal      = OSSemCreate(0);
0006dc  2000              MOVS     r0,#0
0006de  f7fffffe          BL       OSSemCreate
0006e2  490b              LDR      r1,|L1.1808|
0006e4  6008              STR      r0,[r1,#0]  ; OSTmrSemSignal
;;;843    
;;;844    #if OS_EVENT_NAME_SIZE > 18
;;;845        OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
;;;846    #else
;;;847    #if OS_EVENT_NAME_SIZE > 10
;;;848        OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
0006e6  466a              MOV      r2,sp
0006e8  a115              ADR      r1,|L1.1856|
0006ea  4814              LDR      r0,|L1.1852|
0006ec  6800              LDR      r0,[r0,#0]  ; OSTmrSem
0006ee  f7fffffe          BL       OSEventNameSet
;;;849    #endif
;;;850    #endif
;;;851    
;;;852    #if OS_EVENT_NAME_SIZE > 18
;;;853        OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
;;;854    #else
;;;855    #if OS_EVENT_NAME_SIZE > 10
;;;856        OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
0006f2  466a              MOV      r2,sp
0006f4  a115              ADR      r1,|L1.1868|
0006f6  4806              LDR      r0,|L1.1808|
0006f8  6800              LDR      r0,[r0,#0]  ; OSTmrSemSignal
0006fa  f7fffffe          BL       OSEventNameSet
;;;857    #endif
;;;858    #endif
;;;859    
;;;860        OSTmr_InitTask();
0006fe  f7fffffe          BL       OSTmr_InitTask
;;;861    }
000702  bdf8              POP      {r3-r7,pc}
;;;862    #endif
                          ENDP

                  |L1.1796|
                          DCD      OSTmrTime
                  |L1.1800|
                          DCD      OSTmrWheelTbl
                  |L1.1804|
                          DCD      OSIntNesting
                  |L1.1808|
                          DCD      OSTmrSemSignal
                  |L1.1812|
                          DCD      OSTmrTaskStk
                  |L1.1816|
                          DCD      OSTmr_Task
                  |L1.1820|
00071c  75432f4f          DCB      "uC/OS-II Tmr",0
000720  532d4949
000724  20546d72
000728  00      
000729  00                DCB      0
00072a  00                DCB      0
00072b  00                DCB      0
                  |L1.1836|
                          DCD      OSTmrTbl
                  |L1.1840|
                          DCD      OSTmrUsed
                  |L1.1844|
                          DCD      OSTmrFree
                  |L1.1848|
                          DCD      OSTmrFreeList
                  |L1.1852|
                          DCD      OSTmrSem
                  |L1.1856|
000740  4f532d54          DCB      "OS-TmrLock",0
000744  6d724c6f
000748  636b00  
00074b  00                DCB      0
                  |L1.1868|
00074c  4f532d54          DCB      "OS-TmrSig",0
000750  6d725369
000754  6700    
000756  00                DCB      0
000757  00                DCB      0
