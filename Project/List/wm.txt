; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Obj\wm.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\Obj\wm.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\BaseDrive -I..\Ucosii -I..\Ucosii\Port -I..\Ucosii\Src -I..\Ucosii\Include -I..\Ucgui -I..\Ucgui\Config -I..\Ucgui\GUI_X -I..\Ucgui\GUI -I..\Ucgui\GUI\ConvertColor -I..\Ucgui\GUI\ConvertMono -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\LCDDriver -I..\Ucgui\GUI\MultiLayer -I..\Ucgui\GUI\Widget -I..\Ucgui\GUI\WM -I..\ExternalDrive\Lcd -I..\ExternalDrive\Touch -I..\Panel -I"D:\Program files\Keil\ARM\RV31\Inc" -I"D:\Program files\Keil\ARM\CMSIS\Include" -I"D:\Program files\Keil\ARM\Inc\ST\STM32F10x" -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\wm.crf ..\Ucgui\GUI\WM\WM.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _CheckCriticalHandles PROC
;;;99     */
;;;100    static void _CheckCriticalHandles(WM_HWIN hWin) {
000000  4601              MOV      r1,r0
;;;101      WM_CRITICAL_HANDLE * pCH;
;;;102      for (pCH = WM__pFirstCriticalHandle; pCH; pCH = pCH->pNext) {
000002  4af7              LDR      r2,|L1.992|
000004  6810              LDR      r0,[r2,#0]  ; WM__pFirstCriticalHandle
000006  e006              B        |L1.22|
                  |L1.8|
;;;103        if (pCH->hWin == hWin) {
000008  f9b02004          LDRSH    r2,[r0,#4]
00000c  428a              CMP      r2,r1
00000e  d101              BNE      |L1.20|
;;;104          pCH->hWin = 0;
000010  2200              MOVS     r2,#0
000012  8082              STRH     r2,[r0,#4]
                  |L1.20|
000014  6800              LDR      r0,[r0,#0]            ;102
                  |L1.22|
000016  2800              CMP      r0,#0                 ;102
000018  d1f6              BNE      |L1.8|
;;;105        }
;;;106      }
;;;107    }
00001a  4770              BX       lr
;;;108    
                          ENDP

                  _DesktopHandle2Index PROC
;;;119    */
;;;120    static int _DesktopHandle2Index(WM_HWIN hDesktop) {
00001c  4601              MOV      r1,r0
;;;121    #if GUI_NUM_LAYERS > 1
;;;122      int i;
;;;123      for (i = 0; i < GUI_NUM_LAYERS; i++) {
;;;124        if (hDesktop == WM__ahDesktopWin[i]) {
;;;125          return i;
;;;126        }
;;;127      }
;;;128    #else
;;;129      if (hDesktop == WM__ahDesktopWin[0]) {
00001e  48f1              LDR      r0,|L1.996|
000020  f9b00000          LDRSH    r0,[r0,#0]  ; WM__ahDesktopWin
000024  4288              CMP      r0,r1
000026  d101              BNE      |L1.44|
;;;130        return 0;
000028  2000              MOVS     r0,#0
                  |L1.42|
;;;131      }
;;;132    #endif
;;;133      return -1;
;;;134    }
00002a  4770              BX       lr
                  |L1.44|
00002c  f04f30ff          MOV      r0,#0xffffffff        ;133
000030  e7fb              B        |L1.42|
;;;135    
                          ENDP

                  WM__RectIsNZ PROC
;;;548    */
;;;549    int WM__RectIsNZ(const GUI_RECT* pr) {
000032  4601              MOV      r1,r0
;;;550      if (pr->x0 > pr->x1)
000034  f9b10000          LDRSH    r0,[r1,#0]
000038  f9b12004          LDRSH    r2,[r1,#4]
00003c  4290              CMP      r0,r2
00003e  dd01              BLE      |L1.68|
;;;551        return 0;
000040  2000              MOVS     r0,#0
                  |L1.66|
;;;552      if (pr->y0 > pr->y1)
;;;553        return 0;
;;;554      return 1;
;;;555    }
000042  4770              BX       lr
                  |L1.68|
000044  f9b10002          LDRSH    r0,[r1,#2]            ;552
000048  f9b12006          LDRSH    r2,[r1,#6]            ;552
00004c  4290              CMP      r0,r2                 ;552
00004e  dd01              BLE      |L1.84|
000050  2000              MOVS     r0,#0                 ;553
000052  e7f6              B        |L1.66|
                  |L1.84|
000054  2001              MOVS     r0,#1                 ;554
000056  e7f4              B        |L1.66|
;;;556    
                          ENDP

                  _Invalidate1Abs PROC
;;;141    */
;;;142    static void _Invalidate1Abs(WM_HWIN hWin, const GUI_RECT*pRect) {
000058  e92d41fc          PUSH     {r2-r8,lr}
00005c  4607              MOV      r7,r0
00005e  460d              MOV      r5,r1
;;;143      GUI_RECT r;
;;;144      WM_Obj* pWin;
;;;145      int Status;
;;;146      pWin = WM_H2P(hWin);
000060  4638              MOV      r0,r7
000062  f7fffffe          BL       GUI_ALLOC_h2p
000066  4604              MOV      r4,r0
;;;147      Status = pWin->Status;
000068  8ba6              LDRH     r6,[r4,#0x1c]
;;;148      if ((Status & WM_SF_ISVIS) == 0) {
00006a  f0160f02          TST      r6,#2
00006e  d101              BNE      |L1.116|
                  |L1.112|
;;;149        return;   /* Window is not visible... we are done */
;;;150      }
;;;151      if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
;;;152        return;   /* Window is transparent; transparency may change... we are done, since background will be invalidated */
;;;153      }
;;;154      if (WM__RectIsNZ(pRect) == 0) {
;;;155        return;   /* Nothing to do ... */
;;;156      }
;;;157      /* Calc affected area */
;;;158      GUI__IntersectRects(&r, pRect, &pWin->Rect);
;;;159      if (WM__RectIsNZ(&r)) {
;;;160        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;161          WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
;;;162        #endif
;;;163    
;;;164        if (pWin->Status & WM_SF_INVALID) {
;;;165          GUI_MergeRect(&pWin->InvalidRect, &pWin->InvalidRect, &r);
;;;166        } else {
;;;167          pWin->InvalidRect = r;
;;;168          pWin->Status |= WM_SF_INVALID;
;;;169          WM__NumInvalidWindows++;
;;;170          /* Optional code: Call external routine to notify that drawing is required */
;;;171          #ifdef GUI_X_REDRAW
;;;172          {
;;;173            GUI_RECT r;
;;;174            r = pWin->Rect;
;;;175            if (WM__ClipAtParentBorders(&r,  hWin)) {
;;;176              GUI_X_REDRAW(); /* Call hook function to signal an invalidation */
;;;177            }
;;;178          }
;;;179          #endif
;;;180          GUI_X_SIGNAL_EVENT();
;;;181        }
;;;182        /* Debug code: shows invalid areas */
;;;183        #if (WM_SUPPORT_DIAG)
;;;184          if (WM__pfShowInvalid) {
;;;185            (WM__pfShowInvalid)(hWin);
;;;186          }
;;;187        #endif
;;;188      }
;;;189    }
000070  e8bd81fc          POP      {r2-r8,pc}
                  |L1.116|
000074  f6400001          MOV      r0,#0x801             ;151
000078  4030              ANDS     r0,r0,r6              ;151
00007a  2801              CMP      r0,#1                 ;151
00007c  d100              BNE      |L1.128|
00007e  e7f7              B        |L1.112|
                  |L1.128|
000080  4628              MOV      r0,r5                 ;154
000082  f7fffffe          BL       WM__RectIsNZ
000086  b900              CBNZ     r0,|L1.138|
000088  e7f2              B        |L1.112|
                  |L1.138|
00008a  4622              MOV      r2,r4                 ;158
00008c  4629              MOV      r1,r5                 ;158
00008e  4668              MOV      r0,sp                 ;158
000090  f7fffffe          BL       GUI__IntersectRects
000094  4668              MOV      r0,sp                 ;159
000096  f7fffffe          BL       WM__RectIsNZ
00009a  b1b8              CBZ      r0,|L1.204|
00009c  8ba0              LDRH     r0,[r4,#0x1c]         ;164
00009e  f0100f20          TST      r0,#0x20              ;164
0000a2  d006              BEQ      |L1.178|
0000a4  466a              MOV      r2,sp                 ;165
0000a6  f1040108          ADD      r1,r4,#8              ;165
0000aa  4608              MOV      r0,r1                 ;165
0000ac  f7fffffe          BL       GUI_MergeRect
0000b0  e00c              B        |L1.204|
                  |L1.178|
0000b2  9800              LDR      r0,[sp,#0]            ;167
0000b4  60a0              STR      r0,[r4,#8]            ;167
0000b6  9801              LDR      r0,[sp,#4]            ;167
0000b8  60e0              STR      r0,[r4,#0xc]          ;167
0000ba  8ba0              LDRH     r0,[r4,#0x1c]         ;168
0000bc  f0400020          ORR      r0,r0,#0x20           ;168
0000c0  83a0              STRH     r0,[r4,#0x1c]         ;168
0000c2  48c9              LDR      r0,|L1.1000|
0000c4  8800              LDRH     r0,[r0,#0]            ;169  ; WM__NumInvalidWindows
0000c6  1c40              ADDS     r0,r0,#1              ;169
0000c8  49c7              LDR      r1,|L1.1000|
0000ca  8008              STRH     r0,[r1,#0]            ;169
                  |L1.204|
0000cc  bf00              NOP      
0000ce  e7cf              B        |L1.112|
;;;190    
                          ENDP

                  ResetNextDrawWin PROC
;;;210    */
;;;211    static void ResetNextDrawWin(void) {
0000d0  2000              MOVS     r0,#0
;;;212      NextDrawWin = WM_HWIN_NULL;
0000d2  49c6              LDR      r1,|L1.1004|
0000d4  8008              STRH     r0,[r1,#0]
;;;213    }
0000d6  4770              BX       lr
;;;214    
                          ENDP

                  _GethDrawWin PROC
;;;223    */
;;;224    static WM_HWIN _GethDrawWin(void) {
0000d8  49c5              LDR      r1,|L1.1008|
;;;225      WM_HWIN h;
;;;226      #if WM_SUPPORT_TRANSPARENCY
;;;227        if (WM__hATransWindow) {
0000da  8809              LDRH     r1,[r1,#0]  ; WM__hATransWindow
0000dc  b119              CBZ      r1,|L1.230|
;;;228          h = WM__hATransWindow;
0000de  49c4              LDR      r1,|L1.1008|
0000e0  f9b10000          LDRSH    r0,[r1,#0]  ; WM__hATransWindow
0000e4  e002              B        |L1.236|
                  |L1.230|
;;;229        } else
;;;230      #endif
;;;231      {
;;;232        h = GUI_Context.hAWin;
0000e6  49c3              LDR      r1,|L1.1012|
0000e8  f9b1003c          LDRSH    r0,[r1,#0x3c]  ; GUI_Context
                  |L1.236|
;;;233      }
;;;234      return h;
;;;235    }
0000ec  4770              BX       lr
;;;236    
                          ENDP

                  WM__Client2Screen PROC
;;;476    */
;;;477    void WM__Client2Screen(const WM_Obj* pWin, GUI_RECT *pRect) {
0000ee  b570              PUSH     {r4-r6,lr}
0000f0  4604              MOV      r4,r0
0000f2  460d              MOV      r5,r1
;;;478      GUI_MoveRect(pRect, pWin->Rect.x0, pWin->Rect.y0);
0000f4  f9b42002          LDRSH    r2,[r4,#2]
0000f8  f9b41000          LDRSH    r1,[r4,#0]
0000fc  4628              MOV      r0,r5
0000fe  f7fffffe          BL       GUI_MoveRect
;;;479    }
000102  bd70              POP      {r4-r6,pc}
;;;480    
                          ENDP

                  _SetClipRectUserIntersect PROC
;;;244    */
;;;245    static void _SetClipRectUserIntersect(const GUI_RECT* prSrc) {
000104  b57c              PUSH     {r2-r6,lr}
000106  4604              MOV      r4,r0
;;;246      if (GUI_Context.WM__pUserClipRect == NULL) {
000108  48ba              LDR      r0,|L1.1012|
00010a  6b80              LDR      r0,[r0,#0x38]  ; GUI_Context
00010c  b918              CBNZ     r0,|L1.278|
;;;247        LCD_SetClipRectEx(prSrc);
00010e  4620              MOV      r0,r4
000110  f7fffffe          BL       LCD_SetClipRectEx
000114  e016              B        |L1.324|
                  |L1.278|
;;;248      } else {
;;;249        GUI_RECT r;
;;;250        r = *GUI_Context.WM__pUserClipRect;             
000116  48b7              LDR      r0,|L1.1012|
000118  6b80              LDR      r0,[r0,#0x38]  ; GUI_Context
00011a  6801              LDR      r1,[r0,#0]
00011c  9100              STR      r1,[sp,#0]
00011e  6840              LDR      r0,[r0,#4]
000120  9001              STR      r0,[sp,#4]
;;;251        WM__Client2Screen(WM_H2P(_GethDrawWin()), &r);     /* Convert User ClipRect into screen coordinates */
000122  f7fffffe          BL       _GethDrawWin
000126  4606              MOV      r6,r0
000128  f7fffffe          BL       GUI_ALLOC_h2p
00012c  4605              MOV      r5,r0
00012e  4669              MOV      r1,sp
000130  f7fffffe          BL       WM__Client2Screen
;;;252        /* Set intersection as clip rect */    
;;;253        GUI__IntersectRect(&r, prSrc);
000134  4621              MOV      r1,r4
000136  4668              MOV      r0,sp
000138  f7fffffe          BL       GUI__IntersectRect
;;;254        LCD_SetClipRectEx(&r);
00013c  4668              MOV      r0,sp
00013e  f7fffffe          BL       LCD_SetClipRectEx
;;;255      }
000142  bf00              NOP      
                  |L1.324|
;;;256    }
000144  bd7c              POP      {r2-r6,pc}
;;;257    
                          ENDP

                  WM__ClipAtParentBorders PROC
;;;287    */
;;;288    int WM__ClipAtParentBorders(GUI_RECT* pRect, WM_HWIN hWin) {
000146  b570              PUSH     {r4-r6,lr}
000148  4606              MOV      r6,r0
00014a  460d              MOV      r5,r1
;;;289      WM_Obj* pWin;
;;;290    
;;;291      /* Iterate up the window hierarchy.
;;;292         If the window is invisible, we are done.
;;;293         Clip at parent boarders.
;;;294         We are done with iterating if hWin has no parent.
;;;295      */
;;;296      do {
00014c  bf00              NOP      
                  |L1.334|
;;;297        pWin = WM_H2P(hWin);
00014e  4628              MOV      r0,r5
000150  f7fffffe          BL       GUI_ALLOC_h2p
000154  4604              MOV      r4,r0
;;;298        if ((pWin->Status & WM_SF_ISVIS) == 0) {
000156  8ba0              LDRH     r0,[r4,#0x1c]
000158  f0100f02          TST      r0,#2
00015c  d101              BNE      |L1.354|
;;;299          return 0;                     /* Invisible */
00015e  2000              MOVS     r0,#0
                  |L1.352|
;;;300        }
;;;301        GUI__IntersectRect(pRect, &pWin->Rect);  /* And clip on borders */
;;;302        if (pWin->hParent == 0) {
;;;303          break;   /* hWin is now the top level window which has no parent */
;;;304        }
;;;305        hWin = pWin->hParent;                    /* Go one level up (parent)*/
;;;306      } while (1);                               /* Only way out is in the loop. Required for efficiency, no bug, even though some compilers may complain. */
;;;307      
;;;308      /* Now check if the top level window is a desktop window. If it is not,
;;;309        then the window is not visible.
;;;310      */
;;;311      if (_DesktopHandle2Index(hWin) < 0) {
;;;312        return 0;           /* No desktop - (unattached) - Nothing to draw */
;;;313      }
;;;314      return 1;               /* Something may be visible */
;;;315    }
000160  bd70              POP      {r4-r6,pc}
                  |L1.354|
000162  4621              MOV      r1,r4                 ;301
000164  4630              MOV      r0,r6                 ;301
000166  f7fffffe          BL       GUI__IntersectRect
00016a  8ae0              LDRH     r0,[r4,#0x16]         ;302
00016c  b900              CBNZ     r0,|L1.368|
00016e  e002              B        |L1.374|
                  |L1.368|
000170  f9b45016          LDRSH    r5,[r4,#0x16]         ;305
000174  e7eb              B        |L1.334|
                  |L1.374|
000176  bf00              NOP                            ;303
000178  4628              MOV      r0,r5                 ;311
00017a  f7fffffe          BL       _DesktopHandle2Index
00017e  2800              CMP      r0,#0                 ;311
000180  da01              BGE      |L1.390|
000182  2000              MOVS     r0,#0                 ;312
000184  e7ec              B        |L1.352|
                  |L1.390|
000186  2001              MOVS     r0,#1                 ;314
000188  e7ea              B        |L1.352|
;;;316    
                          ENDP

                  WM__ActivateClipRect PROC
;;;320    */
;;;321    void  WM__ActivateClipRect(void) {
00018a  b51c              PUSH     {r2-r4,lr}
;;;322      if (WM_IsActive) {
00018c  489a              LDR      r0,|L1.1016|
00018e  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
000190  b118              CBZ      r0,|L1.410|
;;;323        _SetClipRectUserIntersect(&_ClipContext.CurRect);
000192  489a              LDR      r0,|L1.1020|
000194  f7fffffe          BL       _SetClipRectUserIntersect
000198  e016              B        |L1.456|
                  |L1.410|
;;;324      } else {    /* Window manager disabled, typically because meory device is active */
;;;325        GUI_RECT r;
;;;326        WM_Obj *pAWin;
;;;327        pAWin = WM_H2P(GUI_Context.hAWin);
00019a  4996              LDR      r1,|L1.1012|
00019c  f9b1003c          LDRSH    r0,[r1,#0x3c]  ; GUI_Context
0001a0  f7fffffe          BL       GUI_ALLOC_h2p
0001a4  4604              MOV      r4,r0
;;;328        r = pAWin->Rect;
0001a6  e9d40100          LDRD     r0,r1,[r4,#0]
0001aa  e9cd0100          STRD     r0,r1,[sp,#0]
;;;329        #if WM_SUPPORT_TRANSPARENCY
;;;330          if (WM__hATransWindow) {
0001ae  4890              LDR      r0,|L1.1008|
0001b0  8800              LDRH     r0,[r0,#0]  ; WM__hATransWindow
0001b2  b128              CBZ      r0,|L1.448|
;;;331            WM__ClipAtParentBorders(&r, WM__hATransWindow);
0001b4  488e              LDR      r0,|L1.1008|
0001b6  f9b01000          LDRSH    r1,[r0,#0]  ; WM__hATransWindow
0001ba  4668              MOV      r0,sp
0001bc  f7fffffe          BL       WM__ClipAtParentBorders
                  |L1.448|
;;;332          }
;;;333        #endif
;;;334        /* Take UserClipRect into account */
;;;335        _SetClipRectUserIntersect(&r);
0001c0  4668              MOV      r0,sp
0001c2  f7fffffe          BL       _SetClipRectUserIntersect
;;;336      }
0001c6  bf00              NOP      
                  |L1.456|
;;;337    }
0001c8  bd1c              POP      {r2-r4,pc}
;;;338    
                          ENDP

                  WM__InsertWindowIntoList PROC
;;;350    */
;;;351    void WM__InsertWindowIntoList(WM_HWIN hWin, WM_HWIN hParent) {
0001ca  e92d4ff8          PUSH     {r3-r11,lr}
0001ce  4606              MOV      r6,r0
0001d0  4688              MOV      r8,r1
;;;352      int OnTop;
;;;353      WM_HWIN hi;
;;;354      WM_Obj * pWin;
;;;355      WM_Obj * pParent;
;;;356      WM_Obj * pi;
;;;357    
;;;358      if (hParent) {
0001d2  f1b80f00          CMP      r8,#0
0001d6  d03f              BEQ      |L1.600|
;;;359        pWin = WM_H2P(hWin);
0001d8  4630              MOV      r0,r6
0001da  f7fffffe          BL       GUI_ALLOC_h2p
0001de  4604              MOV      r4,r0
;;;360        pWin->hNext = 0;
0001e0  2000              MOVS     r0,#0
0001e2  8360              STRH     r0,[r4,#0x1a]
;;;361        pWin->hParent = hParent;
0001e4  f8a48016          STRH     r8,[r4,#0x16]
;;;362        pParent = WM_H2P(hParent);
0001e8  4640              MOV      r0,r8
0001ea  f7fffffe          BL       GUI_ALLOC_h2p
0001ee  4607              MOV      r7,r0
;;;363        OnTop   = pWin->Status & WM_CF_STAYONTOP;
0001f0  8ba0              LDRH     r0,[r4,#0x1c]
0001f2  f0000b08          AND      r11,r0,#8
;;;364        hi = pParent->hFirstChild;
0001f6  f9b79018          LDRSH    r9,[r7,#0x18]
;;;365        /* Put it at beginning of the list if there is no child */
;;;366        if (hi == 0) {   /* No child yet ... Makes things easy ! */
0001fa  f1b90f00          CMP      r9,#0
0001fe  d102              BNE      |L1.518|
;;;367          pParent->hFirstChild = hWin;
000200  833e              STRH     r6,[r7,#0x18]
                  |L1.514|
;;;368          return;                         /* Early out ... We are done */
;;;369        }
;;;370        /* Put it at beginning of the list if first child is a TOP window and new one is not */
;;;371        pi = WM_H2P(hi);
;;;372        if (!OnTop) {
;;;373          if (pi->Status & WM_SF_STAYONTOP) {
;;;374            pWin->hNext = hi;
;;;375            pParent->hFirstChild = hWin;
;;;376            return;                         /* Early out ... We are done */
;;;377          }
;;;378        }
;;;379        /* Put it at the end of the list or before the last non "STAY-ON-TOP" child */
;;;380        do {
;;;381          WM_Obj* pNext;
;;;382          WM_HWIN hNext;
;;;383          if ((hNext = pi->hNext) == 0) {   /* End of sibling list ? */
;;;384            pi->hNext = hWin;             /* Then modify this last element to point to new one and we are done */
;;;385            break;
;;;386          }
;;;387          pNext = WM_H2P(hNext);
;;;388          if (!OnTop) {
;;;389            if (pNext->Status & WM_SF_STAYONTOP) {
;;;390              pi->hNext = hWin;
;;;391              pWin->hNext = hNext;
;;;392              break;
;;;393            }
;;;394          }
;;;395          pi = pNext;
;;;396        }  while (1);
;;;397        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;398          WM__NotifyVisChanged(hWin, &pWin->Rect);
;;;399        #endif
;;;400      }
;;;401    }
000202  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.518|
000206  4648              MOV      r0,r9                 ;371
000208  f7fffffe          BL       GUI_ALLOC_h2p
00020c  4605              MOV      r5,r0                 ;371
00020e  f1bb0f00          CMP      r11,#0                ;372
000212  d107              BNE      |L1.548|
000214  8ba8              LDRH     r0,[r5,#0x1c]         ;373
000216  f0100f08          TST      r0,#8                 ;373
00021a  d003              BEQ      |L1.548|
00021c  f8a4901a          STRH     r9,[r4,#0x1a]         ;374
000220  833e              STRH     r6,[r7,#0x18]         ;375
000222  e7ee              B        |L1.514|
                  |L1.548|
000224  bf00              NOP                            ;380
                  |L1.550|
000226  f9b5001a          LDRSH    r0,[r5,#0x1a]         ;383
00022a  9000              STR      r0,[sp,#0]            ;383
00022c  b908              CBNZ     r0,|L1.562|
00022e  836e              STRH     r6,[r5,#0x1a]         ;384
000230  e011              B        |L1.598|
                  |L1.562|
000232  9800              LDR      r0,[sp,#0]            ;387
000234  f7fffffe          BL       GUI_ALLOC_h2p
000238  4682              MOV      r10,r0                ;387
00023a  f1bb0f00          CMP      r11,#0                ;388
00023e  d108              BNE      |L1.594|
000240  f8ba001c          LDRH     r0,[r10,#0x1c]        ;389
000244  f0100f08          TST      r0,#8                 ;389
000248  d003              BEQ      |L1.594|
00024a  836e              STRH     r6,[r5,#0x1a]         ;390
00024c  9800              LDR      r0,[sp,#0]            ;391
00024e  8360              STRH     r0,[r4,#0x1a]         ;391
000250  e001              B        |L1.598|
                  |L1.594|
000252  4655              MOV      r5,r10                ;395
000254  e7e7              B        |L1.550|
                  |L1.598|
000256  bf00              NOP                            ;385
                  |L1.600|
000258  bf00              NOP      
00025a  e7d2              B        |L1.514|
;;;402    
                          ENDP

                  WM__RemoveWindowFromList PROC
;;;406    */
;;;407    void WM__RemoveWindowFromList(WM_HWIN hWin) {
00025c  e92d47f0          PUSH     {r4-r10,lr}
000260  4607              MOV      r7,r0
;;;408      WM_HWIN hi, hParent;
;;;409      WM_Obj * pWin, * pParent, * pi;
;;;410      
;;;411      pWin = WM_H2P(hWin);
000262  4638              MOV      r0,r7
000264  f7fffffe          BL       GUI_ALLOC_h2p
000268  4681              MOV      r9,r0
;;;412      hParent = pWin->hParent;
00026a  f9b98016          LDRSH    r8,[r9,#0x16]
;;;413      if (hParent) {
00026e  f1b80f00          CMP      r8,#0
000272  d020              BEQ      |L1.694|
;;;414        pParent = WM_H2P(hParent);
000274  4640              MOV      r0,r8
000276  f7fffffe          BL       GUI_ALLOC_h2p
00027a  4606              MOV      r6,r0
;;;415        hi = pParent->hFirstChild;
00027c  f9b65018          LDRSH    r5,[r6,#0x18]
;;;416        if (hi == hWin) {
000280  42bd              CMP      r5,r7
000282  d106              BNE      |L1.658|
;;;417          pi = WM_H2P(hi);
000284  4628              MOV      r0,r5
000286  f7fffffe          BL       GUI_ALLOC_h2p
00028a  4604              MOV      r4,r0
;;;418          pParent->hFirstChild = pi->hNext;
00028c  8b60              LDRH     r0,[r4,#0x1a]
00028e  8330              STRH     r0,[r6,#0x18]
000290  e011              B        |L1.694|
                  |L1.658|
;;;419        } else {
;;;420          while (hi) {
000292  e00d              B        |L1.688|
                  |L1.660|
;;;421            pi = WM_H2P(hi);
000294  4628              MOV      r0,r5
000296  f7fffffe          BL       GUI_ALLOC_h2p
00029a  4604              MOV      r4,r0
;;;422            if (pi->hNext == hWin) {
00029c  f9b4001a          LDRSH    r0,[r4,#0x1a]
0002a0  42b8              CMP      r0,r7
0002a2  d103              BNE      |L1.684|
;;;423              pi->hNext = pWin->hNext;
0002a4  f8b9001a          LDRH     r0,[r9,#0x1a]
0002a8  8360              STRH     r0,[r4,#0x1a]
;;;424              break;
0002aa  e003              B        |L1.692|
                  |L1.684|
;;;425            }
;;;426            hi = pi->hNext;
0002ac  f9b4501a          LDRSH    r5,[r4,#0x1a]
                  |L1.688|
0002b0  2d00              CMP      r5,#0                 ;420
0002b2  d1ef              BNE      |L1.660|
                  |L1.692|
0002b4  bf00              NOP                            ;424
                  |L1.694|
;;;427          }
;;;428        }
;;;429      }
;;;430    }
0002b6  e8bd87f0          POP      {r4-r10,pc}
;;;431    
                          ENDP

                  WM_InvalidateArea PROC
;;;781    */
;;;782    void WM_InvalidateArea(const GUI_RECT* pRect) {
0002ba  b570              PUSH     {r4-r6,lr}
0002bc  4604              MOV      r4,r0
;;;783      WM_HWIN   hWin;
;;;784      WM_LOCK();
0002be  f7fffffe          BL       GUI_Lock
;;;785      /* Iterate over all windows */
;;;786      for (hWin = WM__FirstWin; hWin; hWin = WM_H2P(hWin)->hNextLin) {
0002c2  484f              LDR      r0,|L1.1024|
0002c4  f9b05000          LDRSH    r5,[r0,#0]  ; WM__FirstWin
0002c8  e008              B        |L1.732|
                  |L1.714|
;;;787        _Invalidate1Abs(hWin, pRect);
0002ca  4621              MOV      r1,r4
0002cc  4628              MOV      r0,r5
0002ce  f7fffffe          BL       _Invalidate1Abs
0002d2  4628              MOV      r0,r5                 ;786
0002d4  f7fffffe          BL       GUI_ALLOC_h2p
0002d8  f9b05014          LDRSH    r5,[r0,#0x14]         ;786
                  |L1.732|
0002dc  2d00              CMP      r5,#0                 ;786
0002de  d1f4              BNE      |L1.714|
;;;788      }
;;;789      WM_UNLOCK();
0002e0  f7fffffe          BL       GUI_Unlock
;;;790    }
0002e4  bd70              POP      {r4-r6,pc}
;;;791    
                          ENDP

                  WM__DetachWindow PROC
;;;439    */
;;;440    void WM__DetachWindow(WM_HWIN hWin) {
0002e6  b570              PUSH     {r4-r6,lr}
0002e8  4605              MOV      r5,r0
;;;441      WM_Obj* pWin;
;;;442      WM_HWIN hParent;
;;;443      pWin = WM_H2P(hWin);
0002ea  4628              MOV      r0,r5
0002ec  f7fffffe          BL       GUI_ALLOC_h2p
0002f0  4604              MOV      r4,r0
;;;444      hParent = pWin->hParent;
0002f2  f9b46016          LDRSH    r6,[r4,#0x16]
;;;445      if (hParent) {
0002f6  b13e              CBZ      r6,|L1.776|
;;;446        WM__RemoveWindowFromList(hWin);
0002f8  4628              MOV      r0,r5
0002fa  f7fffffe          BL       WM__RemoveWindowFromList
;;;447        /* Clear area used by this window */
;;;448        WM_InvalidateArea(&pWin->Rect);
0002fe  4620              MOV      r0,r4
000300  f7fffffe          BL       WM_InvalidateArea
;;;449        pWin->hParent = 0;
000304  2000              MOVS     r0,#0
000306  82e0              STRH     r0,[r4,#0x16]
                  |L1.776|
;;;450      }
;;;451    }
000308  bd70              POP      {r4-r6,pc}
;;;452    
                          ENDP

                  WM_SelectWindow PROC
;;;958    */
;;;959    WM_HWIN WM_SelectWindow(WM_HWIN  hWin) {
00030a  b570              PUSH     {r4-r6,lr}
00030c  4604              MOV      r4,r0
;;;960      WM_HWIN hWinPrev;
;;;961      WM_Obj* pObj;
;;;962    
;;;963      WM_ASSERT_NOT_IN_PAINT();
;;;964      WM_LOCK();
00030e  f7fffffe          BL       GUI_Lock
;;;965      hWinPrev = GUI_Context.hAWin;
000312  4838              LDR      r0,|L1.1012|
000314  f9b0603c          LDRSH    r6,[r0,#0x3c]  ; GUI_Context
;;;966      if (hWin == 0) {
000318  b914              CBNZ     r4,|L1.800|
;;;967        hWin = WM__FirstWin;
00031a  4839              LDR      r0,|L1.1024|
00031c  f9b04000          LDRSH    r4,[r0,#0]  ; WM__FirstWin
                  |L1.800|
;;;968      }
;;;969      /* Select new window */
;;;970      GUI_Context.hAWin = hWin;
000320  4834              LDR      r0,|L1.1012|
000322  8784              STRH     r4,[r0,#0x3c]
;;;971      #if GUI_NUM_LAYERS > 1
;;;972      {
;;;973        WM_HWIN hTop;
;;;974        int LayerIndex;
;;;975        hTop = _GetTopLevelWindow(hWin);
;;;976        LayerIndex = _DesktopHandle2Index(hTop);
;;;977        if (LayerIndex >= 0) {
;;;978          GUI_SelectLayer(LayerIndex);
;;;979        }
;;;980      }
;;;981      #endif
;;;982      pObj = WM_H2P(hWin);
000324  4620              MOV      r0,r4
000326  f7fffffe          BL       GUI_ALLOC_h2p
00032a  4605              MOV      r5,r0
;;;983      LCD_SetClipRectMax();             /* Drawing operations will clip ... If WM is deactivated, allow all */
00032c  f7fffffe          BL       LCD_SetClipRectMax
;;;984      GUI_Context.xOff = pObj->Rect.x0;
000330  f9b50000          LDRSH    r0,[r5,#0]
000334  492f              LDR      r1,|L1.1012|
000336  6408              STR      r0,[r1,#0x40]  ; GUI_Context
;;;985      GUI_Context.yOff = pObj->Rect.y0;
000338  f9b50002          LDRSH    r0,[r5,#2]
00033c  6448              STR      r0,[r1,#0x44]  ; GUI_Context
;;;986      WM_UNLOCK();
00033e  f7fffffe          BL       GUI_Unlock
;;;987      return hWinPrev;
000342  4630              MOV      r0,r6
;;;988    }
000344  bd70              POP      {r4-r6,pc}
;;;989    
                          ENDP

                  WM__RemoveFromLinList PROC
;;;509    */
;;;510    void WM__RemoveFromLinList(WM_HWIN hWin) {
000346  e92d41f0          PUSH     {r4-r8,lr}
00034a  4606              MOV      r6,r0
;;;511      WM_Obj* piWin;
;;;512      WM_HWIN hiWin;
;;;513      WM_HWIN hNext;
;;;514      for (hiWin = WM__FirstWin; hiWin; ) {
00034c  482c              LDR      r0,|L1.1024|
00034e  f9b07000          LDRSH    r7,[r0,#0]  ; WM__FirstWin
000352  e00e              B        |L1.882|
                  |L1.852|
;;;515        piWin = WM_H2P(hiWin);
000354  4638              MOV      r0,r7
000356  f7fffffe          BL       GUI_ALLOC_h2p
00035a  4604              MOV      r4,r0
;;;516        hNext = piWin->hNextLin;
00035c  f9b45014          LDRSH    r5,[r4,#0x14]
;;;517        if (hNext == hWin) {
000360  42b5              CMP      r5,r6
000362  d105              BNE      |L1.880|
;;;518          piWin->hNextLin = WM_H2P(hWin)->hNextLin;
000364  4630              MOV      r0,r6
000366  f7fffffe          BL       GUI_ALLOC_h2p
00036a  8a80              LDRH     r0,[r0,#0x14]
00036c  82a0              STRH     r0,[r4,#0x14]
;;;519          break;
00036e  e002              B        |L1.886|
                  |L1.880|
;;;520        }
;;;521        hiWin = hNext;
000370  462f              MOV      r7,r5
                  |L1.882|
000372  2f00              CMP      r7,#0                 ;514
000374  d1ee              BNE      |L1.852|
                  |L1.886|
000376  bf00              NOP                            ;519
;;;522      }
;;;523    }
000378  e8bd81f0          POP      {r4-r8,pc}
;;;524    
                          ENDP

                  WM_SendMessage PROC
;;;676    */
;;;677    void WM_SendMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
00037c  b570              PUSH     {r4-r6,lr}
00037e  4604              MOV      r4,r0
000380  460d              MOV      r5,r1
;;;678      if (hWin) {
000382  b174              CBZ      r4,|L1.930|
;;;679        WM_Obj* pWin;
;;;680        WM_LOCK();
000384  f7fffffe          BL       GUI_Lock
;;;681        pWin = WM_H2P(hWin);
000388  4620              MOV      r0,r4
00038a  f7fffffe          BL       GUI_ALLOC_h2p
00038e  4606              MOV      r6,r0
;;;682        if (pWin->cb != NULL) {
000390  6930              LDR      r0,[r6,#0x10]
000392  b118              CBZ      r0,|L1.924|
;;;683          pMsg->hWin = hWin;
000394  80ac              STRH     r4,[r5,#4]
;;;684          (*pWin->cb)(pMsg);
000396  4628              MOV      r0,r5
000398  6931              LDR      r1,[r6,#0x10]
00039a  4788              BLX      r1
                  |L1.924|
;;;685        }
;;;686        WM_UNLOCK();
00039c  f7fffffe          BL       GUI_Unlock
;;;687      }
0003a0  bf00              NOP      
                  |L1.930|
;;;688    }
0003a2  bd70              POP      {r4-r6,pc}
;;;689    
                          ENDP

                  WM__SendMsgNoData PROC
;;;693    */
;;;694    void WM__SendMsgNoData(WM_HWIN hWin, U8 MsgId) {
0003a4  b53e              PUSH     {r1-r5,lr}
0003a6  4605              MOV      r5,r0
0003a8  460c              MOV      r4,r1
;;;695      WM_MESSAGE Msg;
;;;696      Msg.hWin  = hWin;
0003aa  f8ad5004          STRH     r5,[sp,#4]
;;;697      Msg.MsgId = MsgId;
0003ae  9400              STR      r4,[sp,#0]
;;;698      WM_SendMessage(hWin, &Msg);
0003b0  4669              MOV      r1,sp
0003b2  4628              MOV      r0,r5
0003b4  f7fffffe          BL       WM_SendMessage
;;;699    }
0003b8  bd3e              POP      {r1-r5,pc}
;;;700    
                          ENDP

                  WM__IsWindow PROC
;;;484    */
;;;485    int WM__IsWindow(WM_HWIN hWin) {
0003ba  b570              PUSH     {r4-r6,lr}
0003bc  4605              MOV      r5,r0
;;;486      WM_HWIN iWin;
;;;487      for (iWin = WM__FirstWin; iWin; iWin = WM_H2P(iWin)->hNextLin) {
0003be  4810              LDR      r0,|L1.1024|
0003c0  f9b04000          LDRSH    r4,[r0,#0]  ; WM__FirstWin
0003c4  e008              B        |L1.984|
                  |L1.966|
;;;488        if (iWin == hWin) {
0003c6  42ac              CMP      r4,r5
0003c8  d101              BNE      |L1.974|
;;;489          return 1;
0003ca  2001              MOVS     r0,#1
                  |L1.972|
;;;490        }
;;;491      }
;;;492      return 0;
;;;493    }
0003cc  bd70              POP      {r4-r6,pc}
                  |L1.974|
0003ce  4620              MOV      r0,r4                 ;487
0003d0  f7fffffe          BL       GUI_ALLOC_h2p
0003d4  f9b04014          LDRSH    r4,[r0,#0x14]         ;487
                  |L1.984|
0003d8  2c00              CMP      r4,#0                 ;487
0003da  d1f4              BNE      |L1.966|
0003dc  2000              MOVS     r0,#0                 ;492
0003de  e7f5              B        |L1.972|
                  |L1.992|
                          DCD      WM__pFirstCriticalHandle
                  |L1.996|
                          DCD      WM__ahDesktopWin
                  |L1.1000|
                          DCD      WM__NumInvalidWindows
                  |L1.1004|
                          DCD      NextDrawWin
                  |L1.1008|
                          DCD      WM__hATransWindow
                  |L1.1012|
                          DCD      GUI_Context
                  |L1.1016|
                          DCD      WM_IsActive
                  |L1.1020|
                          DCD      _ClipContext+0x8
                  |L1.1024|
                          DCD      WM__FirstWin
                          ENDP

                  WM_DeleteWindow PROC
;;;899    */
;;;900    void WM_DeleteWindow (WM_HWIN hWin) {
000404  b570              PUSH     {r4-r6,lr}
000406  4604              MOV      r4,r0
;;;901      WM_Obj* pWin;
;;;902      if (!hWin) {
000408  b904              CBNZ     r4,|L1.1036|
                  |L1.1034|
;;;903        return;
;;;904      }
;;;905      WM_ASSERT_NOT_IN_PAINT();
;;;906      WM_LOCK();
;;;907      if (WM__IsWindow(hWin)) {
;;;908        pWin = WM_H2P(hWin);
;;;909        ResetNextDrawWin();              /* Make sure the window will no longer receive drawing messages */
;;;910      /* Make sure that focus is set to an existing window */
;;;911        if (WM__hWinFocus == hWin) {
;;;912          WM__hWinFocus = 0;
;;;913        }
;;;914        if (WM__hCapture == hWin) {
;;;915          WM__hCapture = 0;
;;;916        }
;;;917        /* check if critical handles are affected. If so, reset the window handle to 0 */
;;;918        _CheckCriticalHandles(hWin);
;;;919        /* Inform parent */
;;;920        WM_NotifyParent(hWin, WM_NOTIFICATION_CHILD_DELETED);
;;;921        /* Delete all children */
;;;922        _DeleteAllChildren(pWin->hFirstChild);
;;;923        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;924          WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
;;;925        #endif
;;;926        /* Send WM_DELETE message to window in order to inform window itself */
;;;927        WM__SendMsgNoData(hWin, WM_DELETE);     /* tell window about it */
;;;928        WM__DetachWindow(hWin);
;;;929        /* Remove window from window stack */
;;;930        WM__RemoveFromLinList(hWin);
;;;931        /* Handle transparency counter if necessary */
;;;932        #if WM_SUPPORT_TRANSPARENCY
;;;933          if (pWin->Status & WM_SF_HASTRANS) {
;;;934            WM__TransWindowCnt--;
;;;935          }
;;;936        #endif
;;;937        /* Make sure window is no longer counted as invalid */
;;;938        if (pWin->Status & WM_SF_INVALID) {
;;;939          WM__NumInvalidWindows--;
;;;940        }
;;;941      /* Free window memory */
;;;942        WM__NumWindows--;
;;;943        GUI_ALLOC_Free(hWin);
;;;944      /* Select a valid window */
;;;945        WM_SelectWindow(WM__FirstWin);
;;;946      } else {
;;;947        GUI_DEBUG_WARN("WM_DeleteWindow: Invalid handle");
;;;948      }
;;;949      WM_UNLOCK();
;;;950    }
00040a  bd70              POP      {r4-r6,pc}
                  |L1.1036|
00040c  f7fffffe          BL       GUI_Lock
000410  4620              MOV      r0,r4                 ;907
000412  f7fffffe          BL       WM__IsWindow
000416  2800              CMP      r0,#0                 ;907
000418  d049              BEQ      |L1.1198|
00041a  4620              MOV      r0,r4                 ;908
00041c  f7fffffe          BL       GUI_ALLOC_h2p
000420  4605              MOV      r5,r0                 ;908
000422  f7fffffe          BL       ResetNextDrawWin
000426  48fe              LDR      r0,|L1.2080|
000428  f9b00000          LDRSH    r0,[r0,#0]            ;911  ; WM__hWinFocus
00042c  42a0              CMP      r0,r4                 ;911
00042e  d102              BNE      |L1.1078|
000430  2000              MOVS     r0,#0                 ;912
000432  49fb              LDR      r1,|L1.2080|
000434  8008              STRH     r0,[r1,#0]            ;912
                  |L1.1078|
000436  48fb              LDR      r0,|L1.2084|
000438  f9b00000          LDRSH    r0,[r0,#0]            ;914  ; WM__hCapture
00043c  42a0              CMP      r0,r4                 ;914
00043e  d102              BNE      |L1.1094|
000440  2000              MOVS     r0,#0                 ;915
000442  49f8              LDR      r1,|L1.2084|
000444  8008              STRH     r0,[r1,#0]            ;915
                  |L1.1094|
000446  4620              MOV      r0,r4                 ;918
000448  f7fffffe          BL       _CheckCriticalHandles
00044c  2107              MOVS     r1,#7                 ;920
00044e  4620              MOV      r0,r4                 ;920
000450  f7fffffe          BL       WM_NotifyParent
000454  f9b50018          LDRSH    r0,[r5,#0x18]         ;922
000458  f7fffffe          BL       _DeleteAllChildren
00045c  210b              MOVS     r1,#0xb               ;927
00045e  4620              MOV      r0,r4                 ;927
000460  f7fffffe          BL       WM__SendMsgNoData
000464  4620              MOV      r0,r4                 ;928
000466  f7fffffe          BL       WM__DetachWindow
00046a  4620              MOV      r0,r4                 ;930
00046c  f7fffffe          BL       WM__RemoveFromLinList
000470  8ba8              LDRH     r0,[r5,#0x1c]         ;933
000472  f0100f01          TST      r0,#1                 ;933
000476  d004              BEQ      |L1.1154|
000478  48eb              LDR      r0,|L1.2088|
00047a  6800              LDR      r0,[r0,#0]            ;934  ; WM__TransWindowCnt
00047c  1e40              SUBS     r0,r0,#1              ;934
00047e  49ea              LDR      r1,|L1.2088|
000480  6008              STR      r0,[r1,#0]            ;934  ; WM__TransWindowCnt
                  |L1.1154|
000482  8ba8              LDRH     r0,[r5,#0x1c]         ;938
000484  f0100f20          TST      r0,#0x20              ;938
000488  d004              BEQ      |L1.1172|
00048a  48e8              LDR      r0,|L1.2092|
00048c  8800              LDRH     r0,[r0,#0]            ;939  ; WM__NumInvalidWindows
00048e  1e40              SUBS     r0,r0,#1              ;939
000490  49e6              LDR      r1,|L1.2092|
000492  8008              STRH     r0,[r1,#0]            ;939
                  |L1.1172|
000494  48e6              LDR      r0,|L1.2096|
000496  8800              LDRH     r0,[r0,#0]            ;942  ; WM__NumWindows
000498  1e40              SUBS     r0,r0,#1              ;942
00049a  49e5              LDR      r1,|L1.2096|
00049c  8008              STRH     r0,[r1,#0]            ;942
00049e  4620              MOV      r0,r4                 ;943
0004a0  f7fffffe          BL       GUI_ALLOC_Free
0004a4  48e3              LDR      r0,|L1.2100|
0004a6  f9b00000          LDRSH    r0,[r0,#0]            ;945  ; WM__FirstWin
0004aa  f7fffffe          BL       WM_SelectWindow
                  |L1.1198|
0004ae  f7fffffe          BL       GUI_Unlock
0004b2  bf00              NOP      
0004b4  e7a9              B        |L1.1034|
;;;951    
                          ENDP

                  _DeleteAllChildren PROC
;;;457    */
;;;458    static void _DeleteAllChildren(WM_HWIN hChild) {
0004b6  b570              PUSH     {r4-r6,lr}
0004b8  4604              MOV      r4,r0
;;;459      while (hChild) {
0004ba  e00a              B        |L1.1234|
                  |L1.1212|
;;;460        WM_Obj* pChild = WM_H2P(hChild);
0004bc  4620              MOV      r0,r4
0004be  f7fffffe          BL       GUI_ALLOC_h2p
0004c2  4605              MOV      r5,r0
;;;461        WM_HWIN hNext = pChild->hNext;
0004c4  f9b5601a          LDRSH    r6,[r5,#0x1a]
;;;462        WM_DeleteWindow(hChild);
0004c8  4620              MOV      r0,r4
0004ca  f7fffffe          BL       WM_DeleteWindow
;;;463        hChild = hNext;
0004ce  4634              MOV      r4,r6
;;;464      }
0004d0  bf00              NOP      
                  |L1.1234|
0004d2  2c00              CMP      r4,#0                 ;459
0004d4  d1f2              BNE      |L1.1212|
;;;465    }
0004d6  bd70              POP      {r4-r6,pc}
;;;466    
                          ENDP

                  WM__InvalidateAreaBelow PROC
;;;500    */
;;;501    void WM__InvalidateAreaBelow(const GUI_RECT* pRect, WM_HWIN StopWin) {
0004d8  b570              PUSH     {r4-r6,lr}
0004da  4605              MOV      r5,r0
0004dc  460c              MOV      r4,r1
;;;502      GUI_USE_PARA(StopWin);
0004de  bf00              NOP      
;;;503      WM_InvalidateArea(pRect);      /* Can be optimized to spare windows above */
0004e0  4628              MOV      r0,r5
0004e2  f7fffffe          BL       WM_InvalidateArea
;;;504    }
0004e6  bd70              POP      {r4-r6,pc}
;;;505    
                          ENDP

                  _AddToLinList PROC
;;;528    */
;;;529    static void _AddToLinList(WM_HWIN hNew) {
0004e8  b570              PUSH     {r4-r6,lr}
0004ea  4604              MOV      r4,r0
;;;530      WM_Obj* pFirst;
;;;531      WM_Obj* pNew;
;;;532      if (WM__FirstWin) {
0004ec  48d1              LDR      r0,|L1.2100|
0004ee  8800              LDRH     r0,[r0,#0]  ; WM__FirstWin
0004f0  b168              CBZ      r0,|L1.1294|
;;;533        pFirst = WM_H2P(WM__FirstWin);
0004f2  48d0              LDR      r0,|L1.2100|
0004f4  f9b00000          LDRSH    r0,[r0,#0]  ; WM__FirstWin
0004f8  f7fffffe          BL       GUI_ALLOC_h2p
0004fc  4606              MOV      r6,r0
;;;534        pNew   = WM_H2P(hNew);
0004fe  4620              MOV      r0,r4
000500  f7fffffe          BL       GUI_ALLOC_h2p
000504  4605              MOV      r5,r0
;;;535        pNew->hNextLin = pFirst->hNextLin;
000506  8ab0              LDRH     r0,[r6,#0x14]
000508  82a8              STRH     r0,[r5,#0x14]
;;;536        pFirst->hNextLin = hNew;
00050a  82b4              STRH     r4,[r6,#0x14]
00050c  e001              B        |L1.1298|
                  |L1.1294|
;;;537      } else {
;;;538        WM__FirstWin = hNew;
00050e  48c9              LDR      r0,|L1.2100|
000510  8004              STRH     r4,[r0,#0]
                  |L1.1298|
;;;539      }
;;;540    }
000512  bd70              POP      {r4-r6,pc}
;;;541    
                          ENDP

                  _Findy1 PROC
;;;561    */
;;;562    static void _Findy1(WM_HWIN iWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
000514  e92d47fc          PUSH     {r2-r10,lr}
000518  4606              MOV      r6,r0
00051a  460c              MOV      r4,r1
00051c  4617              MOV      r7,r2
;;;563      WM_Obj* pWin;
;;;564      for (; iWin; iWin = pWin->hNext) { 
00051e  e04d              B        |L1.1468|
                  |L1.1312|
;;;565        int Status = (pWin = WM_H2P(iWin))->Status;
000520  4630              MOV      r0,r6
000522  f7fffffe          BL       GUI_ALLOC_h2p
000526  4605              MOV      r5,r0
000528  f8b0801c          LDRH     r8,[r0,#0x1c]
;;;566        /* Check if this window affects us at all */    
;;;567        if (Status & WM_SF_ISVIS) {
00052c  f0180f02          TST      r8,#2
000530  d042              BEQ      |L1.1464|
;;;568          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;569          if (pParentRect) {
000532  b12f              CBZ      r7,|L1.1344|
;;;570            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
000534  463a              MOV      r2,r7
000536  4629              MOV      r1,r5
000538  4668              MOV      r0,sp
00053a  f7fffffe          BL       GUI__IntersectRects
00053e  e003              B        |L1.1352|
                  |L1.1344|
;;;571          } else {
;;;572            rWinClipped = pWin->Rect;
000540  e9d50100          LDRD     r0,r1,[r5,#0]
000544  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L1.1352|
;;;573          }
;;;574          /* Check if this window affects us at all */    
;;;575          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
000548  4669              MOV      r1,sp
00054a  4620              MOV      r0,r4
00054c  f7fffffe          BL       GUI_RectsIntersect
000550  b388              CBZ      r0,|L1.1462|
;;;576            if ((Status & WM_SF_HASTRANS) == 0) {
000552  f0180f01          TST      r8,#1
000556  d11c              BNE      |L1.1426|
;;;577              if (pWin->Rect.y0 > pRect->y0) {
000558  f9b50002          LDRSH    r0,[r5,#2]
00055c  f9b41002          LDRSH    r1,[r4,#2]
000560  4288              CMP      r0,r1
000562  dd0c              BLE      |L1.1406|
;;;578                ASSIGN_IF_LESS(pRect->y1, rWinClipped.y0 - 1);      /* Check upper border of window */
000564  f9bd0002          LDRSH    r0,[sp,#2]
000568  1e40              SUBS     r0,r0,#1
00056a  f9b41006          LDRSH    r1,[r4,#6]
00056e  4288              CMP      r0,r1
000570  da21              BGE      |L1.1462|
000572  f8bd0002          LDRH     r0,[sp,#2]
000576  1e40              SUBS     r0,r0,#1
000578  b200              SXTH     r0,r0
00057a  80e0              STRH     r0,[r4,#6]
00057c  e01b              B        |L1.1462|
                  |L1.1406|
;;;579              } else {
;;;580                ASSIGN_IF_LESS(pRect->y1, rWinClipped.y1);        /* Check lower border of window */
00057e  f9bd0006          LDRSH    r0,[sp,#6]
000582  f9b41006          LDRSH    r1,[r4,#6]
000586  4288              CMP      r0,r1
000588  da15              BGE      |L1.1462|
00058a  f8bd0006          LDRH     r0,[sp,#6]
00058e  80e0              STRH     r0,[r4,#6]
000590  e011              B        |L1.1462|
                  |L1.1426|
;;;581              }
;;;582            } else {
;;;583              /* Check all children*/ 
;;;584              WM_HWIN hChild;
;;;585              WM_Obj* pChild;
;;;586              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
000592  f9b59018          LDRSH    r9,[r5,#0x18]
000596  e00a              B        |L1.1454|
                  |L1.1432|
;;;587                pChild = WM_H2P(hChild);
000598  4648              MOV      r0,r9
00059a  f7fffffe          BL       GUI_ALLOC_h2p
00059e  4682              MOV      r10,r0
;;;588                _Findy1(hChild, pRect, &rWinClipped);
0005a0  466a              MOV      r2,sp
0005a2  4621              MOV      r1,r4
0005a4  4648              MOV      r0,r9
0005a6  f7fffffe          BL       _Findy1
0005aa  f9ba901a          LDRSH    r9,[r10,#0x1a]        ;586
                  |L1.1454|
0005ae  f1b90f00          CMP      r9,#0                 ;586
0005b2  d1f1              BNE      |L1.1432|
;;;589              }
;;;590            }
0005b4  bf00              NOP      
                  |L1.1462|
;;;591          }
;;;592        }
0005b6  bf00              NOP      
                  |L1.1464|
0005b8  f9b5601a          LDRSH    r6,[r5,#0x1a]         ;564
                  |L1.1468|
0005bc  2e00              CMP      r6,#0                 ;564
0005be  d1af              BNE      |L1.1312|
;;;593      }
;;;594    }
0005c0  e8bd87fc          POP      {r2-r10,pc}
;;;595    
                          ENDP

                  _Findx0 PROC
;;;599    */
;;;600    static int _Findx0(WM_HWIN hWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
0005c4  e92d5ffc          PUSH     {r2-r12,lr}
0005c8  4606              MOV      r6,r0
0005ca  460d              MOV      r5,r1
0005cc  4617              MOV      r7,r2
;;;601      WM_Obj* pWin;
;;;602      int r = 0;
0005ce  f04f0b00          MOV      r11,#0
;;;603      for (; hWin; hWin = pWin->hNext) { 
0005d2  e03b              B        |L1.1612|
                  |L1.1492|
;;;604        int Status = (pWin = WM_H2P(hWin))->Status;
0005d4  4630              MOV      r0,r6
0005d6  f7fffffe          BL       GUI_ALLOC_h2p
0005da  4604              MOV      r4,r0
0005dc  f8b0801c          LDRH     r8,[r0,#0x1c]
;;;605        if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
0005e0  f0180f02          TST      r8,#2
0005e4  d030              BEQ      |L1.1608|
;;;606          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;607          if (pParentRect) {
0005e6  b12f              CBZ      r7,|L1.1524|
;;;608            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
0005e8  463a              MOV      r2,r7
0005ea  4621              MOV      r1,r4
0005ec  4668              MOV      r0,sp
0005ee  f7fffffe          BL       GUI__IntersectRects
0005f2  e003              B        |L1.1532|
                  |L1.1524|
;;;609          } else {
;;;610            rWinClipped = pWin->Rect;
0005f4  e9d40100          LDRD     r0,r1,[r4,#0]
0005f8  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L1.1532|
;;;611          }
;;;612          /* Check if this window affects us at all */    
;;;613          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
0005fc  4669              MOV      r1,sp
0005fe  4628              MOV      r0,r5
000600  f7fffffe          BL       GUI_RectsIntersect
000604  b1f8              CBZ      r0,|L1.1606|
;;;614            if ((Status & WM_SF_HASTRANS) == 0) {
000606  f0180f01          TST      r8,#1
00060a  d107              BNE      |L1.1564|
;;;615              pRect->x0 = rWinClipped.x1+1;
00060c  f8bd0004          LDRH     r0,[sp,#4]
000610  1c40              ADDS     r0,r0,#1
000612  b200              SXTH     r0,r0
000614  8028              STRH     r0,[r5,#0]
;;;616              r = 1;
000616  f04f0b01          MOV      r11,#1
00061a  e014              B        |L1.1606|
                  |L1.1564|
;;;617            } else {
;;;618              /* Check all children */
;;;619              WM_HWIN hChild;
;;;620              WM_Obj* pChild;
;;;621              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
00061c  f9b49018          LDRSH    r9,[r4,#0x18]
000620  e00d              B        |L1.1598|
                  |L1.1570|
;;;622                pChild = WM_H2P(hChild);
000622  4648              MOV      r0,r9
000624  f7fffffe          BL       GUI_ALLOC_h2p
000628  4682              MOV      r10,r0
;;;623                if (_Findx0(hChild, pRect, &rWinClipped)) {
00062a  466a              MOV      r2,sp
00062c  4629              MOV      r1,r5
00062e  4648              MOV      r0,r9
000630  f7fffffe          BL       _Findx0
000634  b108              CBZ      r0,|L1.1594|
;;;624                  r = 1;
000636  f04f0b01          MOV      r11,#1
                  |L1.1594|
00063a  f9ba901a          LDRSH    r9,[r10,#0x1a]        ;621
                  |L1.1598|
00063e  f1b90f00          CMP      r9,#0                 ;621
000642  d1ee              BNE      |L1.1570|
;;;625                }
;;;626              }
;;;627            }
000644  bf00              NOP      
                  |L1.1606|
;;;628          }
;;;629        }
000646  bf00              NOP      
                  |L1.1608|
000648  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;603
                  |L1.1612|
00064c  2e00              CMP      r6,#0                 ;603
00064e  d1c1              BNE      |L1.1492|
;;;630      }
;;;631      return r;
000650  4658              MOV      r0,r11
;;;632    }
000652  e8bd9ffc          POP      {r2-r12,pc}
;;;633    
                          ENDP

                  _Findx1 PROC
;;;637    */
;;;638    static void _Findx1(WM_HWIN hWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
000656  e92d47fc          PUSH     {r2-r10,lr}
00065a  4606              MOV      r6,r0
00065c  460d              MOV      r5,r1
00065e  4617              MOV      r7,r2
;;;639      WM_Obj* pWin;
;;;640      for (; hWin; hWin = pWin->hNext) { 
000660  e036              B        |L1.1744|
                  |L1.1634|
;;;641        int Status = (pWin = WM_H2P(hWin))->Status;
000662  4630              MOV      r0,r6
000664  f7fffffe          BL       GUI_ALLOC_h2p
000668  4604              MOV      r4,r0
00066a  f8b0801c          LDRH     r8,[r0,#0x1c]
;;;642        if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
00066e  f0180f02          TST      r8,#2
000672  d02b              BEQ      |L1.1740|
;;;643          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;644          if (pParentRect) {
000674  b12f              CBZ      r7,|L1.1666|
;;;645            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
000676  463a              MOV      r2,r7
000678  4621              MOV      r1,r4
00067a  4668              MOV      r0,sp
00067c  f7fffffe          BL       GUI__IntersectRects
000680  e003              B        |L1.1674|
                  |L1.1666|
;;;646          } else {
;;;647            rWinClipped = pWin->Rect;
000682  e9d40100          LDRD     r0,r1,[r4,#0]
000686  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L1.1674|
;;;648          }
;;;649          /* Check if this window affects us at all */    
;;;650          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
00068a  4669              MOV      r1,sp
00068c  4628              MOV      r0,r5
00068e  f7fffffe          BL       GUI_RectsIntersect
000692  b1d0              CBZ      r0,|L1.1738|
;;;651            if ((Status & WM_SF_HASTRANS) == 0) {
000694  f0180f01          TST      r8,#1
000698  d105              BNE      |L1.1702|
;;;652              pRect->x1 = rWinClipped.x0-1;
00069a  f8bd0000          LDRH     r0,[sp,#0]
00069e  1e40              SUBS     r0,r0,#1
0006a0  b200              SXTH     r0,r0
0006a2  80a8              STRH     r0,[r5,#4]
0006a4  e011              B        |L1.1738|
                  |L1.1702|
;;;653            } else {
;;;654              /* Check all children */
;;;655              WM_HWIN hChild;
;;;656              WM_Obj* pChild;
;;;657              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
0006a6  f9b49018          LDRSH    r9,[r4,#0x18]
0006aa  e00a              B        |L1.1730|
                  |L1.1708|
;;;658                pChild = WM_H2P(hChild);
0006ac  4648              MOV      r0,r9
0006ae  f7fffffe          BL       GUI_ALLOC_h2p
0006b2  4682              MOV      r10,r0
;;;659                _Findx1(hChild, pRect, &rWinClipped);
0006b4  466a              MOV      r2,sp
0006b6  4629              MOV      r1,r5
0006b8  4648              MOV      r0,r9
0006ba  f7fffffe          BL       _Findx1
0006be  f9ba901a          LDRSH    r9,[r10,#0x1a]        ;657
                  |L1.1730|
0006c2  f1b90f00          CMP      r9,#0                 ;657
0006c6  d1f1              BNE      |L1.1708|
;;;660              }
;;;661            }
0006c8  bf00              NOP      
                  |L1.1738|
;;;662          }
;;;663        }
0006ca  bf00              NOP      
                  |L1.1740|
0006cc  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;640
                  |L1.1744|
0006d0  2e00              CMP      r6,#0                 ;640
0006d2  d1c6              BNE      |L1.1634|
;;;664      }
;;;665    }
0006d4  e8bd87fc          POP      {r2-r10,pc}
;;;666    
                          ENDP

                  WM__GetClientRectWin PROC
;;;707    */
;;;708    void WM__GetClientRectWin(const WM_Obj* pWin, GUI_RECT* pRect) {
0006d8  2200              MOVS     r2,#0
;;;709      pRect->x0 = pRect->y0 = 0;
0006da  804a              STRH     r2,[r1,#2]
0006dc  800a              STRH     r2,[r1,#0]
;;;710      pRect->x1 = pWin->Rect.x1 - pWin->Rect.x0;
0006de  8882              LDRH     r2,[r0,#4]
0006e0  8803              LDRH     r3,[r0,#0]
0006e2  1ad2              SUBS     r2,r2,r3
0006e4  b212              SXTH     r2,r2
0006e6  808a              STRH     r2,[r1,#4]
;;;711      pRect->y1 = pWin->Rect.y1 - pWin->Rect.y0;
0006e8  88c2              LDRH     r2,[r0,#6]
0006ea  8843              LDRH     r3,[r0,#2]
0006ec  1ad2              SUBS     r2,r2,r3
0006ee  b212              SXTH     r2,r2
0006f0  80ca              STRH     r2,[r1,#6]
;;;712    }
0006f2  4770              BX       lr
;;;713    
                          ENDP

                  WM__GetInvalidRectAbs PROC
;;;717    */
;;;718    static void WM__GetInvalidRectAbs(WM_Obj* pWin, GUI_RECT* pRect) {
0006f4  6882              LDR      r2,[r0,#8]
;;;719      *pRect = pWin->InvalidRect;
0006f6  600a              STR      r2,[r1,#0]
0006f8  68c2              LDR      r2,[r0,#0xc]
0006fa  604a              STR      r2,[r1,#4]
;;;720    }
0006fc  4770              BX       lr
;;;721    
                          ENDP

                  WM_InvalidateRect PROC
;;;735    */
;;;736    void WM_InvalidateRect(WM_HWIN hWin, const GUI_RECT*pRect) {
0006fe  e92d41ff          PUSH     {r0-r8,lr}
000702  4605              MOV      r5,r0
000704  460e              MOV      r6,r1
;;;737      GUI_RECT r;
;;;738      WM_Obj* pWin;
;;;739      int Status;
;;;740      if (hWin) {
000706  b385              CBZ      r5,|L1.1898|
;;;741        WM_LOCK();
000708  f7fffffe          BL       GUI_Lock
;;;742        pWin = WM_H2P(hWin);
00070c  4628              MOV      r0,r5
00070e  f7fffffe          BL       GUI_ALLOC_h2p
000712  4604              MOV      r4,r0
;;;743        Status = pWin->Status;
000714  8ba7              LDRH     r7,[r4,#0x1c]
;;;744        if (Status & WM_SF_ISVIS) {
000716  f0170f02          TST      r7,#2
00071a  d024              BEQ      |L1.1894|
;;;745          r = pWin->Rect;
00071c  e9d40100          LDRD     r0,r1,[r4,#0]
000720  e9cd0102          STRD     r0,r1,[sp,#8]
;;;746          if (pRect) {
000724  b166              CBZ      r6,|L1.1856|
;;;747            GUI_RECT rPara;
;;;748            rPara = *pRect;
000726  6830              LDR      r0,[r6,#0]
000728  9000              STR      r0,[sp,#0]
00072a  6870              LDR      r0,[r6,#4]
00072c  9001              STR      r0,[sp,#4]
;;;749            WM__Client2Screen(pWin, &rPara);
00072e  4669              MOV      r1,sp
000730  4620              MOV      r0,r4
000732  f7fffffe          BL       WM__Client2Screen
;;;750            GUI__IntersectRect(&r, &rPara);
000736  4669              MOV      r1,sp
000738  a802              ADD      r0,sp,#8
00073a  f7fffffe          BL       GUI__IntersectRect
;;;751          }
00073e  bf00              NOP      
                  |L1.1856|
;;;752          if (WM__ClipAtParentBorders(&r, hWin)) {      /* Optimization that saves invalidation if window area is not visible ... Not required */
000740  4629              MOV      r1,r5
000742  a802              ADD      r0,sp,#8
000744  f7fffffe          BL       WM__ClipAtParentBorders
000748  b168              CBZ      r0,|L1.1894|
;;;753            if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
00074a  f6400001          MOV      r0,#0x801
00074e  4038              ANDS     r0,r0,r7
000750  2801              CMP      r0,#1
000752  d104              BNE      |L1.1886|
;;;754              WM__InvalidateAreaBelow(&r, hWin);        /* Can be optimized to spare windows above */
000754  4629              MOV      r1,r5
000756  a802              ADD      r0,sp,#8
000758  f7fffffe          BL       WM__InvalidateAreaBelow
00075c  e003              B        |L1.1894|
                  |L1.1886|
;;;755            } else {
;;;756              _Invalidate1Abs(hWin, &r);
00075e  a902              ADD      r1,sp,#8
000760  4628              MOV      r0,r5
000762  f7fffffe          BL       _Invalidate1Abs
                  |L1.1894|
;;;757            }
;;;758          }
;;;759        }
;;;760        WM_UNLOCK();
000766  f7fffffe          BL       GUI_Unlock
                  |L1.1898|
;;;761      }
;;;762    }
00076a  e8bd81ff          POP      {r0-r8,pc}
;;;763    
                          ENDP

                  WM_InvalidateWindow PROC
;;;769    */
;;;770    void WM_InvalidateWindow(WM_HWIN hWin) {
00076e  b510              PUSH     {r4,lr}
000770  4604              MOV      r4,r0
;;;771      WM_InvalidateRect(hWin, NULL);
000772  2100              MOVS     r1,#0
000774  4620              MOV      r0,r4
000776  f7fffffe          BL       WM_InvalidateRect
;;;772    }
00077a  bd10              POP      {r4,pc}
;;;773    
                          ENDP

                  WM_CreateWindowAsChild PROC
;;;801    */
;;;802    WM_HWIN WM_CreateWindowAsChild( int x0, int y0, int width, int height
00077c  e92d4ff8          PUSH     {r3-r11,lr}
;;;803                                   ,WM_HWIN hParent, U16 Style, WM_CALLBACK* cb
;;;804                                   ,int NumExtraBytes) {
000780  4680              MOV      r8,r0
000782  4689              MOV      r9,r1
000784  4692              MOV      r10,r2
000786  469b              MOV      r11,r3
000788  e9dd750a          LDRD     r7,r5,[sp,#0x28]
;;;805      WM_Obj* pWin;
;;;806      WM_HWIN hWin;
;;;807      WM_ASSERT_NOT_IN_PAINT();
;;;808      WM_LOCK();
00078c  f7fffffe          BL       GUI_Lock
;;;809      Style |= WM__CreateFlags;
000790  4829              LDR      r0,|L1.2104|
000792  8800              LDRH     r0,[r0,#0]  ; WM__CreateFlags
000794  4305              ORRS     r5,r5,r0
;;;810      /* Default parent is Desktop 0 */
;;;811      if (!hParent) {
000796  b92f              CBNZ     r7,|L1.1956|
;;;812        if (WM__NumWindows) {
000798  4825              LDR      r0,|L1.2096|
00079a  8800              LDRH     r0,[r0,#0]  ; WM__NumWindows
00079c  b110              CBZ      r0,|L1.1956|
;;;813        #if GUI_NUM_LAYERS == 1
;;;814          hParent = WM__ahDesktopWin[0];
00079e  4827              LDR      r0,|L1.2108|
0007a0  f9b07000          LDRSH    r7,[r0,#0]  ; WM__ahDesktopWin
                  |L1.1956|
;;;815        #else
;;;816          hParent = WM__ahDesktopWin[GUI_Context.SelLayer];
;;;817        #endif
;;;818        }
;;;819      }
;;;820      if (hParent == WM_UNATTACHED) {
0007a4  1c78              ADDS     r0,r7,#1
0007a6  d100              BNE      |L1.1962|
;;;821        hParent = WM_HWIN_NULL;
0007a8  2700              MOVS     r7,#0
                  |L1.1962|
;;;822      }  
;;;823      if (hParent) {
0007aa  b1f7              CBZ      r7,|L1.2026|
;;;824        WM_Obj* pParent = WM_H2P(hParent);
0007ac  4638              MOV      r0,r7
0007ae  f7fffffe          BL       GUI_ALLOC_h2p
0007b2  4606              MOV      r6,r0
;;;825        x0 += pParent->Rect.x0;
0007b4  f9b60000          LDRSH    r0,[r6,#0]
0007b8  4480              ADD      r8,r8,r0
;;;826        y0 += pParent->Rect.y0;
0007ba  f9b60002          LDRSH    r0,[r6,#2]
0007be  4481              ADD      r9,r9,r0
;;;827        if (width==0) {
0007c0  f1ba0f00          CMP      r10,#0
0007c4  d106              BNE      |L1.2004|
;;;828          width = pParent->Rect.x1 - pParent->Rect.x0+1;
0007c6  f9b60004          LDRSH    r0,[r6,#4]
0007ca  f9b61000          LDRSH    r1,[r6,#0]
0007ce  1a40              SUBS     r0,r0,r1
0007d0  f1000a01          ADD      r10,r0,#1
                  |L1.2004|
;;;829        }
;;;830        if (height==0) {
0007d4  f1bb0f00          CMP      r11,#0
0007d8  d106              BNE      |L1.2024|
;;;831          height = pParent->Rect.y1 - pParent->Rect.y0+1;
0007da  f9b60006          LDRSH    r0,[r6,#6]
0007de  f9b61002          LDRSH    r1,[r6,#2]
0007e2  1a40              SUBS     r0,r0,r1
0007e4  f1000b01          ADD      r11,r0,#1
                  |L1.2024|
;;;832        }
;;;833      }
0007e8  bf00              NOP      
                  |L1.2026|
;;;834      if ((hWin = (WM_HWIN) GUI_ALLOC_AllocZero(NumExtraBytes + sizeof(WM_Obj))) == 0) {
0007ea  980d              LDR      r0,[sp,#0x34]
0007ec  3020              ADDS     r0,r0,#0x20
0007ee  b200              SXTH     r0,r0
0007f0  f7fffffe          BL       GUI_ALLOC_AllocZero
0007f4  9000              STR      r0,[sp,#0]
0007f6  2800              CMP      r0,#0
0007f8  d05a              BEQ      |L1.2224|
;;;835        GUI_DEBUG_ERROROUT("WM_CreateWindow: No memory to create window");
;;;836      } else {
;;;837        WM__NumWindows++;
0007fa  480d              LDR      r0,|L1.2096|
0007fc  8800              LDRH     r0,[r0,#0]  ; WM__NumWindows
0007fe  1c40              ADDS     r0,r0,#1
000800  490b              LDR      r1,|L1.2096|
000802  8008              STRH     r0,[r1,#0]
;;;838        pWin = WM_H2P(hWin);
000804  9800              LDR      r0,[sp,#0]
000806  f7fffffe          BL       GUI_ALLOC_h2p
00080a  4604              MOV      r4,r0
;;;839        pWin->Rect.x0 = x0;
00080c  fa0ff088          SXTH     r0,r8
000810  8020              STRH     r0,[r4,#0]
;;;840        pWin->Rect.y0 = y0;
000812  fa0ff089          SXTH     r0,r9
000816  8060              STRH     r0,[r4,#2]
;;;841        pWin->Rect.x1 = x0 + width - 1;
000818  eb08000a          ADD      r0,r8,r10
00081c  1e40              SUBS     r0,r0,#1
00081e  e00f              B        |L1.2112|
                  |L1.2080|
                          DCD      WM__hWinFocus
                  |L1.2084|
                          DCD      WM__hCapture
                  |L1.2088|
                          DCD      WM__TransWindowCnt
                  |L1.2092|
                          DCD      WM__NumInvalidWindows
                  |L1.2096|
                          DCD      WM__NumWindows
                  |L1.2100|
                          DCD      WM__FirstWin
                  |L1.2104|
                          DCD      WM__CreateFlags
                  |L1.2108|
                          DCD      WM__ahDesktopWin
                  |L1.2112|
000840  b200              SXTH     r0,r0
000842  80a0              STRH     r0,[r4,#4]
;;;842        pWin->Rect.y1 = y0 + height - 1;
000844  eb09000b          ADD      r0,r9,r11
000848  1e40              SUBS     r0,r0,#1
00084a  b200              SXTH     r0,r0
00084c  80e0              STRH     r0,[r4,#6]
;;;843        pWin->cb = cb;
00084e  980c              LDR      r0,[sp,#0x30]
000850  6120              STR      r0,[r4,#0x10]
;;;844        /* Copy the flags which can simply be accepted */
;;;845        pWin->Status |= (Style & (WM_CF_SHOW |
000852  8ba0              LDRH     r0,[r4,#0x1c]
000854  f643718f          MOV      r1,#0x3f8f
000858  4029              ANDS     r1,r1,r5
00085a  4308              ORRS     r0,r0,r1
00085c  83a0              STRH     r0,[r4,#0x1c]
;;;846                                  WM_SF_MEMDEV |
;;;847                                  WM_CF_MEMDEV_ON_REDRAW |
;;;848                                  WM_SF_STAYONTOP |
;;;849                                  WM_SF_CONST_OUTLINE |
;;;850                                  WM_SF_HASTRANS |
;;;851                                  WM_CF_ANCHOR_RIGHT |
;;;852                                  WM_CF_ANCHOR_BOTTOM |
;;;853                                  WM_CF_ANCHOR_LEFT |
;;;854                                  WM_CF_ANCHOR_TOP |
;;;855                                  WM_CF_LATE_CLIP));
;;;856        /* Add to linked lists */
;;;857        _AddToLinList(hWin);
00085e  9800              LDR      r0,[sp,#0]
000860  f7fffffe          BL       _AddToLinList
;;;858        WM__InsertWindowIntoList(hWin, hParent);
000864  4639              MOV      r1,r7
000866  9800              LDR      r0,[sp,#0]
000868  f7fffffe          BL       WM__InsertWindowIntoList
;;;859        /* Activate window if WM_CF_ACTIVATE is specified */
;;;860        if (Style & WM_CF_ACTIVATE) {
00086c  f0150f20          TST      r5,#0x20
000870  d002              BEQ      |L1.2168|
;;;861          WM_SelectWindow(hWin);  /* This is not needed if callbacks are being used, but it does not cost a lot and makes life easier ... */
000872  9800              LDR      r0,[sp,#0]
000874  f7fffffe          BL       WM_SelectWindow
                  |L1.2168|
;;;862        }
;;;863        /* Handle the Style flags, one at a time */
;;;864        #if WM_SUPPORT_TRANSPARENCY
;;;865          if (Style & WM_SF_HASTRANS) {
000878  f0150f01          TST      r5,#1
00087c  d004              BEQ      |L1.2184|
;;;866            WM__TransWindowCnt++;          /* Increment counter for transparency windows */
00087e  48fe              LDR      r0,|L1.3192|
000880  6800              LDR      r0,[r0,#0]  ; WM__TransWindowCnt
000882  1c40              ADDS     r0,r0,#1
000884  49fc              LDR      r1,|L1.3192|
000886  6008              STR      r0,[r1,#0]  ; WM__TransWindowCnt
                  |L1.2184|
;;;867          }
;;;868        #endif
;;;869        if (Style & WM_CF_BGND) {
000888  f0150f40          TST      r5,#0x40
00088c  d002              BEQ      |L1.2196|
;;;870          WM_BringToBottom(hWin);
00088e  9800              LDR      r0,[sp,#0]
000890  f7fffffe          BL       WM_BringToBottom
                  |L1.2196|
;;;871        }
;;;872        if (Style & WM_CF_SHOW) {
000894  f0150f02          TST      r5,#2
000898  d006              BEQ      |L1.2216|
;;;873          pWin->Status |= WM_SF_ISVIS;  /* Set Visibility flag */
00089a  8ba0              LDRH     r0,[r4,#0x1c]
00089c  f0400002          ORR      r0,r0,#2
0008a0  83a0              STRH     r0,[r4,#0x1c]
;;;874          WM_InvalidateWindow(hWin);    /* Mark content as invalid */
0008a2  9800              LDR      r0,[sp,#0]
0008a4  f7fffffe          BL       WM_InvalidateWindow
                  |L1.2216|
;;;875        }
;;;876        WM__SendMsgNoData(hWin, WM_CREATE);
0008a8  2101              MOVS     r1,#1
0008aa  9800              LDR      r0,[sp,#0]
0008ac  f7fffffe          BL       WM__SendMsgNoData
                  |L1.2224|
;;;877      }
;;;878      WM_UNLOCK();
0008b0  f7fffffe          BL       GUI_Unlock
;;;879      return hWin;
0008b4  9800              LDR      r0,[sp,#0]
;;;880    }
0008b6  e8bd8ff8          POP      {r3-r11,pc}
;;;881    
                          ENDP

                  WM_CreateWindow PROC
;;;885    */
;;;886    WM_HWIN WM_CreateWindow(int x0, int y0, int width, int height, U16 Style, WM_CALLBACK* cb, int NumExtraBytes) {
0008ba  e92d47ff          PUSH     {r0-r10,lr}
0008be  4604              MOV      r4,r0
0008c0  460d              MOV      r5,r1
0008c2  4616              MOV      r6,r2
0008c4  461f              MOV      r7,r3
0008c6  e9dd9a0d          LDRD     r9,r10,[sp,#0x34]
0008ca  f8dd8030          LDR      r8,[sp,#0x30]
;;;887      return WM_CreateWindowAsChild(x0,y0,width,height, 0 /* No parent */,  Style, cb, NumExtraBytes);
0008ce  2000              MOVS     r0,#0
0008d0  463b              MOV      r3,r7
0008d2  4632              MOV      r2,r6
0008d4  4629              MOV      r1,r5
0008d6  e88d0701          STM      sp,{r0,r8-r10}
0008da  4620              MOV      r0,r4
0008dc  f7fffffe          BL       WM_CreateWindowAsChild
;;;888    }
0008e0  b004              ADD      sp,sp,#0x10
0008e2  e8bd87f0          POP      {r4-r10,pc}
;;;889    
                          ENDP

                  WM_GetActiveWindow PROC
;;;993    */
;;;994    WM_HWIN WM_GetActiveWindow(void) {
0008e6  48e5              LDR      r0,|L1.3196|
;;;995      return GUI_Context.hAWin;
0008e8  f9b0003c          LDRSH    r0,[r0,#0x3c]  ; GUI_Context
;;;996    }
0008ec  4770              BX       lr
;;;997    
                          ENDP

                  _FindNext_IVR PROC
;;;1028   #if WM_SUPPORT_OBSTRUCT
;;;1029   static int _FindNext_IVR(void) {
0008ee  b57c              PUSH     {r2-r6,lr}
;;;1030     WM_HMEM hParent;
;;;1031     GUI_RECT r;
;;;1032     WM_Obj* pAWin;
;;;1033     WM_Obj* pParent;
;;;1034     r = _ClipContext.CurRect;  /* temps  so we do not have to work with pointers too much */
0008f0  49e3              LDR      r1,|L1.3200|
0008f2  e9d10102          LDRD     r0,r1,[r1,#8]
0008f6  e9cd0100          STRD     r0,r1,[sp,#0]
;;;1035     /*
;;;1036        STEP 1:
;;;1037          Set the next position which could be part of the next IVR
;;;1038          This will be the first unhandle pixel in reading order, i.e. next one to the right
;;;1039          or next one down if we are at the right border.
;;;1040     */
;;;1041     if (_ClipContext.Cnt == 0) {       /* First IVR starts in upper left */
0008fa  48e1              LDR      r0,|L1.3200|
0008fc  6900              LDR      r0,[r0,#0x10]  ; _ClipContext
0008fe  b940              CBNZ     r0,|L1.2322|
;;;1042       r.x0 = _ClipContext.ClientRect.x0;
000900  48df              LDR      r0,|L1.3200|
000902  8800              LDRH     r0,[r0,#0]  ; _ClipContext
000904  f8ad0000          STRH     r0,[sp,#0]
;;;1043       r.y0 = _ClipContext.ClientRect.y0;
000908  48dd              LDR      r0,|L1.3200|
00090a  8840              LDRH     r0,[r0,#2]  ; _ClipContext
00090c  f8ad0002          STRH     r0,[sp,#2]
000910  e01b              B        |L1.2378|
                  |L1.2322|
;;;1044     } else {
;;;1045       r.x0 = _ClipContext.CurRect.x1+1;
000912  48db              LDR      r0,|L1.3200|
000914  8980              LDRH     r0,[r0,#0xc]
000916  1c40              ADDS     r0,r0,#1
000918  b200              SXTH     r0,r0
00091a  f8ad0000          STRH     r0,[sp,#0]
;;;1046       r.y0 = _ClipContext.CurRect.y0;
00091e  48d8              LDR      r0,|L1.3200|
000920  8940              LDRH     r0,[r0,#0xa]
000922  f8ad0002          STRH     r0,[sp,#2]
;;;1047       if (r.x0 > _ClipContext.ClientRect.x1) {
000926  f9bd0000          LDRSH    r0,[sp,#0]
00092a  49d5              LDR      r1,|L1.3200|
00092c  f9b11004          LDRSH    r1,[r1,#4]  ; _ClipContext
000930  4288              CMP      r0,r1
000932  dd0a              BLE      |L1.2378|
;;;1048   NextStripe:  /* go down to next stripe */
000934  bf00              NOP      
                  |L1.2358|
;;;1049         r.x0 = _ClipContext.ClientRect.x0;
000936  48d2              LDR      r0,|L1.3200|
000938  8800              LDRH     r0,[r0,#0]  ; _ClipContext
00093a  f8ad0000          STRH     r0,[sp,#0]
;;;1050         r.y0 = _ClipContext.CurRect.y1+1;
00093e  48d0              LDR      r0,|L1.3200|
000940  89c0              LDRH     r0,[r0,#0xe]
000942  1c40              ADDS     r0,r0,#1
000944  b200              SXTH     r0,r0
000946  f8ad0002          STRH     r0,[sp,#2]
                  |L1.2378|
;;;1051       }
;;;1052     }
;;;1053     /*
;;;1054        STEP 2:
;;;1055          Check if we are done completely.
;;;1056     */
;;;1057     if (r.y0 >_ClipContext.ClientRect.y1) {
00094a  f9bd0002          LDRSH    r0,[sp,#2]
00094e  49cc              LDR      r1,|L1.3200|
000950  f9b11006          LDRSH    r1,[r1,#6]  ; _ClipContext
000954  4288              CMP      r0,r1
000956  dd01              BLE      |L1.2396|
;;;1058       return 0;
000958  2000              MOVS     r0,#0
                  |L1.2394|
;;;1059     }
;;;1060     /* STEP 3:
;;;1061          Find out the max. height (r.y1) if we are at the left border.
;;;1062          Since we are using the same height for all IVRs at the same y0,
;;;1063          we do this only for the leftmost one.
;;;1064     */
;;;1065     pAWin = WM_H2P(GUI_Context.hAWin);
;;;1066     if (r.x0 == _ClipContext.ClientRect.x0) {
;;;1067       r.y1 = _ClipContext.ClientRect.y1;
;;;1068       r.x1 = _ClipContext.ClientRect.x1;
;;;1069       /* Iterate over all windows which are above */
;;;1070       /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
;;;1071       for (hParent = GUI_Context.hAWin; hParent; hParent = pParent->hParent) {
;;;1072         pParent = WM_H2P(hParent);
;;;1073         _Findy1(pParent->hNext, &r, NULL);
;;;1074       }
;;;1075       /* Check all children */
;;;1076       _Findy1(pAWin->hFirstChild, &r, NULL);
;;;1077     }
;;;1078     /* 
;;;1079       STEP 4
;;;1080         Find out x0 for the given y0, y1 by iterating over windows above.
;;;1081         if we find one that intersects, adjust x0 to the right.
;;;1082     */
;;;1083   Find_x0:
;;;1084     r.x1 = r.x0;
;;;1085     /* Iterate over all windows which are above */
;;;1086     /* Check all siblings above (siblings of window, siblings of parents, etc ...) */
;;;1087     #if 0   /* This is a planned, but not yet released optimization */
;;;1088       if (Status & WM_SF_DONT_CLIP_SIBLINGS)
;;;1089       {
;;;1090         hParent = pAWin->hParent;
;;;1091       } else
;;;1092     #endif
;;;1093     {
;;;1094       hParent = GUI_Context.hAWin;
;;;1095     }
;;;1096     for (; hParent; hParent = pParent->hParent) {
;;;1097       pParent = WM_H2P(hParent);
;;;1098       if (_Findx0(pParent->hNext, &r, NULL)) {
;;;1099         goto Find_x0;
;;;1100       }
;;;1101     }
;;;1102     /* Check all children */
;;;1103     if (_Findx0(pAWin->hFirstChild, &r, NULL)) {
;;;1104       goto Find_x0;
;;;1105     }
;;;1106     /* 
;;;1107      STEP 5:
;;;1108        If r.x0 out of right border, this stripe is done. Set next stripe and goto STEP 2
;;;1109        Find out x1 for the given x0, y0, y1
;;;1110     */
;;;1111     r.x1 = _ClipContext.ClientRect.x1;
;;;1112     if (r.x1 < r.x0) {/* horizontal border reached ? */
;;;1113       _ClipContext.CurRect = r;
;;;1114       goto NextStripe;
;;;1115     }    
;;;1116     /* 
;;;1117      STEP 6:
;;;1118        Find r.x1. We have to Iterate over all windows which are above
;;;1119     */
;;;1120     /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
;;;1121     #if 0   /* This is a planned, but not yet released optimization */
;;;1122       if (Status & WM_SF_DONT_CLIP_SIBLINGS)
;;;1123       {
;;;1124         hParent = pAWin->hParent;
;;;1125       } else
;;;1126     #endif
;;;1127     {
;;;1128       hParent = GUI_Context.hAWin;
;;;1129     }
;;;1130     for (; hParent; hParent = pParent->hParent) {
;;;1131       pParent = WM_H2P(hParent);
;;;1132       _Findx1(pParent->hNext, &r, NULL);
;;;1133     }
;;;1134     /* Check all children */
;;;1135     _Findx1(pAWin->hFirstChild, &r, NULL);
;;;1136     /* We are done. Return the rectangle we found in the _ClipContext. */
;;;1137     if (_ClipContext.Cnt >200) {
;;;1138       return 0;  /* error !!! This should not happen !*/
;;;1139     }
;;;1140     _ClipContext.CurRect = r;
;;;1141     return 1;  /* IVR is valid ! */
;;;1142   }
00095a  bd7c              POP      {r2-r6,pc}
                  |L1.2396|
00095c  49c7              LDR      r1,|L1.3196|
00095e  f9b1003c          LDRSH    r0,[r1,#0x3c]         ;1065  ; GUI_Context
000962  f7fffffe          BL       GUI_ALLOC_h2p
000966  4605              MOV      r5,r0                 ;1065
000968  f9bd0000          LDRSH    r0,[sp,#0]            ;1066
00096c  49c4              LDR      r1,|L1.3200|
00096e  f9b11000          LDRSH    r1,[r1,#0]            ;1066  ; _ClipContext
000972  4288              CMP      r0,r1                 ;1066
000974  d11f              BNE      |L1.2486|
000976  48c2              LDR      r0,|L1.3200|
000978  88c0              LDRH     r0,[r0,#6]            ;1067  ; _ClipContext
00097a  f8ad0006          STRH     r0,[sp,#6]            ;1067
00097e  48c0              LDR      r0,|L1.3200|
000980  8880              LDRH     r0,[r0,#4]            ;1068  ; _ClipContext
000982  f8ad0004          STRH     r0,[sp,#4]            ;1068
000986  48bd              LDR      r0,|L1.3196|
000988  f9b0603c          LDRSH    r6,[r0,#0x3c]         ;1071  ; GUI_Context
00098c  e00b              B        |L1.2470|
                  |L1.2446|
00098e  4630              MOV      r0,r6                 ;1072
000990  f7fffffe          BL       GUI_ALLOC_h2p
000994  4604              MOV      r4,r0                 ;1072
000996  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1073
00099a  2200              MOVS     r2,#0                 ;1073
00099c  4669              MOV      r1,sp                 ;1073
00099e  f7fffffe          BL       _Findy1
0009a2  f9b46016          LDRSH    r6,[r4,#0x16]         ;1071
                  |L1.2470|
0009a6  2e00              CMP      r6,#0                 ;1071
0009a8  d1f1              BNE      |L1.2446|
0009aa  f9b50018          LDRSH    r0,[r5,#0x18]         ;1076
0009ae  2200              MOVS     r2,#0                 ;1076
0009b0  4669              MOV      r1,sp                 ;1076
0009b2  f7fffffe          BL       _Findy1
                  |L1.2486|
0009b6  bf00              NOP                            ;1083
                  |L1.2488|
0009b8  f8bd0000          LDRH     r0,[sp,#0]            ;1084
0009bc  f8ad0004          STRH     r0,[sp,#4]            ;1084
0009c0  48ae              LDR      r0,|L1.3196|
0009c2  f9b0603c          LDRSH    r6,[r0,#0x3c]         ;1094  ; GUI_Context
0009c6  e00d              B        |L1.2532|
                  |L1.2504|
0009c8  4630              MOV      r0,r6                 ;1097
0009ca  f7fffffe          BL       GUI_ALLOC_h2p
0009ce  4604              MOV      r4,r0                 ;1097
0009d0  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1098
0009d4  2200              MOVS     r2,#0                 ;1098
0009d6  4669              MOV      r1,sp                 ;1098
0009d8  f7fffffe          BL       _Findx0
0009dc  b100              CBZ      r0,|L1.2528|
0009de  e7eb              B        |L1.2488|
                  |L1.2528|
0009e0  f9b46016          LDRSH    r6,[r4,#0x16]         ;1096
                  |L1.2532|
0009e4  2e00              CMP      r6,#0                 ;1096
0009e6  d1ef              BNE      |L1.2504|
0009e8  f9b50018          LDRSH    r0,[r5,#0x18]         ;1103
0009ec  2200              MOVS     r2,#0                 ;1103
0009ee  4669              MOV      r1,sp                 ;1103
0009f0  f7fffffe          BL       _Findx0
0009f4  b100              CBZ      r0,|L1.2552|
0009f6  e7df              B        |L1.2488|
                  |L1.2552|
0009f8  48a1              LDR      r0,|L1.3200|
0009fa  8880              LDRH     r0,[r0,#4]            ;1111  ; _ClipContext
0009fc  f8ad0004          STRH     r0,[sp,#4]            ;1111
000a00  f9bd0004          LDRSH    r0,[sp,#4]            ;1112
000a04  f9bd1000          LDRSH    r1,[sp,#0]            ;1112
000a08  4288              CMP      r0,r1                 ;1112
000a0a  da05              BGE      |L1.2584|
000a0c  489c              LDR      r0,|L1.3200|
000a0e  e9dd1200          LDRD     r1,r2,[sp,#0]         ;1113
000a12  e9c01202          STRD     r1,r2,[r0,#8]         ;1113
000a16  e78e              B        |L1.2358|
                  |L1.2584|
000a18  4898              LDR      r0,|L1.3196|
000a1a  f9b0603c          LDRSH    r6,[r0,#0x3c]         ;1128  ; GUI_Context
000a1e  e00b              B        |L1.2616|
                  |L1.2592|
000a20  4630              MOV      r0,r6                 ;1131
000a22  f7fffffe          BL       GUI_ALLOC_h2p
000a26  4604              MOV      r4,r0                 ;1131
000a28  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1132
000a2c  2200              MOVS     r2,#0                 ;1132
000a2e  4669              MOV      r1,sp                 ;1132
000a30  f7fffffe          BL       _Findx1
000a34  f9b46016          LDRSH    r6,[r4,#0x16]         ;1130
                  |L1.2616|
000a38  2e00              CMP      r6,#0                 ;1130
000a3a  d1f1              BNE      |L1.2592|
000a3c  f9b50018          LDRSH    r0,[r5,#0x18]         ;1135
000a40  2200              MOVS     r2,#0                 ;1135
000a42  4669              MOV      r1,sp                 ;1135
000a44  f7fffffe          BL       _Findx1
000a48  488d              LDR      r0,|L1.3200|
000a4a  6900              LDR      r0,[r0,#0x10]         ;1137  ; _ClipContext
000a4c  28c8              CMP      r0,#0xc8              ;1137
000a4e  dd01              BLE      |L1.2644|
000a50  2000              MOVS     r0,#0                 ;1138
000a52  e782              B        |L1.2394|
                  |L1.2644|
000a54  488a              LDR      r0,|L1.3200|
000a56  e9dd1200          LDRD     r1,r2,[sp,#0]         ;1140
000a5a  e9c01202          STRD     r1,r2,[r0,#8]         ;1140
000a5e  2001              MOVS     r0,#1                 ;1141
000a60  e77b              B        |L1.2394|
;;;1143   
                          ENDP

                  WM__GetNextIVR PROC
;;;1167   */
;;;1168   int  WM__GetNextIVR(void) {
000a62  b510              PUSH     {r4,lr}
;;;1169     #if GUI_SUPPORT_CURSOR
;;;1170       static char _CursorHidden;
;;;1171     #endif
;;;1172     /* If WM is not active, we have no rectangles to return */
;;;1173     if (WM_IsActive==0) {
000a64  4887              LDR      r0,|L1.3204|
000a66  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
000a68  b908              CBNZ     r0,|L1.2670|
;;;1174       return 0;
000a6a  2000              MOVS     r0,#0
                  |L1.2668|
;;;1175     }
;;;1176     if (_ClipContext.EntranceCnt > 1) {
;;;1177       _ClipContext.EntranceCnt--;
;;;1178       return 0;
;;;1179     }
;;;1180     #if GUI_SUPPORT_CURSOR
;;;1181       if (_CursorHidden) {
;;;1182         _CursorHidden = 0;
;;;1183         (*GUI_CURSOR_pfTempUnhide) ();
;;;1184       }
;;;1185     #endif
;;;1186     ++_ClipContext.Cnt;
;;;1187     /* Find next rectangle and use it as ClipRect */
;;;1188     if (!_FindNext_IVR()) {
;;;1189       _ClipContext.EntranceCnt--;  /* This search is over ! */
;;;1190       return 0;        /* Could not find an other one ! */
;;;1191     }
;;;1192     WM__ActivateClipRect();
;;;1193     /* Hide cursor if necessary */
;;;1194     #if GUI_SUPPORT_CURSOR
;;;1195       if (GUI_CURSOR_pfTempHide) {
;;;1196         _CursorHidden = (*GUI_CURSOR_pfTempHide) ( &_ClipContext.CurRect);
;;;1197       }
;;;1198     #endif
;;;1199     return 1;
;;;1200   }
000a6c  bd10              POP      {r4,pc}
                  |L1.2670|
000a6e  4884              LDR      r0,|L1.3200|
000a70  6940              LDR      r0,[r0,#0x14]         ;1176  ; _ClipContext
000a72  2801              CMP      r0,#1                 ;1176
000a74  dd06              BLE      |L1.2692|
000a76  4882              LDR      r0,|L1.3200|
000a78  6940              LDR      r0,[r0,#0x14]         ;1177  ; _ClipContext
000a7a  1e40              SUBS     r0,r0,#1              ;1177
000a7c  4980              LDR      r1,|L1.3200|
000a7e  6148              STR      r0,[r1,#0x14]         ;1177  ; _ClipContext
000a80  2000              MOVS     r0,#0                 ;1178
000a82  e7f3              B        |L1.2668|
                  |L1.2692|
000a84  4880              LDR      r0,|L1.3208|
000a86  7800              LDRB     r0,[r0,#0]            ;1181  ; _CursorHidden
000a88  b128              CBZ      r0,|L1.2710|
000a8a  2000              MOVS     r0,#0                 ;1182
000a8c  497e              LDR      r1,|L1.3208|
000a8e  7008              STRB     r0,[r1,#0]            ;1182
000a90  487e              LDR      r0,|L1.3212|
000a92  6800              LDR      r0,[r0,#0]            ;1183  ; GUI_CURSOR_pfTempUnhide
000a94  4780              BLX      r0                    ;1183
                  |L1.2710|
000a96  487a              LDR      r0,|L1.3200|
000a98  6900              LDR      r0,[r0,#0x10]         ;1186  ; _ClipContext
000a9a  1c40              ADDS     r0,r0,#1              ;1186
000a9c  4978              LDR      r1,|L1.3200|
000a9e  6108              STR      r0,[r1,#0x10]         ;1186  ; _ClipContext
000aa0  f7fffffe          BL       _FindNext_IVR
000aa4  b930              CBNZ     r0,|L1.2740|
000aa6  4876              LDR      r0,|L1.3200|
000aa8  6940              LDR      r0,[r0,#0x14]         ;1189  ; _ClipContext
000aaa  1e40              SUBS     r0,r0,#1              ;1189
000aac  4974              LDR      r1,|L1.3200|
000aae  6148              STR      r0,[r1,#0x14]         ;1189  ; _ClipContext
000ab0  2000              MOVS     r0,#0                 ;1190
000ab2  e7db              B        |L1.2668|
                  |L1.2740|
000ab4  f7fffffe          BL       WM__ActivateClipRect
000ab8  4875              LDR      r0,|L1.3216|
000aba  6800              LDR      r0,[r0,#0]            ;1195  ; GUI_CURSOR_pfTempHide
000abc  b130              CBZ      r0,|L1.2764|
000abe  4870              LDR      r0,|L1.3200|
000ac0  3008              ADDS     r0,r0,#8              ;1196
000ac2  4973              LDR      r1,|L1.3216|
000ac4  6809              LDR      r1,[r1,#0]            ;1196  ; GUI_CURSOR_pfTempHide
000ac6  4788              BLX      r1                    ;1196
000ac8  496f              LDR      r1,|L1.3208|
000aca  7008              STRB     r0,[r1,#0]            ;1196
                  |L1.2764|
000acc  2001              MOVS     r0,#1                 ;1199
000ace  e7cd              B        |L1.2668|
;;;1201   
                          ENDP

                  WM__InitIVRSearch PROC
;;;1213   */
;;;1214   int WM__InitIVRSearch(const GUI_RECT* pMaxRect) {
000ad0  b57f              PUSH     {r0-r6,lr}
000ad2  4605              MOV      r5,r0
;;;1215     GUI_RECT r;
;;;1216     WM_Obj* pAWin;
;;;1217     GUI_ASSERT_LOCK();   /* GUI_LOCK must have been "called" before entering this (normally done indrawing routine) */
;;;1218      /* If WM is not active -> nothing to do, leave cliprect alone */
;;;1219     if (WM_IsActive==0) {
000ad4  486b              LDR      r0,|L1.3204|
000ad6  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
000ad8  b920              CBNZ     r0,|L1.2788|
;;;1220       WM__ActivateClipRect();
000ada  f7fffffe          BL       WM__ActivateClipRect
;;;1221       return 1;
000ade  2001              MOVS     r0,#1
                  |L1.2784|
;;;1222     }
;;;1223     /* If we entered multiple times, leave Cliprect alone */
;;;1224     if (++_ClipContext.EntranceCnt > 1)
;;;1225       return 1;
;;;1226     pAWin = WM_H2P(GUI_Context.hAWin);
;;;1227     _ClipContext.Cnt        = -1;
;;;1228    /* When using callback mechanism, it is legal to reduce drawing
;;;1229       area to the invalid area ! */
;;;1230     if (WM__PaintCallbackCnt) {
;;;1231       WM__GetInvalidRectAbs(pAWin, &r);
;;;1232     } else {  /* Not using callback mechanism, therefor allow entire rectangle */
;;;1233       if (pAWin->Status & WM_SF_ISVIS) {
;;;1234         r = pAWin->Rect;
;;;1235       } else {
;;;1236         --_ClipContext.EntranceCnt;
;;;1237         return 0;  /* window is not even visible ! */
;;;1238       }
;;;1239     }
;;;1240     /* If the drawing routine has specified a rectangle, use it to reduce the rectangle */
;;;1241     if (pMaxRect) {
;;;1242       GUI__IntersectRect(&r, pMaxRect);
;;;1243     }
;;;1244     /* If user has reduced the cliprect size, reduce the rectangle */
;;;1245     if (GUI_Context.WM__pUserClipRect) {
;;;1246       WM_Obj* pWin = pAWin;
;;;1247       GUI_RECT rUser = *(GUI_Context.WM__pUserClipRect);
;;;1248       #if WM_SUPPORT_TRANSPARENCY
;;;1249         if (WM__hATransWindow) {
;;;1250           pWin = WM_H2P(WM__hATransWindow);
;;;1251         }   
;;;1252       #endif
;;;1253       WM__Client2Screen(pWin, &rUser);
;;;1254       GUI__IntersectRect(&r, &rUser);
;;;1255     }
;;;1256     /* For transparent windows, we need to further reduce the rectangle */
;;;1257     #if WM_SUPPORT_TRANSPARENCY
;;;1258       if (WM__hATransWindow) {
;;;1259         if (WM__ClipAtParentBorders(&r, WM__hATransWindow) == 0) {
;;;1260           --_ClipContext.EntranceCnt;
;;;1261           return 0;           /* Nothing to draw */
;;;1262         }
;;;1263       }
;;;1264     #endif
;;;1265     /* Iterate over all ancestors and clip at their borders. If there is no visible part, we are done */
;;;1266     if (WM__ClipAtParentBorders(&r, GUI_Context.hAWin) == 0) {
;;;1267       --_ClipContext.EntranceCnt;
;;;1268       return 0;           /* Nothing to draw */
;;;1269     }
;;;1270     /* Store the rectangle and find the first rectangle of the area */
;;;1271     _ClipContext.ClientRect = r;
;;;1272     return WM__GetNextIVR();
;;;1273   }
000ae0  b004              ADD      sp,sp,#0x10
000ae2  bd70              POP      {r4-r6,pc}
                  |L1.2788|
000ae4  4866              LDR      r0,|L1.3200|
000ae6  6940              LDR      r0,[r0,#0x14]         ;1224  ; _ClipContext
000ae8  1c40              ADDS     r0,r0,#1              ;1224
000aea  4965              LDR      r1,|L1.3200|
000aec  6148              STR      r0,[r1,#0x14]         ;1224  ; _ClipContext
000aee  2801              CMP      r0,#1                 ;1224
000af0  dd01              BLE      |L1.2806|
000af2  2001              MOVS     r0,#1                 ;1225
000af4  e7f4              B        |L1.2784|
                  |L1.2806|
000af6  4961              LDR      r1,|L1.3196|
000af8  f9b1003c          LDRSH    r0,[r1,#0x3c]         ;1226  ; GUI_Context
000afc  f7fffffe          BL       GUI_ALLOC_h2p
000b00  4604              MOV      r4,r0                 ;1226
000b02  f04f30ff          MOV      r0,#0xffffffff        ;1227
000b06  495e              LDR      r1,|L1.3200|
000b08  6108              STR      r0,[r1,#0x10]         ;1227  ; _ClipContext
000b0a  4862              LDR      r0,|L1.3220|
000b0c  7800              LDRB     r0,[r0,#0]            ;1230  ; WM__PaintCallbackCnt
000b0e  b120              CBZ      r0,|L1.2842|
000b10  a902              ADD      r1,sp,#8              ;1231
000b12  4620              MOV      r0,r4                 ;1231
000b14  f7fffffe          BL       WM__GetInvalidRectAbs
000b18  e00f              B        |L1.2874|
                  |L1.2842|
000b1a  8ba0              LDRH     r0,[r4,#0x1c]         ;1233
000b1c  f0100f02          TST      r0,#2                 ;1233
000b20  d004              BEQ      |L1.2860|
000b22  e9d40100          LDRD     r0,r1,[r4,#0]         ;1234
000b26  e9cd0102          STRD     r0,r1,[sp,#8]         ;1234
000b2a  e006              B        |L1.2874|
                  |L1.2860|
000b2c  4854              LDR      r0,|L1.3200|
000b2e  6940              LDR      r0,[r0,#0x14]         ;1236  ; _ClipContext
000b30  1e40              SUBS     r0,r0,#1              ;1236
000b32  4953              LDR      r1,|L1.3200|
000b34  6148              STR      r0,[r1,#0x14]         ;1236  ; _ClipContext
000b36  2000              MOVS     r0,#0                 ;1237
000b38  e7d2              B        |L1.2784|
                  |L1.2874|
000b3a  b11d              CBZ      r5,|L1.2884|
000b3c  4629              MOV      r1,r5                 ;1242
000b3e  a802              ADD      r0,sp,#8              ;1242
000b40  f7fffffe          BL       GUI__IntersectRect
                  |L1.2884|
000b44  484d              LDR      r0,|L1.3196|
000b46  6b80              LDR      r0,[r0,#0x38]         ;1245  ; GUI_Context
000b48  b1c0              CBZ      r0,|L1.2940|
000b4a  4626              MOV      r6,r4                 ;1246
000b4c  484b              LDR      r0,|L1.3196|
000b4e  6b80              LDR      r0,[r0,#0x38]         ;1247  ; GUI_Context
000b50  6801              LDR      r1,[r0,#0]            ;1247
000b52  9100              STR      r1,[sp,#0]            ;1247
000b54  6840              LDR      r0,[r0,#4]            ;1247
000b56  9001              STR      r0,[sp,#4]            ;1247
000b58  484f              LDR      r0,|L1.3224|
000b5a  8800              LDRH     r0,[r0,#0]            ;1249  ; WM__hATransWindow
000b5c  b128              CBZ      r0,|L1.2922|
000b5e  484e              LDR      r0,|L1.3224|
000b60  f9b00000          LDRSH    r0,[r0,#0]            ;1250  ; WM__hATransWindow
000b64  f7fffffe          BL       GUI_ALLOC_h2p
000b68  4606              MOV      r6,r0                 ;1250
                  |L1.2922|
000b6a  4669              MOV      r1,sp                 ;1253
000b6c  4630              MOV      r0,r6                 ;1253
000b6e  f7fffffe          BL       WM__Client2Screen
000b72  4669              MOV      r1,sp                 ;1254
000b74  a802              ADD      r0,sp,#8              ;1254
000b76  f7fffffe          BL       GUI__IntersectRect
000b7a  bf00              NOP                            ;1255
                  |L1.2940|
000b7c  4846              LDR      r0,|L1.3224|
000b7e  8800              LDRH     r0,[r0,#0]            ;1258  ; WM__hATransWindow
000b80  b168              CBZ      r0,|L1.2974|
000b82  4845              LDR      r0,|L1.3224|
000b84  f9b01000          LDRSH    r1,[r0,#0]            ;1259  ; WM__hATransWindow
000b88  a802              ADD      r0,sp,#8              ;1259
000b8a  f7fffffe          BL       WM__ClipAtParentBorders
000b8e  b930              CBNZ     r0,|L1.2974|
000b90  483b              LDR      r0,|L1.3200|
000b92  6940              LDR      r0,[r0,#0x14]         ;1260  ; _ClipContext
000b94  1e40              SUBS     r0,r0,#1              ;1260
000b96  493a              LDR      r1,|L1.3200|
000b98  6148              STR      r0,[r1,#0x14]         ;1260  ; _ClipContext
000b9a  2000              MOVS     r0,#0                 ;1261
000b9c  e7a0              B        |L1.2784|
                  |L1.2974|
000b9e  4837              LDR      r0,|L1.3196|
000ba0  f9b0103c          LDRSH    r1,[r0,#0x3c]         ;1266  ; GUI_Context
000ba4  a802              ADD      r0,sp,#8              ;1266
000ba6  f7fffffe          BL       WM__ClipAtParentBorders
000baa  b930              CBNZ     r0,|L1.3002|
000bac  4834              LDR      r0,|L1.3200|
000bae  6940              LDR      r0,[r0,#0x14]         ;1267  ; _ClipContext
000bb0  1e40              SUBS     r0,r0,#1              ;1267
000bb2  4933              LDR      r1,|L1.3200|
000bb4  6148              STR      r0,[r1,#0x14]         ;1267  ; _ClipContext
000bb6  2000              MOVS     r0,#0                 ;1268
000bb8  e792              B        |L1.2784|
                  |L1.3002|
000bba  4831              LDR      r0,|L1.3200|
000bbc  e9dd1202          LDRD     r1,r2,[sp,#8]         ;1271
000bc0  c006              STM      r0!,{r1,r2}           ;1271
000bc2  f7fffffe          BL       WM__GetNextIVR
000bc6  e78b              B        |L1.2784|
;;;1274   
                          ENDP

                  WM_SetDefault PROC
;;;1283   */
;;;1284   void WM_SetDefault(void) {
000bc8  b510              PUSH     {r4,lr}
;;;1285     GL_SetDefault();
000bca  f7fffffe          BL       GL_SetDefault
;;;1286     GUI_Context.WM__pUserClipRect = NULL;   /* No add. clipping */
000bce  2000              MOVS     r0,#0
000bd0  492a              LDR      r1,|L1.3196|
000bd2  6388              STR      r0,[r1,#0x38]  ; GUI_Context
;;;1287   }
000bd4  bd10              POP      {r4,pc}
;;;1288   
                          ENDP

                  _Paint1 PROC
;;;1292   */
;;;1293   static void _Paint1(WM_HWIN hWin, WM_Obj* pWin) {
000bd6  b5fe              PUSH     {r1-r7,lr}
000bd8  4605              MOV      r5,r0
000bda  460c              MOV      r4,r1
;;;1294     int Status = pWin->Status;
000bdc  8ba6              LDRH     r6,[r4,#0x1c]
;;;1295     /* Send WM_PAINT if window is visible and a callback is defined */
;;;1296     if ((pWin->cb != NULL)  && (Status & WM_SF_ISVIS)) {
000bde  6920              LDR      r0,[r4,#0x10]
000be0  2800              CMP      r0,#0
000be2  d035              BEQ      |L1.3152|
000be4  f0160f02          TST      r6,#2
000be8  d032              BEQ      |L1.3152|
;;;1297       WM_MESSAGE Msg;
;;;1298       WM__PaintCallbackCnt++;
000bea  482a              LDR      r0,|L1.3220|
000bec  7800              LDRB     r0,[r0,#0]  ; WM__PaintCallbackCnt
000bee  1c40              ADDS     r0,r0,#1
000bf0  4928              LDR      r1,|L1.3220|
000bf2  7008              STRB     r0,[r1,#0]
;;;1299       if (Status & WM_SF_LATE_CLIP) {
000bf4  f4165f80          TST      r6,#0x1000
000bf8  d00d              BEQ      |L1.3094|
;;;1300         Msg.hWin   = hWin;
000bfa  f8ad5004          STRH     r5,[sp,#4]
;;;1301         Msg.MsgId  = WM_PAINT;
000bfe  200f              MOVS     r0,#0xf
000c00  9000              STR      r0,[sp,#0]
;;;1302         Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
000c02  f1040008          ADD      r0,r4,#8
000c06  9002              STR      r0,[sp,#8]
;;;1303         WM_SetDefault();
000c08  f7fffffe          BL       WM_SetDefault
;;;1304         WM_SendMessage(hWin, &Msg);
000c0c  4669              MOV      r1,sp
000c0e  4628              MOV      r0,r5
000c10  f7fffffe          BL       WM_SendMessage
000c14  e016              B        |L1.3140|
                  |L1.3094|
;;;1305       } else {
;;;1306         WM_ITERATE_START(&pWin->InvalidRect) {
000c16  f1040008          ADD      r0,r4,#8
000c1a  f7fffffe          BL       WM__InitIVRSearch
000c1e  b188              CBZ      r0,|L1.3140|
000c20  bf00              NOP      
                  |L1.3106|
;;;1307           Msg.hWin   = hWin;
000c22  f8ad5004          STRH     r5,[sp,#4]
;;;1308           Msg.MsgId  = WM_PAINT;
000c26  200f              MOVS     r0,#0xf
000c28  9000              STR      r0,[sp,#0]
;;;1309           Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
000c2a  f1040008          ADD      r0,r4,#8
000c2e  9002              STR      r0,[sp,#8]
;;;1310           WM_SetDefault();
000c30  f7fffffe          BL       WM_SetDefault
;;;1311           WM_SendMessage(hWin, &Msg);
000c34  4669              MOV      r1,sp
000c36  4628              MOV      r0,r5
000c38  f7fffffe          BL       WM_SendMessage
;;;1312         } WM_ITERATE_END();
000c3c  f7fffffe          BL       WM__GetNextIVR
000c40  2800              CMP      r0,#0
000c42  d1ee              BNE      |L1.3106|
                  |L1.3140|
;;;1313       }
;;;1314       WM__PaintCallbackCnt--;
000c44  4813              LDR      r0,|L1.3220|
000c46  7800              LDRB     r0,[r0,#0]  ; WM__PaintCallbackCnt
000c48  1e40              SUBS     r0,r0,#1
000c4a  4912              LDR      r1,|L1.3220|
000c4c  7008              STRB     r0,[r1,#0]
;;;1315     }
000c4e  bf00              NOP      
                  |L1.3152|
;;;1316   }
000c50  bdfe              POP      {r1-r7,pc}
;;;1317   /*********************************************************************
                          ENDP

                  _Paint1Trans PROC
;;;1339   #if WM_SUPPORT_TRANSPARENCY
;;;1340   static int _Paint1Trans(WM_HWIN hWin, WM_Obj* pWin) {
000c52  e92d41f0          PUSH     {r4-r8,lr}
000c56  4605              MOV      r5,r0
000c58  460c              MOV      r4,r1
;;;1341     int xPrev, yPrev;
;;;1342     WM_Obj* pAWin = WM_H2P(GUI_Context.hAWin);
000c5a  4908              LDR      r1,|L1.3196|
000c5c  f9b1003c          LDRSH    r0,[r1,#0x3c]  ; GUI_Context
000c60  f7fffffe          BL       GUI_ALLOC_h2p
000c64  4680              MOV      r8,r0
;;;1343     /* Check if we need to do any drawing */
;;;1344     if (GUI_RectsIntersect(&pAWin->InvalidRect, &pWin->Rect)) {
000c66  4621              MOV      r1,r4
000c68  f1080008          ADD      r0,r8,#8
000c6c  f7fffffe          BL       GUI_RectsIntersect
000c70  b390              CBZ      r0,|L1.3288|
;;;1345       /* Save old values */
;;;1346       xPrev = GUI_Context.xOff;
000c72  4802              LDR      r0,|L1.3196|
000c74  6c06              LDR      r6,[r0,#0x40]  ; GUI_Context
;;;1347       yPrev = GUI_Context.yOff;
000c76  e011              B        |L1.3228|
                  |L1.3192|
                          DCD      WM__TransWindowCnt
                  |L1.3196|
                          DCD      GUI_Context
                  |L1.3200|
                          DCD      _ClipContext
                  |L1.3204|
                          DCD      WM_IsActive
                  |L1.3208|
                          DCD      _CursorHidden
                  |L1.3212|
                          DCD      GUI_CURSOR_pfTempUnhide
                  |L1.3216|
                          DCD      GUI_CURSOR_pfTempHide
                  |L1.3220|
                          DCD      WM__PaintCallbackCnt
                  |L1.3224|
                          DCD      WM__hATransWindow
                  |L1.3228|
000c9c  6c47              LDR      r7,[r0,#0x44]  ; GUI_Context
;;;1348       /* Set values for the current (transparent) window, rather than the one below */
;;;1349       GUI__IntersectRects(&pWin->InvalidRect, &pWin->Rect, &pAWin->InvalidRect);
000c9e  f1080208          ADD      r2,r8,#8
000ca2  4621              MOV      r1,r4
000ca4  f1040008          ADD      r0,r4,#8
000ca8  f7fffffe          BL       GUI__IntersectRects
;;;1350       WM__hATransWindow = hWin;
000cac  48d7              LDR      r0,|L1.4108|
000cae  8005              STRH     r5,[r0,#0]
;;;1351       GUI_Context.xOff = pWin->Rect.x0;
000cb0  f9b40000          LDRSH    r0,[r4,#0]
000cb4  49d6              LDR      r1,|L1.4112|
000cb6  6408              STR      r0,[r1,#0x40]  ; GUI_Context
;;;1352       GUI_Context.yOff = pWin->Rect.y0;
000cb8  f9b40002          LDRSH    r0,[r4,#2]
000cbc  6448              STR      r0,[r1,#0x44]  ; GUI_Context
;;;1353       /* Do the actual drawing ... */
;;;1354       _Paint1(hWin, pWin);
000cbe  4621              MOV      r1,r4
000cc0  4628              MOV      r0,r5
000cc2  f7fffffe          BL       _Paint1
;;;1355       /* Restore settings */
;;;1356       WM__hATransWindow = 0;
000cc6  2000              MOVS     r0,#0
000cc8  49d0              LDR      r1,|L1.4108|
000cca  8008              STRH     r0,[r1,#0]
;;;1357       GUI_Context.xOff = xPrev;
000ccc  48d0              LDR      r0,|L1.4112|
000cce  6406              STR      r6,[r0,#0x40]  ; GUI_Context
;;;1358       GUI_Context.yOff = yPrev;
000cd0  6447              STR      r7,[r0,#0x44]  ; GUI_Context
;;;1359       return 1;                       /* Some drawing took place */
000cd2  2001              MOVS     r0,#1
                  |L1.3284|
;;;1360     }
;;;1361     return 0;                         /* No invalid area, so nothing was drawn */
;;;1362   }
000cd4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3288|
000cd8  e7ff              B        |L1.3290|
                  |L1.3290|
000cda  2000              MOVS     r0,#0                 ;1361
000cdc  e7fa              B        |L1.3284|
;;;1363   #endif
                          ENDP

                  _PaintTransChildren PROC
;;;1376   #if WM_SUPPORT_TRANSPARENCY
;;;1377   static void _PaintTransChildren(WM_Obj* pWin) {
000cde  b57c              PUSH     {r2-r6,lr}
000ce0  4604              MOV      r4,r0
;;;1378     WM_HWIN hChild;
;;;1379     WM_Obj* pChild;
;;;1380     if (pWin->Status & WM_SF_ISVIS) {
000ce2  8ba0              LDRH     r0,[r4,#0x1c]
000ce4  f0100f02          TST      r0,#2
000ce8  d026              BEQ      |L1.3384|
;;;1381       for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
000cea  f9b46018          LDRSH    r6,[r4,#0x18]
000cee  e021              B        |L1.3380|
                  |L1.3312|
;;;1382         pChild = WM_H2P(hChild);
000cf0  4630              MOV      r0,r6
000cf2  f7fffffe          BL       GUI_ALLOC_h2p
000cf6  4605              MOV      r5,r0
;;;1383         if ((pChild->Status & (WM_SF_HASTRANS | WM_SF_ISVIS))   /* Transparent & visible ? */
000cf8  8ba8              LDRH     r0,[r5,#0x1c]
000cfa  f0000003          AND      r0,r0,#3
000cfe  2803              CMP      r0,#3
000d00  d116              BNE      |L1.3376|
;;;1384   		                ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
;;;1385           /* Set invalid area of the window to draw */
;;;1386           if (GUI_RectsIntersect(&pChild->Rect, &pWin->InvalidRect)) {
000d02  f1040108          ADD      r1,r4,#8
000d06  4628              MOV      r0,r5
000d08  f7fffffe          BL       GUI_RectsIntersect
000d0c  b180              CBZ      r0,|L1.3376|
;;;1387             GUI_RECT InvalidRectPrev;
;;;1388             InvalidRectPrev = pWin->InvalidRect;
000d0e  68a0              LDR      r0,[r4,#8]
000d10  9000              STR      r0,[sp,#0]
000d12  68e0              LDR      r0,[r4,#0xc]
000d14  9001              STR      r0,[sp,#4]
;;;1389             if(_Paint1Trans(hChild, pChild)) {
000d16  4629              MOV      r1,r5
000d18  4630              MOV      r0,r6
000d1a  f7fffffe          BL       _Paint1Trans
000d1e  b110              CBZ      r0,|L1.3366|
;;;1390               _PaintTransChildren(pChild);
000d20  4628              MOV      r0,r5
000d22  f7fffffe          BL       _PaintTransChildren
                  |L1.3366|
;;;1391             }
;;;1392             pWin->InvalidRect = InvalidRectPrev;
000d26  9800              LDR      r0,[sp,#0]
000d28  60a0              STR      r0,[r4,#8]
000d2a  9801              LDR      r0,[sp,#4]
000d2c  60e0              STR      r0,[r4,#0xc]
;;;1393           }
000d2e  bf00              NOP      
                  |L1.3376|
000d30  f9b5601a          LDRSH    r6,[r5,#0x1a]         ;1381
                  |L1.3380|
000d34  2e00              CMP      r6,#0                 ;1381
000d36  d1db              BNE      |L1.3312|
                  |L1.3384|
;;;1394         }
;;;1395       }
;;;1396     }
;;;1397   }
000d38  bd7c              POP      {r2-r6,pc}
;;;1398   #endif
                          ENDP

                  _PaintTransTopSiblings PROC
;;;1411   #if WM_SUPPORT_TRANSPARENCY
;;;1412   static void _PaintTransTopSiblings(WM_HWIN hWin, WM_Obj* pWin) {
000d3a  e92d41f0          PUSH     {r4-r8,lr}
000d3e  4606              MOV      r6,r0
000d40  460c              MOV      r4,r1
;;;1413     WM_HWIN hParent;
;;;1414     WM_Obj* pParent;
;;;1415     hParent = pWin->hParent;
000d42  f9b47016          LDRSH    r7,[r4,#0x16]
;;;1416     hWin = pWin->hNext;
000d46  f9b4601a          LDRSH    r6,[r4,#0x1a]
;;;1417     while (hParent) { /* Go hierarchy up to desktop window */
000d4a  e01c              B        |L1.3462|
                  |L1.3404|
;;;1418       for (; hWin; hWin = pWin->hNext) {
000d4c  e011              B        |L1.3442|
                  |L1.3406|
;;;1419         pWin = WM_H2P(hWin);
000d4e  4630              MOV      r0,r6
000d50  f7fffffe          BL       GUI_ALLOC_h2p
000d54  4604              MOV      r4,r0
;;;1420         /* paint window if it is transparent & visible */
;;;1421         if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_ISVIS)) ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
000d56  8ba0              LDRH     r0,[r4,#0x1c]
000d58  f0000003          AND      r0,r0,#3
000d5c  2803              CMP      r0,#3
000d5e  d103              BNE      |L1.3432|
;;;1422           _Paint1Trans(hWin, pWin);
000d60  4621              MOV      r1,r4
000d62  4630              MOV      r0,r6
000d64  f7fffffe          BL       _Paint1Trans
                  |L1.3432|
;;;1423         }
;;;1424         /* paint transparent & visible children */
;;;1425         _PaintTransChildren(pWin);
000d68  4620              MOV      r0,r4
000d6a  f7fffffe          BL       _PaintTransChildren
000d6e  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;1418
                  |L1.3442|
000d72  2e00              CMP      r6,#0                 ;1418
000d74  d1eb              BNE      |L1.3406|
;;;1426       }
;;;1427       pParent = WM_H2P(hParent);
000d76  4638              MOV      r0,r7
000d78  f7fffffe          BL       GUI_ALLOC_h2p
000d7c  4605              MOV      r5,r0
;;;1428       hWin = pParent->hNext;
000d7e  f9b5601a          LDRSH    r6,[r5,#0x1a]
;;;1429       hParent = pParent->hParent;
000d82  f9b57016          LDRSH    r7,[r5,#0x16]
                  |L1.3462|
000d86  2f00              CMP      r7,#0                 ;1417
000d88  d1e0              BNE      |L1.3404|
;;;1430     }
;;;1431   }
000d8a  e8bd81f0          POP      {r4-r8,pc}
;;;1432   #endif
                          ENDP

                  WM__PaintWinAndOverlays PROC
;;;1453   */
;;;1454   void WM__PaintWinAndOverlays(WM_PAINTINFO* pInfo) {
000d8e  b570              PUSH     {r4-r6,lr}
000d90  4604              MOV      r4,r0
;;;1455     WM_HWIN hWin;
;;;1456     WM_Obj* pWin;
;;;1457     hWin = pInfo->hWin;
000d92  f9b46000          LDRSH    r6,[r4,#0]
;;;1458     pWin = pInfo->pWin;
000d96  6865              LDR      r5,[r4,#4]
;;;1459     #if WM_SUPPORT_TRANSPARENCY
;;;1460       /* Transparent windows without const outline are drawn as part of the background and can be skipped. */
;;;1461       if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) != WM_SF_HASTRANS) {
000d98  8ba8              LDRH     r0,[r5,#0x1c]
000d9a  f6400101          MOV      r1,#0x801
000d9e  4008              ANDS     r0,r0,r1
000da0  2801              CMP      r0,#1
000da2  d003              BEQ      |L1.3500|
;;;1462     #endif
;;;1463     _Paint1(hWin, pWin);    /* Draw the window itself */
000da4  4629              MOV      r1,r5
000da6  4630              MOV      r0,r6
000da8  f7fffffe          BL       _Paint1
                  |L1.3500|
;;;1464     #if WM_SUPPORT_TRANSPARENCY
;;;1465       }
;;;1466       if (WM__TransWindowCnt != 0) {
000dac  4899              LDR      r0,|L1.4116|
000dae  6800              LDR      r0,[r0,#0]  ; WM__TransWindowCnt
000db0  b130              CBZ      r0,|L1.3520|
;;;1467         _PaintTransChildren(pWin);       /* Draw all transparent children */
000db2  4628              MOV      r0,r5
000db4  f7fffffe          BL       _PaintTransChildren
;;;1468         _PaintTransTopSiblings(hWin, pWin);    /* Draw all transparent top level siblings */
000db8  4629              MOV      r1,r5
000dba  4630              MOV      r0,r6
000dbc  f7fffffe          BL       _PaintTransTopSiblings
                  |L1.3520|
;;;1469       }
;;;1470     #endif
;;;1471   }
000dc0  bd70              POP      {r4-r6,pc}
;;;1472   
                          ENDP

                  _Paint PROC
;;;1502   */
;;;1503   static int _Paint(WM_HWIN hWin, WM_Obj* pWin) {
000dc2  b57c              PUSH     {r2-r6,lr}
000dc4  4605              MOV      r5,r0
000dc6  460c              MOV      r4,r1
;;;1504     int Ret = 0;
000dc8  2600              MOVS     r6,#0
;;;1505     if (pWin->Status & WM_SF_INVALID) {
000dca  8ba0              LDRH     r0,[r4,#0x1c]
000dcc  f0100f20          TST      r0,#0x20
000dd0  d023              BEQ      |L1.3610|
;;;1506       if (pWin->cb) {
000dd2  6920              LDR      r0,[r4,#0x10]
000dd4  b180              CBZ      r0,|L1.3576|
;;;1507         if (WM__ClipAtParentBorders(&pWin->InvalidRect, hWin)) {
000dd6  4629              MOV      r1,r5
000dd8  f1040008          ADD      r0,r4,#8
000ddc  f7fffffe          BL       WM__ClipAtParentBorders
000de0  b150              CBZ      r0,|L1.3576|
;;;1508           WM_PAINTINFO Info;
;;;1509           Info.hWin = hWin;
000de2  f8ad5000          STRH     r5,[sp,#0]
;;;1510           Info.pWin = pWin;
000de6  9401              STR      r4,[sp,#4]
;;;1511           WM_SelectWindow(hWin);
000de8  4628              MOV      r0,r5
000dea  f7fffffe          BL       WM_SelectWindow
;;;1512           #if GUI_SUPPORT_MEMDEV
;;;1513             if (pWin->Status & WM_SF_MEMDEV) {
;;;1514               int Flags;
;;;1515               GUI_RECT r = pWin->InvalidRect;
;;;1516               Flags = (pWin->Status & WM_SF_HASTRANS) ? GUI_MEMDEV_HASTRANS : GUI_MEMDEV_NOTRANS;
;;;1517               /*
;;;1518                * Currently we treat a desktop window as transparent, because per default it does not repaint itself.
;;;1519                */
;;;1520               if (pWin->hParent == 0) {
;;;1521                 Flags = GUI_MEMDEV_HASTRANS;
;;;1522               }
;;;1523               GUI_MEMDEV_Draw(&r, _cbPaintMemDev, &Info, 0, Flags);
;;;1524             } else
;;;1525           #endif
;;;1526           {
;;;1527             WM__PaintWinAndOverlays(&Info);
000dee  4668              MOV      r0,sp
000df0  f7fffffe          BL       WM__PaintWinAndOverlays
;;;1528             Ret = 1;    /* Something has been done */
000df4  2601              MOVS     r6,#1
;;;1529           }
;;;1530         }
000df6  bf00              NOP      
                  |L1.3576|
;;;1531       }
;;;1532       /* We purposly clear the invalid flag after painting so we can still query the invalid rectangle while painting */
;;;1533       pWin->Status &=  ~WM_SF_INVALID; /* Clear invalid flag */
000df8  8ba0              LDRH     r0,[r4,#0x1c]
000dfa  f0200020          BIC      r0,r0,#0x20
000dfe  83a0              STRH     r0,[r4,#0x1c]
;;;1534       if (pWin->Status & WM_CF_MEMDEV_ON_REDRAW) {
000e00  8ba0              LDRH     r0,[r4,#0x1c]
000e02  f4105f00          TST      r0,#0x2000
000e06  d003              BEQ      |L1.3600|
;;;1535         pWin->Status |= WM_CF_MEMDEV;
000e08  8ba0              LDRH     r0,[r4,#0x1c]
000e0a  f0400004          ORR      r0,r0,#4
000e0e  83a0              STRH     r0,[r4,#0x1c]
                  |L1.3600|
;;;1536       }
;;;1537       WM__NumInvalidWindows--;
000e10  4881              LDR      r0,|L1.4120|
000e12  8800              LDRH     r0,[r0,#0]  ; WM__NumInvalidWindows
000e14  1e40              SUBS     r0,r0,#1
000e16  4980              LDR      r1,|L1.4120|
000e18  8008              STRH     r0,[r1,#0]
                  |L1.3610|
;;;1538     }
;;;1539     return Ret;      /* Nothing done */
000e1a  4630              MOV      r0,r6
;;;1540   }
000e1c  bd7c              POP      {r2-r6,pc}
;;;1541   
                          ENDP

                  _DrawNext PROC
;;;1545   */
;;;1546   static void _DrawNext(void) {
000e1e  b570              PUSH     {r4-r6,lr}
000e20  b092              SUB      sp,sp,#0x48
;;;1547     int UpdateRem = 1;
000e22  2601              MOVS     r6,#1
;;;1548     WM_HWIN iWin = (NextDrawWin == WM_HWIN_NULL) ? WM__FirstWin : NextDrawWin;
000e24  487d              LDR      r0,|L1.4124|
000e26  8800              LDRH     r0,[r0,#0]  ; NextDrawWin
000e28  b918              CBNZ     r0,|L1.3634|
000e2a  487d              LDR      r0,|L1.4128|
000e2c  f9b00000          LDRSH    r0,[r0,#0]  ; WM__FirstWin
000e30  e002              B        |L1.3640|
                  |L1.3634|
000e32  487a              LDR      r0,|L1.4124|
000e34  f9b00000          LDRSH    r0,[r0,#0]  ; NextDrawWin
                  |L1.3640|
000e38  4604              MOV      r4,r0
;;;1549     GUI_CONTEXT ContextOld;
;;;1550     GUI_SaveContext(&ContextOld);
000e3a  4668              MOV      r0,sp
000e3c  f7fffffe          BL       GUI_SaveContext_W
;;;1551     /* Make sure the next window to redraw is valid */
;;;1552     for (; iWin && UpdateRem; ) {
000e40  e00c              B        |L1.3676|
                  |L1.3650|
;;;1553       WM_Obj* pWin = WM_H2P(iWin);
000e42  4620              MOV      r0,r4
000e44  f7fffffe          BL       GUI_ALLOC_h2p
000e48  4605              MOV      r5,r0
;;;1554       if (_Paint(iWin, pWin)) {
000e4a  4629              MOV      r1,r5
000e4c  4620              MOV      r0,r4
000e4e  f7fffffe          BL       _Paint
000e52  b100              CBZ      r0,|L1.3670|
;;;1555         UpdateRem--;  /* Only the given number of windows at a time ... */
000e54  1e76              SUBS     r6,r6,#1
                  |L1.3670|
;;;1556       }
;;;1557       iWin = pWin->hNextLin;
000e56  f9b54014          LDRSH    r4,[r5,#0x14]
;;;1558     }  
000e5a  bf00              NOP      
                  |L1.3676|
000e5c  b10c              CBZ      r4,|L1.3682|
000e5e  2e00              CMP      r6,#0                 ;1552
000e60  d1ef              BNE      |L1.3650|
                  |L1.3682|
;;;1559     NextDrawWin = iWin;   /* Remember the window */
000e62  486e              LDR      r0,|L1.4124|
000e64  8004              STRH     r4,[r0,#0]
;;;1560     GUI_RestoreContext(&ContextOld);
000e66  4668              MOV      r0,sp
000e68  f7fffffe          BL       GUI_RestoreContext
;;;1561   }
000e6c  b012              ADD      sp,sp,#0x48
000e6e  bd70              POP      {r4-r6,pc}
;;;1562   
                          ENDP

                  WM_Exec1 PROC
;;;1566   */
;;;1567   int WM_Exec1(void) {
000e70  b510              PUSH     {r4,lr}
;;;1568     /* Poll PID if necessary */
;;;1569     if (WM_pfPollPID) {
000e72  486c              LDR      r0,|L1.4132|
000e74  6800              LDR      r0,[r0,#0]  ; WM_pfPollPID
000e76  b110              CBZ      r0,|L1.3710|
;;;1570       WM_pfPollPID();
000e78  486a              LDR      r0,|L1.4132|
000e7a  6800              LDR      r0,[r0,#0]  ; WM_pfPollPID
000e7c  4780              BLX      r0
                  |L1.3710|
;;;1571     }
;;;1572     if (WM_pfHandlePID) {
000e7e  486a              LDR      r0,|L1.4136|
000e80  6800              LDR      r0,[r0,#0]  ; WM_pfHandlePID
000e82  b128              CBZ      r0,|L1.3728|
;;;1573       if (WM_pfHandlePID())
000e84  4868              LDR      r0,|L1.4136|
000e86  6800              LDR      r0,[r0,#0]  ; WM_pfHandlePID
000e88  4780              BLX      r0
000e8a  b108              CBZ      r0,|L1.3728|
;;;1574         return 1;               /* We have done something ... */
000e8c  2001              MOVS     r0,#1
                  |L1.3726|
;;;1575     }
;;;1576     if (GUI_PollKeyMsg()) {
;;;1577       return 1;               /* We have done something ... */
;;;1578     }
;;;1579     if (WM_IsActive && WM__NumInvalidWindows) {
;;;1580       WM_LOCK();
;;;1581       _DrawNext();
;;;1582       WM_UNLOCK();
;;;1583       return 1;               /* We have done something ... */
;;;1584     }
;;;1585     return 0;                  /* There was nothing to do ... */
;;;1586   }
000e8e  bd10              POP      {r4,pc}
                  |L1.3728|
000e90  f7fffffe          BL       GUI_PollKeyMsg
000e94  b108              CBZ      r0,|L1.3738|
000e96  2001              MOVS     r0,#1                 ;1577
000e98  e7f9              B        |L1.3726|
                  |L1.3738|
000e9a  4864              LDR      r0,|L1.4140|
000e9c  7800              LDRB     r0,[r0,#0]            ;1579  ; WM_IsActive
000e9e  b150              CBZ      r0,|L1.3766|
000ea0  485d              LDR      r0,|L1.4120|
000ea2  8800              LDRH     r0,[r0,#0]            ;1579  ; WM__NumInvalidWindows
000ea4  b138              CBZ      r0,|L1.3766|
000ea6  f7fffffe          BL       GUI_Lock
000eaa  f7fffffe          BL       _DrawNext
000eae  f7fffffe          BL       GUI_Unlock
000eb2  2001              MOVS     r0,#1                 ;1583
000eb4  e7eb              B        |L1.3726|
                  |L1.3766|
000eb6  2000              MOVS     r0,#0                 ;1585
000eb8  e7e9              B        |L1.3726|
;;;1587   
                          ENDP

                  WM_Exec PROC
;;;1591   */
;;;1592   int WM_Exec(void) {
000eba  b510              PUSH     {r4,lr}
;;;1593     int r = 0;
000ebc  2400              MOVS     r4,#0
;;;1594     while (WM_Exec1()) {
000ebe  e000              B        |L1.3778|
                  |L1.3776|
;;;1595       r = 1;                  /* We have done something */
000ec0  2401              MOVS     r4,#1
                  |L1.3778|
000ec2  f7fffffe          BL       WM_Exec1
000ec6  2800              CMP      r0,#0                 ;1594
000ec8  d1fa              BNE      |L1.3776|
;;;1596     }
;;;1597     return r;
000eca  4620              MOV      r0,r4
;;;1598   }
000ecc  bd10              POP      {r4,pc}
;;;1599   
                          ENDP

                  WM_DefaultProc PROC
;;;1663   */
;;;1664   void WM_DefaultProc(WM_MESSAGE* pMsg) {
000ece  e92d41f0          PUSH     {r4-r8,lr}
000ed2  4604              MOV      r4,r0
;;;1665     WM_HWIN hWin = pMsg->hWin;
000ed4  f9b45004          LDRSH    r5,[r4,#4]
;;;1666     const void *p = pMsg->Data.p;
000ed8  68a6              LDR      r6,[r4,#8]
;;;1667     WM_Obj* pWin = WM_H2P(hWin);
000eda  4628              MOV      r0,r5
000edc  f7fffffe          BL       GUI_ALLOC_h2p
000ee0  4607              MOV      r7,r0
;;;1668     /* Exec message */
;;;1669     switch (pMsg->MsgId) {
000ee2  6820              LDR      r0,[r4,#0]
000ee4  2817              CMP      r0,#0x17
000ee6  d00f              BEQ      |L1.3848|
000ee8  dc04              BGT      |L1.3828|
000eea  280e              CMP      r0,#0xe
000eec  d00f              BEQ      |L1.3854|
000eee  2814              CMP      r0,#0x14
000ef0  d11a              BNE      |L1.3880|
000ef2  e004              B        |L1.3838|
                  |L1.3828|
000ef4  2822              CMP      r0,#0x22
000ef6  d00f              BEQ      |L1.3864|
000ef8  2828              CMP      r0,#0x28
000efa  d115              BNE      |L1.3880|
000efc  e010              B        |L1.3872|
                  |L1.3838|
;;;1670     case WM_GET_INSIDE_RECT:      /* return client window in absolute (screen) coordinates */
;;;1671       WM__GetClientRectWin(pWin, (GUI_RECT*)p);
000efe  4631              MOV      r1,r6
000f00  4638              MOV      r0,r7
000f02  f7fffffe          BL       WM__GetClientRectWin
;;;1672       break;
000f06  e00f              B        |L1.3880|
                  |L1.3848|
;;;1673     case WM_GET_CLIENT_WINDOW:      /* return handle to client window. For most windows, there is no seperate client window, so it is the same handle */
;;;1674       pMsg->Data.v = (int)hWin;
000f08  60a5              STR      r5,[r4,#8]
                  |L1.3850|
;;;1675       return;                       /* Message handled */
;;;1676     case WM_KEY:
;;;1677       WM_SendToParent(hWin, pMsg);
;;;1678       return;                       /* Message handled */
;;;1679      case WM_GET_BKCOLOR:
;;;1680       pMsg->Data.Color = GUI_INVALID_COLOR;
;;;1681       return;                       /* Message handled */
;;;1682     case WM_NOTIFY_ENABLE:
;;;1683       WM_InvalidateWindow(hWin);    
;;;1684       return;                       /* Message handled */
;;;1685     }
;;;1686     /* Message not handled. If it queries something, we return 0 to be on the safe side. */
;;;1687     pMsg->Data.v = 0;
;;;1688     pMsg->Data.p = 0;
;;;1689   }
000f0a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3854|
000f0e  4621              MOV      r1,r4                 ;1677
000f10  4628              MOV      r0,r5                 ;1677
000f12  f7fffffe          BL       WM_SendToParent
000f16  e7f8              B        |L1.3850|
                  |L1.3864|
000f18  f06f4070          MVN      r0,#0xf0000000        ;1680
000f1c  60a0              STR      r0,[r4,#8]            ;1680
000f1e  e7f4              B        |L1.3850|
                  |L1.3872|
000f20  4628              MOV      r0,r5                 ;1683
000f22  f7fffffe          BL       WM_InvalidateWindow
000f26  e7f0              B        |L1.3850|
                  |L1.3880|
000f28  bf00              NOP                            ;1672
000f2a  2000              MOVS     r0,#0                 ;1687
000f2c  60a0              STR      r0,[r4,#8]            ;1687
000f2e  60a0              STR      r0,[r4,#8]            ;1688
000f30  bf00              NOP      
000f32  e7ea              B        |L1.3850|
;;;1690   
                          ENDP

                  cbBackWin PROC
;;;1607   */
;;;1608   static void cbBackWin( WM_MESSAGE* pMsg) {
000f34  b570              PUSH     {r4-r6,lr}
000f36  4604              MOV      r4,r0
;;;1609     const WM_KEY_INFO* pKeyInfo;
;;;1610     switch (pMsg->MsgId) {
000f38  6820              LDR      r0,[r4,#0]
000f3a  280e              CMP      r0,#0xe
000f3c  d002              BEQ      |L1.3908|
000f3e  280f              CMP      r0,#0xf
000f40  d118              BNE      |L1.3956|
000f42  e007              B        |L1.3924|
                  |L1.3908|
;;;1611     case WM_KEY:
;;;1612       pKeyInfo = (const WM_KEY_INFO*)pMsg->Data.p;
000f44  68a5              LDR      r5,[r4,#8]
;;;1613       if (pKeyInfo->PressedCnt == 1) {
000f46  6868              LDR      r0,[r5,#4]
000f48  2801              CMP      r0,#1
000f4a  d102              BNE      |L1.3922|
;;;1614         GUI_StoreKey(pKeyInfo->Key);
000f4c  6828              LDR      r0,[r5,#0]
000f4e  f7fffffe          BL       GUI_StoreKey
                  |L1.3922|
;;;1615       }
;;;1616       break;
000f52  e013              B        |L1.3964|
                  |L1.3924|
;;;1617     case WM_PAINT:
;;;1618       {
;;;1619         int LayerIndex;
;;;1620         #if GUI_NUM_LAYERS > 1
;;;1621           LayerIndex = _DesktopHandle2Index(pMsg->hWin);
;;;1622         #else
;;;1623           LayerIndex = 0;
000f54  2600              MOVS     r6,#0
;;;1624         #endif
;;;1625         if (WM__aBkColor[LayerIndex] != GUI_INVALID_COLOR) {
000f56  4836              LDR      r0,|L1.4144|
000f58  f8500026          LDR      r0,[r0,r6,LSL #2]
000f5c  f06f4170          MVN      r1,#0xf0000000
000f60  4288              CMP      r0,r1
000f62  d006              BEQ      |L1.3954|
;;;1626           GUI_SetBkColor(WM__aBkColor[LayerIndex]);
000f64  4932              LDR      r1,|L1.4144|
000f66  f8510026          LDR      r0,[r1,r6,LSL #2]
000f6a  f7fffffe          BL       GUI_SetBkColor
;;;1627           GUI_Clear();
000f6e  f7fffffe          BL       GUI_Clear
                  |L1.3954|
;;;1628         }
;;;1629       }
;;;1630     default:
000f72  bf00              NOP      
                  |L1.3956|
;;;1631       WM_DefaultProc(pMsg);
000f74  4620              MOV      r0,r4
000f76  f7fffffe          BL       WM_DefaultProc
000f7a  bf00              NOP                            ;1610
                  |L1.3964|
000f7c  bf00              NOP                            ;1616
;;;1632     }
;;;1633   }
000f7e  bd70              POP      {r4-r6,pc}
;;;1634   
                          ENDP

                  WM_Activate PROC
;;;1638   */
;;;1639   void WM_Activate(void) {
000f80  2001              MOVS     r0,#1
;;;1640     WM_IsActive = 1;       /* Running */
000f82  492a              LDR      r1,|L1.4140|
000f84  7008              STRB     r0,[r1,#0]
;;;1641   }
000f86  4770              BX       lr
;;;1642   
                          ENDP

                  WM_Deactivate PROC
;;;1646   */
;;;1647   void WM_Deactivate(void) {
000f88  b510              PUSH     {r4,lr}
;;;1648     WM_IsActive = 0;       /* No clipping performed by WM */
000f8a  2000              MOVS     r0,#0
000f8c  4927              LDR      r1,|L1.4140|
000f8e  7008              STRB     r0,[r1,#0]
;;;1649     WM_LOCK();
000f90  f7fffffe          BL       GUI_Lock
;;;1650     LCD_SetClipRectMax();
000f94  f7fffffe          BL       LCD_SetClipRectMax
;;;1651     WM_UNLOCK();
000f98  f7fffffe          BL       GUI_Unlock
;;;1652   }
000f9c  bd10              POP      {r4,pc}
;;;1653   
                          ENDP

                  WM_Init PROC
;;;1694   */
;;;1695   void WM_Init(void) {
000f9e  b50e              PUSH     {r1-r3,lr}
;;;1696   	if (!_IsInited) {
000fa0  4824              LDR      r0,|L1.4148|
000fa2  7800              LDRB     r0,[r0,#0]  ; _IsInited
000fa4  bb80              CBNZ     r0,|L1.4104|
;;;1697   	  NextDrawWin = WM__FirstWin = WM_HWIN_NULL;
000fa6  2000              MOVS     r0,#0
000fa8  491d              LDR      r1,|L1.4128|
000faa  8008              STRH     r0,[r1,#0]
000fac  491b              LDR      r1,|L1.4124|
000fae  8008              STRH     r0,[r1,#0]
;;;1698   	  GUI_Context.WM__pUserClipRect = NULL;
000fb0  4917              LDR      r1,|L1.4112|
000fb2  6388              STR      r0,[r1,#0x38]  ; GUI_Context
;;;1699   	  WM__NumWindows = WM__NumInvalidWindows =0;
000fb4  4918              LDR      r1,|L1.4120|
000fb6  8008              STRH     r0,[r1,#0]
000fb8  491f              LDR      r1,|L1.4152|
000fba  8008              STRH     r0,[r1,#0]
;;;1700   	  /* Make sure we have at least one window. This greatly simplifies the
;;;1701   		  drawing routines as they do not have to check if the window is valid.
;;;1702   	  */
;;;1703       #if GUI_NUM_LAYERS == 1
;;;1704         WM__ahDesktopWin[0] = WM_CreateWindow(0, 0, GUI_XMAX, GUI_YMAX, WM_CF_SHOW, cbBackWin, 0);
000fbc  491f              LDR      r1,|L1.4156|
000fbe  2202              MOVS     r2,#2
000fc0  f64073ff          MOV      r3,#0xfff
000fc4  e9cd2100          STRD     r2,r1,[sp,#0]
000fc8  9002              STR      r0,[sp,#8]
000fca  461a              MOV      r2,r3
000fcc  4601              MOV      r1,r0
000fce  f7fffffe          BL       WM_CreateWindow
000fd2  491b              LDR      r1,|L1.4160|
000fd4  8008              STRH     r0,[r1,#0]
;;;1705         WM__aBkColor[0] = GUI_INVALID_COLOR;
000fd6  f06f4070          MVN      r0,#0xf0000000
000fda  4915              LDR      r1,|L1.4144|
000fdc  6008              STR      r0,[r1,#0]  ; WM__aBkColor
;;;1706         WM_InvalidateWindow(WM__ahDesktopWin[0]); /* Required because a desktop window has no parent. */
000fde  4918              LDR      r1,|L1.4160|
000fe0  f9b10000          LDRSH    r0,[r1,#0]  ; WM__ahDesktopWin
000fe4  f7fffffe          BL       WM_InvalidateWindow
;;;1707       #else
;;;1708       {
;;;1709         int i;
;;;1710         for (i = 0; i < GUI_NUM_LAYERS; i++) {
;;;1711           WM__ahDesktopWin[i] = WM_CreateWindowAsChild(0, 0, GUI_XMAX, GUI_YMAX, WM_UNATTACHED, WM_CF_SHOW, cbBackWin, 0);
;;;1712           WM__aBkColor[i] = GUI_INVALID_COLOR;
;;;1713           WM_InvalidateWindow(WM__ahDesktopWin[i]); /* Required because a desktop window has no parent. */
;;;1714         }
;;;1715       }
;;;1716       #endif
;;;1717       /* Register the critical handles ... Note: This could be moved into the module setting the Window handle */
;;;1718       WM__AddCriticalHandle(&WM__CHWinModal);
000fe8  4816              LDR      r0,|L1.4164|
000fea  f7fffffe          BL       WM__AddCriticalHandle
;;;1719       WM__AddCriticalHandle(&WM__CHWinLast);
000fee  4816              LDR      r0,|L1.4168|
000ff0  f7fffffe          BL       WM__AddCriticalHandle
;;;1720   
;;;1721       WM_SelectWindow(WM__ahDesktopWin[0]);
000ff4  4912              LDR      r1,|L1.4160|
000ff6  f9b10000          LDRSH    r0,[r1,#0]  ; WM__ahDesktopWin
000ffa  f7fffffe          BL       WM_SelectWindow
;;;1722   	  WM_Activate();
000ffe  f7fffffe          BL       WM_Activate
;;;1723       _IsInited =1;
001002  2001              MOVS     r0,#1
001004  490b              LDR      r1,|L1.4148|
001006  7008              STRB     r0,[r1,#0]
                  |L1.4104|
;;;1724   	}
;;;1725   }
001008  bd0e              POP      {r1-r3,pc}
;;;1726   
                          ENDP

00100a  0000              DCW      0x0000
                  |L1.4108|
                          DCD      WM__hATransWindow
                  |L1.4112|
                          DCD      GUI_Context
                  |L1.4116|
                          DCD      WM__TransWindowCnt
                  |L1.4120|
                          DCD      WM__NumInvalidWindows
                  |L1.4124|
                          DCD      NextDrawWin
                  |L1.4128|
                          DCD      WM__FirstWin
                  |L1.4132|
                          DCD      WM_pfPollPID
                  |L1.4136|
                          DCD      WM_pfHandlePID
                  |L1.4140|
                          DCD      WM_IsActive
                  |L1.4144|
                          DCD      WM__aBkColor
                  |L1.4148|
                          DCD      _IsInited
                  |L1.4152|
                          DCD      WM__NumWindows
                  |L1.4156|
                          DCD      cbBackWin
                  |L1.4160|
                          DCD      WM__ahDesktopWin
                  |L1.4164|
                          DCD      WM__CHWinModal
                  |L1.4168|
                          DCD      WM__CHWinLast

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  WM_PID__StateLast
                          %        12
                  _ClipContext
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  _CursorHidden
000000  0000              DCB      0x00,0x00
                  WM__NumWindows
000002  0000              DCB      0x00,0x00
                  WM__NumInvalidWindows
000004  0000              DCB      0x00,0x00
                  WM__FirstWin
000006  0000              DCB      0x00,0x00
                  WM__pFirstCriticalHandle
                          DCD      0x00000000
                  WM__ahDesktopWin
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  WM__aBkColor
                          DCD      0x00000000
                  WM_IsActive
000014  0000              DCB      0x00,0x00
                  WM__CreateFlags
000016  0000              DCB      0x00,0x00
                  WM__hCapture
000018  0000              DCB      0x00,0x00
                  WM__hWinFocus
00001a  0000              DCB      0x00,0x00
                  WM__CaptureReleaseAuto
00001c  00000000          DCB      0x00,0x00,0x00,0x00
                  WM_pfPollPID
                          DCD      0x00000000
                  WM__PaintCallbackCnt
000024  00000000          DCB      0x00,0x00,0x00,0x00
                  WM__TransWindowCnt
                          DCD      0x00000000
                  WM__hATransWindow
00002c  0000              DCB      0x00,0x00
                  NextDrawWin
00002e  0000              DCB      0x00,0x00
                  _IsInited
000030  00                DCB      0x00
