; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Obj\os_core.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\Obj\os_core.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\BaseDrive -I..\Ucosii -I..\Ucosii\Port -I..\Ucosii\Src -I..\Ucosii\Include -I..\Ucgui -I..\Ucgui\Config -I..\Ucgui\GUI_X -I..\Ucgui\GUI -I..\Ucgui\GUI\ConvertColor -I..\Ucgui\GUI\ConvertMono -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\LCDDriver -I..\Ucgui\GUI\MultiLayer -I..\Ucgui\GUI\Widget -I..\Ucgui\GUI\WM -I..\ExternalDrive\Lcd -I..\ExternalDrive\Touch -I..\Panel -I"D:\Program files\Keil\ARM\RV31\Inc" -I"D:\Program files\Keil\ARM\CMSIS\Include" -I"D:\Program files\Keil\ARM\Inc\ST\STM32F10x" -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\os_core.crf ..\Ucosii\Src\os_core.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  OS_StrCopy PROC
;;;1695   #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
;;;1696   INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
000000  4602              MOV      r2,r0
;;;1697   {
;;;1698       INT8U  len;
;;;1699   
;;;1700   
;;;1701       len = 0;
000002  2000              MOVS     r0,#0
;;;1702       while (*psrc != OS_ASCII_NUL) {
000004  e005              B        |L1.18|
                  |L1.6|
;;;1703           *pdest++ = *psrc++;
000006  f8113b01          LDRB     r3,[r1],#1
00000a  f8023b01          STRB     r3,[r2],#1
;;;1704           len++;
00000e  1c43              ADDS     r3,r0,#1
000010  b2d8              UXTB     r0,r3
                  |L1.18|
000012  780b              LDRB     r3,[r1,#0]            ;1702
000014  2b00              CMP      r3,#0                 ;1702
000016  d1f6              BNE      |L1.6|
;;;1705       }
;;;1706       *pdest = OS_ASCII_NUL;
000018  7013              STRB     r3,[r2,#0]
;;;1707       return (len);
;;;1708   }
00001a  4770              BX       lr
;;;1709   #endif
                          ENDP

                  OSEventNameGet PROC
;;;108    #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
;;;109    INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
00001c  e92d41f0          PUSH     {r4-r8,lr}
;;;110    {
000020  4605              MOV      r5,r0
000022  460e              MOV      r6,r1
000024  4614              MOV      r4,r2
;;;111        INT8U      len;
;;;112    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;113        OS_CPU_SR  cpu_sr = 0;
000026  2700              MOVS     r7,#0
;;;114    #endif
;;;115    
;;;116    
;;;117    
;;;118    #if OS_ARG_CHK_EN > 0
;;;119        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
000028  b914              CBNZ     r4,|L1.48|
;;;120            return (0);
00002a  2000              MOVS     r0,#0
                  |L1.44|
;;;121        }
;;;122        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;123            *perr = OS_ERR_PEVENT_NULL;
;;;124            return (0);
;;;125        }
;;;126        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;127            *perr = OS_ERR_PNAME_NULL;
;;;128            return (0);
;;;129        }
;;;130    #endif
;;;131        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
;;;132            *perr  = OS_ERR_NAME_GET_ISR;
;;;133            return (0);
;;;134        }
;;;135        switch (pevent->OSEventType) {
;;;136            case OS_EVENT_TYPE_SEM:
;;;137            case OS_EVENT_TYPE_MUTEX:
;;;138            case OS_EVENT_TYPE_MBOX:
;;;139            case OS_EVENT_TYPE_Q:
;;;140                 break;
;;;141    
;;;142            default:
;;;143                 *perr = OS_ERR_EVENT_TYPE;
;;;144                 return (0);
;;;145        }
;;;146        OS_ENTER_CRITICAL();
;;;147        len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
;;;148        OS_EXIT_CRITICAL();
;;;149        *perr = OS_ERR_NONE;
;;;150        return (len);
;;;151    }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.48|
000030  b91d              CBNZ     r5,|L1.58|
000032  2004              MOVS     r0,#4                 ;123
000034  7020              STRB     r0,[r4,#0]            ;123
000036  2000              MOVS     r0,#0                 ;124
000038  e7f8              B        |L1.44|
                  |L1.58|
00003a  b91e              CBNZ     r6,|L1.68|
00003c  200c              MOVS     r0,#0xc               ;127
00003e  7020              STRB     r0,[r4,#0]            ;127
000040  2000              MOVS     r0,#0                 ;128
000042  e7f3              B        |L1.44|
                  |L1.68|
000044  48fa              LDR      r0,|L1.1072|
000046  7800              LDRB     r0,[r0,#0]            ;131  ; OSIntNesting
000048  2800              CMP      r0,#0                 ;131
00004a  dd03              BLE      |L1.84|
00004c  2011              MOVS     r0,#0x11              ;132
00004e  7020              STRB     r0,[r4,#0]            ;132
000050  2000              MOVS     r0,#0                 ;133
000052  e7eb              B        |L1.44|
                  |L1.84|
000054  7828              LDRB     r0,[r5,#0]            ;135
000056  2801              CMP      r0,#1                 ;135
000058  d008              BEQ      |L1.108|
00005a  2802              CMP      r0,#2                 ;135
00005c  d007              BEQ      |L1.110|
00005e  2803              CMP      r0,#3                 ;135
000060  d002              BEQ      |L1.104|
000062  2804              CMP      r0,#4                 ;135
000064  d104              BNE      |L1.112|
000066  e000              B        |L1.106|
                  |L1.104|
000068  bf00              NOP                            ;137
                  |L1.106|
00006a  bf00              NOP                            ;138
                  |L1.108|
00006c  bf00              NOP                            ;139
                  |L1.110|
00006e  e003              B        |L1.120|
                  |L1.112|
000070  2001              MOVS     r0,#1                 ;143
000072  7020              STRB     r0,[r4,#0]            ;143
000074  2000              MOVS     r0,#0                 ;144
000076  e7d9              B        |L1.44|
                  |L1.120|
000078  bf00              NOP                            ;140
00007a  f7fffffe          BL       OS_CPU_SR_Save
00007e  4607              MOV      r7,r0                 ;146
000080  f105010f          ADD      r1,r5,#0xf            ;147
000084  4630              MOV      r0,r6                 ;147
000086  f7fffffe          BL       OS_StrCopy
00008a  4680              MOV      r8,r0                 ;147
00008c  4638              MOV      r0,r7                 ;148
00008e  f7fffffe          BL       OS_CPU_SR_Restore
000092  2000              MOVS     r0,#0                 ;149
000094  7020              STRB     r0,[r4,#0]            ;149
000096  4640              MOV      r0,r8                 ;150
000098  e7c8              B        |L1.44|
;;;152    #endif
                          ENDP

                  OS_StrLen PROC
;;;1727   #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
;;;1728   INT8U  OS_StrLen (INT8U *psrc)
00009a  4601              MOV      r1,r0
;;;1729   {
;;;1730       INT8U  len;
;;;1731   
;;;1732   
;;;1733       len = 0;
00009c  2000              MOVS     r0,#0
;;;1734       while (*psrc != OS_ASCII_NUL) {
00009e  e002              B        |L1.166|
                  |L1.160|
;;;1735           psrc++;
0000a0  1c49              ADDS     r1,r1,#1
;;;1736           len++;
0000a2  1c42              ADDS     r2,r0,#1
0000a4  b2d0              UXTB     r0,r2
                  |L1.166|
0000a6  780a              LDRB     r2,[r1,#0]            ;1734
0000a8  2a00              CMP      r2,#0                 ;1734
0000aa  d1f9              BNE      |L1.160|
;;;1737       }
;;;1738       return (len);
;;;1739   }
0000ac  4770              BX       lr
;;;1740   #endif
                          ENDP

                  OSEventNameSet PROC
;;;182    #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
;;;183    void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
0000ae  e92d41f0          PUSH     {r4-r8,lr}
;;;184    {
0000b2  4605              MOV      r5,r0
0000b4  460e              MOV      r6,r1
0000b6  4614              MOV      r4,r2
;;;185        INT8U      len;
;;;186    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;187        OS_CPU_SR  cpu_sr = 0;
0000b8  f04f0800          MOV      r8,#0
;;;188    #endif
;;;189    
;;;190    
;;;191    
;;;192    #if OS_ARG_CHK_EN > 0
;;;193        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
0000bc  b90c              CBNZ     r4,|L1.194|
                  |L1.190|
;;;194            return;
;;;195        }
;;;196        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;197            *perr = OS_ERR_PEVENT_NULL;
;;;198            return;
;;;199        }
;;;200        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;201            *perr = OS_ERR_PNAME_NULL;
;;;202            return;
;;;203        }
;;;204    #endif
;;;205        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
;;;206            *perr = OS_ERR_NAME_SET_ISR;
;;;207            return;
;;;208        }
;;;209        switch (pevent->OSEventType) {
;;;210            case OS_EVENT_TYPE_SEM:
;;;211            case OS_EVENT_TYPE_MUTEX:
;;;212            case OS_EVENT_TYPE_MBOX:
;;;213            case OS_EVENT_TYPE_Q:
;;;214                 break;
;;;215    
;;;216            default:
;;;217                 *perr = OS_ERR_EVENT_TYPE;
;;;218                 return;
;;;219        }
;;;220        OS_ENTER_CRITICAL();
;;;221        len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
;;;222        if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
;;;223            OS_EXIT_CRITICAL();
;;;224            *perr = OS_ERR_EVENT_NAME_TOO_LONG;
;;;225            return;
;;;226        }
;;;227        (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
;;;228        OS_EXIT_CRITICAL();
;;;229        *perr = OS_ERR_NONE;
;;;230    }
0000be  e8bd81f0          POP      {r4-r8,pc}
                  |L1.194|
0000c2  b915              CBNZ     r5,|L1.202|
0000c4  2004              MOVS     r0,#4                 ;197
0000c6  7020              STRB     r0,[r4,#0]            ;197
0000c8  e7f9              B        |L1.190|
                  |L1.202|
0000ca  b916              CBNZ     r6,|L1.210|
0000cc  200c              MOVS     r0,#0xc               ;201
0000ce  7020              STRB     r0,[r4,#0]            ;201
0000d0  e7f5              B        |L1.190|
                  |L1.210|
0000d2  48d7              LDR      r0,|L1.1072|
0000d4  7800              LDRB     r0,[r0,#0]            ;205  ; OSIntNesting
0000d6  2800              CMP      r0,#0                 ;205
0000d8  dd02              BLE      |L1.224|
0000da  2012              MOVS     r0,#0x12              ;206
0000dc  7020              STRB     r0,[r4,#0]            ;206
0000de  e7ee              B        |L1.190|
                  |L1.224|
0000e0  7828              LDRB     r0,[r5,#0]            ;209
0000e2  2801              CMP      r0,#1                 ;209
0000e4  d008              BEQ      |L1.248|
0000e6  2802              CMP      r0,#2                 ;209
0000e8  d007              BEQ      |L1.250|
0000ea  2803              CMP      r0,#3                 ;209
0000ec  d002              BEQ      |L1.244|
0000ee  2804              CMP      r0,#4                 ;209
0000f0  d104              BNE      |L1.252|
0000f2  e000              B        |L1.246|
                  |L1.244|
0000f4  bf00              NOP                            ;211
                  |L1.246|
0000f6  bf00              NOP                            ;212
                  |L1.248|
0000f8  bf00              NOP                            ;213
                  |L1.250|
0000fa  e002              B        |L1.258|
                  |L1.252|
0000fc  2001              MOVS     r0,#1                 ;217
0000fe  7020              STRB     r0,[r4,#0]            ;217
000100  e7dd              B        |L1.190|
                  |L1.258|
000102  bf00              NOP                            ;214
000104  f7fffffe          BL       OS_CPU_SR_Save
000108  4680              MOV      r8,r0                 ;220
00010a  4630              MOV      r0,r6                 ;221
00010c  f7fffffe          BL       OS_StrLen
000110  4607              MOV      r7,r0                 ;221
000112  2f0f              CMP      r7,#0xf               ;222
000114  dd05              BLE      |L1.290|
000116  4640              MOV      r0,r8                 ;223
000118  f7fffffe          BL       OS_CPU_SR_Restore
00011c  200b              MOVS     r0,#0xb               ;224
00011e  7020              STRB     r0,[r4,#0]            ;224
000120  e7cd              B        |L1.190|
                  |L1.290|
000122  4631              MOV      r1,r6                 ;227
000124  f105000f          ADD      r0,r5,#0xf            ;227
000128  f7fffffe          BL       OS_StrCopy
00012c  4640              MOV      r0,r8                 ;228
00012e  f7fffffe          BL       OS_CPU_SR_Restore
000132  2000              MOVS     r0,#0                 ;229
000134  7020              STRB     r0,[r4,#0]            ;229
000136  bf00              NOP      
000138  e7c1              B        |L1.190|
;;;231    #endif
                          ENDP

                  OS_TaskIdle PROC
;;;1762   
;;;1763   void  OS_TaskIdle (void *p_arg)
00013a  2400              MOVS     r4,#0
;;;1764   {
;;;1765   #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;1766       OS_CPU_SR  cpu_sr = 0;
;;;1767   #endif
;;;1768   
;;;1769   
;;;1770   
;;;1771       (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
;;;1772       for (;;) {
00013c  bf00              NOP      
                  |L1.318|
;;;1773           OS_ENTER_CRITICAL();
00013e  f7fffffe          BL       OS_CPU_SR_Save
000142  4604              MOV      r4,r0
;;;1774           OSIdleCtr++;
000144  48bb              LDR      r0,|L1.1076|
000146  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
000148  1c40              ADDS     r0,r0,#1
00014a  49ba              LDR      r1,|L1.1076|
00014c  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1775           OS_EXIT_CRITICAL();
00014e  4620              MOV      r0,r4
000150  f7fffffe          BL       OS_CPU_SR_Restore
;;;1776           OSTaskIdleHook();                        /* Call user definable HOOK                           */
000154  f7fffffe          BL       OSTaskIdleHook
000158  e7f1              B        |L1.318|
;;;1777       }
;;;1778   }
;;;1779   /*$PAGE*/
                          ENDP

                  OS_InitTaskIdle PROC
;;;1367   
;;;1368   static  void  OS_InitTaskIdle (void)
00015a  b500              PUSH     {lr}
;;;1369   {
00015c  b087              SUB      sp,sp,#0x1c
;;;1370   #if OS_TASK_NAME_SIZE > 7
;;;1371       INT8U  err;
;;;1372   #endif
;;;1373   
;;;1374   
;;;1375   #if OS_TASK_CREATE_EXT_EN > 0
;;;1376       #if OS_STK_GROWTH == 1
;;;1377       (void)OSTaskCreateExt(OS_TaskIdle,
00015e  2003              MOVS     r0,#3
000160  2100              MOVS     r1,#0
000162  2280              MOVS     r2,#0x80
000164  4bb4              LDR      r3,|L1.1080|
000166  e9cd3201          STRD     r3,r2,[sp,#4]
00016a  e9cd1003          STRD     r1,r0,[sp,#0xc]
00016e  f64f70ff          MOV      r0,#0xffff
000172  231f              MOVS     r3,#0x1f
000174  4ab1              LDR      r2,|L1.1084|
000176  9000              STR      r0,[sp,#0]
000178  f2af0041          ADR      r0,OS_TaskIdle + 1
00017c  f7fffffe          BL       OSTaskCreateExt
;;;1378                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1379                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Top-Of-Stack                     */
;;;1380                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1381                             OS_TASK_IDLE_ID,
;;;1382                             &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
;;;1383                             OS_TASK_IDLE_STK_SIZE,
;;;1384                             (void *)0,                                 /* No TCB extension                     */
;;;1385                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1386       #else
;;;1387       (void)OSTaskCreateExt(OS_TaskIdle,
;;;1388                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1389                             &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
;;;1390                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1391                             OS_TASK_IDLE_ID,
;;;1392                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Bottom-Of-Stack                  */
;;;1393                             OS_TASK_IDLE_STK_SIZE,
;;;1394                             (void *)0,                                 /* No TCB extension                     */
;;;1395                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1396       #endif
;;;1397   #else
;;;1398       #if OS_STK_GROWTH == 1
;;;1399       (void)OSTaskCreate(OS_TaskIdle,
;;;1400                          (void *)0,
;;;1401                          &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1],
;;;1402                          OS_TASK_IDLE_PRIO);
;;;1403       #else
;;;1404       (void)OSTaskCreate(OS_TaskIdle,
;;;1405                          (void *)0,
;;;1406                          &OSTaskIdleStk[0],
;;;1407                          OS_TASK_IDLE_PRIO);
;;;1408       #endif
;;;1409   #endif
;;;1410   
;;;1411   #if OS_TASK_NAME_SIZE > 14
;;;1412       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
000180  aa06              ADD      r2,sp,#0x18
000182  a1af              ADR      r1,|L1.1088|
000184  201f              MOVS     r0,#0x1f
000186  f7fffffe          BL       OSTaskNameSet
;;;1413   #else
;;;1414   #if OS_TASK_NAME_SIZE > 7
;;;1415       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
;;;1416   #endif
;;;1417   #endif
;;;1418   }
00018a  b007              ADD      sp,sp,#0x1c
00018c  bd00              POP      {pc}
;;;1419   /*$PAGE*/
                          ENDP

                  OS_MemClr PROC
;;;1548   
;;;1549   void  OS_MemClr (INT8U *pdest, INT16U size)
00018e  e004              B        |L1.410|
                  |L1.400|
;;;1550   {
;;;1551       while (size > 0) {
;;;1552           *pdest++ = (INT8U)0;
000190  2200              MOVS     r2,#0
000192  f8002b01          STRB     r2,[r0],#1
;;;1553           size--;
000196  1e4a              SUBS     r2,r1,#1
000198  b291              UXTH     r1,r2
                  |L1.410|
00019a  2900              CMP      r1,#0                 ;1551
00019c  dcf8              BGT      |L1.400|
;;;1554       }
;;;1555   }
00019e  4770              BX       lr
;;;1556   /*$PAGE*/
                          ENDP

                  OS_InitEventList PROC
;;;1240   
;;;1241   static  void  OS_InitEventList (void)
0001a0  b530              PUSH     {r4,r5,lr}
;;;1242   {
;;;1243   #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0)
;;;1244   #if (OS_MAX_EVENTS > 1)
;;;1245       INT16U     i;
;;;1246       OS_EVENT  *pevent1;
;;;1247       OS_EVENT  *pevent2;
;;;1248   
;;;1249   
;;;1250       OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
0001a2  f44f71a0          MOV      r1,#0x140
0001a6  48aa              LDR      r0,|L1.1104|
0001a8  f7fffffe          BL       OS_MemClr
;;;1251       pevent1 = &OSEventTbl[0];
0001ac  4ba8              LDR      r3,|L1.1104|
;;;1252       pevent2 = &OSEventTbl[1];
0001ae  f1030520          ADD      r5,r3,#0x20
;;;1253       for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
0001b2  2400              MOVS     r4,#0
0001b4  e00a              B        |L1.460|
                  |L1.438|
;;;1254           pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
0001b6  2000              MOVS     r0,#0
0001b8  7018              STRB     r0,[r3,#0]
;;;1255           pevent1->OSEventPtr     = pevent2;
0001ba  605d              STR      r5,[r3,#4]
;;;1256   #if OS_EVENT_NAME_SIZE > 1
;;;1257           pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
0001bc  203f              MOVS     r0,#0x3f
0001be  73d8              STRB     r0,[r3,#0xf]
;;;1258           pevent1->OSEventName[1] = OS_ASCII_NUL;
0001c0  2100              MOVS     r1,#0
0001c2  7419              STRB     r1,[r3,#0x10]
;;;1259   #endif
;;;1260           pevent1++;
0001c4  3320              ADDS     r3,r3,#0x20
;;;1261           pevent2++;
0001c6  3520              ADDS     r5,r5,#0x20
0001c8  1c60              ADDS     r0,r4,#1              ;1253
0001ca  b284              UXTH     r4,r0                 ;1253
                  |L1.460|
0001cc  2c09              CMP      r4,#9                 ;1253
0001ce  dbf2              BLT      |L1.438|
;;;1262       }
;;;1263       pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
0001d0  2000              MOVS     r0,#0
0001d2  7018              STRB     r0,[r3,#0]
;;;1264       pevent1->OSEventPtr             = (OS_EVENT *)0;
0001d4  6058              STR      r0,[r3,#4]
;;;1265   #if OS_EVENT_NAME_SIZE > 1
;;;1266       pevent1->OSEventName[0]         = '?';
0001d6  203f              MOVS     r0,#0x3f
0001d8  73d8              STRB     r0,[r3,#0xf]
;;;1267       pevent1->OSEventName[1]         = OS_ASCII_NUL;
0001da  2100              MOVS     r1,#0
0001dc  7419              STRB     r1,[r3,#0x10]
;;;1268   #endif
;;;1269       OSEventFreeList                 = &OSEventTbl[0];
0001de  489c              LDR      r0,|L1.1104|
0001e0  499c              LDR      r1,|L1.1108|
0001e2  6008              STR      r0,[r1,#0]  ; OSEventFreeList
;;;1270   #else
;;;1271       OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
;;;1272       OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;1273       OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
;;;1274   #if OS_EVENT_NAME_SIZE > 1
;;;1275       OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
;;;1276       OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
;;;1277   #endif
;;;1278   #endif
;;;1279   #endif
;;;1280   }
0001e4  bd30              POP      {r4,r5,pc}
;;;1281   /*$PAGE*/
                          ENDP

                  OS_InitTCBList PROC
;;;1499   
;;;1500   static  void  OS_InitTCBList (void)
0001e6  b530              PUSH     {r4,r5,lr}
;;;1501   {
;;;1502       INT8U    i;
;;;1503       OS_TCB  *ptcb1;
;;;1504       OS_TCB  *ptcb2;
;;;1505   
;;;1506   
;;;1507       OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
0001e8  f2405194          MOV      r1,#0x594
0001ec  489a              LDR      r0,|L1.1112|
0001ee  f7fffffe          BL       OS_MemClr
;;;1508       OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
0001f2  2180              MOVS     r1,#0x80
0001f4  4899              LDR      r0,|L1.1116|
0001f6  f7fffffe          BL       OS_MemClr
;;;1509       ptcb1 = &OSTCBTbl[0];
0001fa  4b97              LDR      r3,|L1.1112|
;;;1510       ptcb2 = &OSTCBTbl[1];
0001fc  f1030554          ADD      r5,r3,#0x54
;;;1511       for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
000200  2400              MOVS     r4,#0
000202  e00a              B        |L1.538|
                  |L1.516|
;;;1512           ptcb1->OSTCBNext = ptcb2;
000204  615d              STR      r5,[r3,#0x14]
;;;1513   #if OS_TASK_NAME_SIZE > 1
;;;1514           ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
000206  203f              MOVS     r0,#0x3f
000208  f8830044          STRB     r0,[r3,#0x44]
;;;1515           ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
00020c  2100              MOVS     r1,#0
00020e  2045              MOVS     r0,#0x45
000210  54c1              STRB     r1,[r0,r3]
;;;1516   #endif
;;;1517           ptcb1++;
000212  3354              ADDS     r3,r3,#0x54
;;;1518           ptcb2++;
000214  3554              ADDS     r5,r5,#0x54
000216  1c60              ADDS     r0,r4,#1              ;1511
000218  b2c4              UXTB     r4,r0                 ;1511
                  |L1.538|
00021a  2c10              CMP      r4,#0x10              ;1511
00021c  d3f2              BCC      |L1.516|
;;;1519       }
;;;1520       ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
00021e  2000              MOVS     r0,#0
000220  6158              STR      r0,[r3,#0x14]
;;;1521   #if OS_TASK_NAME_SIZE > 1
;;;1522       ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
000222  203f              MOVS     r0,#0x3f
000224  f8830044          STRB     r0,[r3,#0x44]
;;;1523       ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
000228  2100              MOVS     r1,#0
00022a  2045              MOVS     r0,#0x45
00022c  54c1              STRB     r1,[r0,r3]
;;;1524   #endif
;;;1525       OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
00022e  2000              MOVS     r0,#0
000230  498b              LDR      r1,|L1.1120|
000232  6008              STR      r0,[r1,#0]  ; OSTCBList
;;;1526       OSTCBFreeList           = &OSTCBTbl[0];
000234  4888              LDR      r0,|L1.1112|
000236  498b              LDR      r1,|L1.1124|
000238  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1527   }
00023a  bd30              POP      {r4,r5,pc}
;;;1528   /*$PAGE*/
                          ENDP

                  OS_InitRdyList PROC
;;;1330   
;;;1331   static  void  OS_InitRdyList (void)
00023c  2200              MOVS     r2,#0
;;;1332   {
;;;1333       INT8U    i;
;;;1334   #if OS_LOWEST_PRIO <= 63
;;;1335       INT8U   *prdytbl;
;;;1336   #else
;;;1337       INT16U  *prdytbl;
;;;1338   #endif
;;;1339   
;;;1340   
;;;1341       OSRdyGrp      = 0;                                     /* Clear the ready list                     */
00023e  4b8a              LDR      r3,|L1.1128|
000240  701a              STRB     r2,[r3,#0]
;;;1342       prdytbl       = &OSRdyTbl[0];
000242  498a              LDR      r1,|L1.1132|
;;;1343       for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
000244  2000              MOVS     r0,#0
000246  e004              B        |L1.594|
                  |L1.584|
;;;1344           *prdytbl++ = 0;
000248  2200              MOVS     r2,#0
00024a  f8012b01          STRB     r2,[r1],#1
00024e  1c42              ADDS     r2,r0,#1              ;1343
000250  b2d0              UXTB     r0,r2                 ;1343
                  |L1.594|
000252  2804              CMP      r0,#4                 ;1343
000254  dbf8              BLT      |L1.584|
;;;1345       }
;;;1346   
;;;1347       OSPrioCur     = 0;
000256  2200              MOVS     r2,#0
000258  4b85              LDR      r3,|L1.1136|
00025a  701a              STRB     r2,[r3,#0]
;;;1348       OSPrioHighRdy = 0;
00025c  4b85              LDR      r3,|L1.1140|
00025e  701a              STRB     r2,[r3,#0]
;;;1349   
;;;1350       OSTCBHighRdy  = (OS_TCB *)0;
000260  4b85              LDR      r3,|L1.1144|
000262  601a              STR      r2,[r3,#0]  ; OSTCBHighRdy
;;;1351       OSTCBCur      = (OS_TCB *)0;
000264  4b85              LDR      r3,|L1.1148|
000266  601a              STR      r2,[r3,#0]  ; OSTCBCur
;;;1352   }
000268  4770              BX       lr
;;;1353   
                          ENDP

                  OS_InitMisc PROC
;;;1294   
;;;1295   static  void  OS_InitMisc (void)
00026a  2000              MOVS     r0,#0
;;;1296   {
;;;1297   #if OS_TIME_GET_SET_EN > 0
;;;1298       OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
00026c  4984              LDR      r1,|L1.1152|
00026e  6008              STR      r0,[r1,#0]  ; OSTime
;;;1299   #endif
;;;1300   
;;;1301       OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
000270  496f              LDR      r1,|L1.1072|
000272  7008              STRB     r0,[r1,#0]
;;;1302       OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
000274  4983              LDR      r1,|L1.1156|
000276  7008              STRB     r0,[r1,#0]
;;;1303   
;;;1304       OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
000278  4983              LDR      r1,|L1.1160|
00027a  7008              STRB     r0,[r1,#0]
;;;1305   
;;;1306       OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
00027c  4983              LDR      r1,|L1.1164|
00027e  7008              STRB     r0,[r1,#0]
;;;1307   
;;;1308       OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
000280  4983              LDR      r1,|L1.1168|
000282  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1309       OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
000284  496b              LDR      r1,|L1.1076|
000286  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1310   
;;;1311   #if OS_TASK_STAT_EN > 0
;;;1312       OSIdleCtrRun  = 0L;
;;;1313       OSIdleCtrMax  = 0L;
;;;1314       OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
;;;1315   #endif
;;;1316   }
000288  4770              BX       lr
;;;1317   /*$PAGE*/
                          ENDP

                  OSInit PROC
;;;553    
;;;554    void  OSInit (void)
00028a  b510              PUSH     {r4,lr}
;;;555    {
;;;556        OSInitHookBegin();                                           /* Call port specific initialization code   */
00028c  f7fffffe          BL       OSInitHookBegin
;;;557    
;;;558        OS_InitMisc();                                               /* Initialize miscellaneous variables       */
000290  f7fffffe          BL       OS_InitMisc
;;;559    
;;;560        OS_InitRdyList();                                            /* Initialize the Ready List                */
000294  f7fffffe          BL       OS_InitRdyList
;;;561    
;;;562        OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
000298  f7fffffe          BL       OS_InitTCBList
;;;563    
;;;564        OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
00029c  f7fffffe          BL       OS_InitEventList
;;;565    
;;;566    #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
;;;567        OS_FlagInit();                                               /* Initialize the event flag structures     */
;;;568    #endif
;;;569    
;;;570    #if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
;;;571        OS_MemInit();                                                /* Initialize the memory manager            */
0002a0  f7fffffe          BL       OS_MemInit
;;;572    #endif
;;;573    
;;;574    #if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
;;;575        OS_QInit();                                                  /* Initialize the message queue structures  */
0002a4  f7fffffe          BL       OS_QInit
;;;576    #endif
;;;577    
;;;578        OS_InitTaskIdle();                                           /* Create the Idle Task                     */
0002a8  f7fffffe          BL       OS_InitTaskIdle
;;;579    #if OS_TASK_STAT_EN > 0
;;;580        OS_InitTaskStat();                                           /* Create the Statistic Task                */
;;;581    #endif
;;;582    
;;;583    #if OS_TMR_EN > 0
;;;584        OSTmr_Init();                                                /* Initialize the Timer Manager             */
0002ac  f7fffffe          BL       OSTmr_Init
;;;585    #endif
;;;586    
;;;587        OSInitHookEnd();                                             /* Call port specific init. code            */
0002b0  f7fffffe          BL       OSInitHookEnd
;;;588    
;;;589    #if OS_DEBUG_EN > 0
;;;590        OSDebugInit();
;;;591    #endif
;;;592    }
0002b4  bd10              POP      {r4,pc}
;;;593    /*$PAGE*/
                          ENDP

                  OSIntEnter PROC
;;;618    
;;;619    void  OSIntEnter (void)
0002b6  4875              LDR      r0,|L1.1164|
;;;620    {
;;;621        if (OSRunning == OS_TRUE) {
0002b8  7800              LDRB     r0,[r0,#0]  ; OSRunning
0002ba  2801              CMP      r0,#1
0002bc  d108              BNE      |L1.720|
;;;622            if (OSIntNesting < 255u) {
0002be  485c              LDR      r0,|L1.1072|
0002c0  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
0002c2  28ff              CMP      r0,#0xff
0002c4  d204              BCS      |L1.720|
;;;623                OSIntNesting++;                      /* Increment ISR nesting level                        */
0002c6  485a              LDR      r0,|L1.1072|
0002c8  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
0002ca  1c40              ADDS     r0,r0,#1
0002cc  4958              LDR      r1,|L1.1072|
0002ce  7008              STRB     r0,[r1,#0]
                  |L1.720|
;;;624            }
;;;625        }
;;;626    }
0002d0  4770              BX       lr
;;;627    /*$PAGE*/
                          ENDP

                  OS_SchedNew PROC
;;;1647   
;;;1648   static  void  OS_SchedNew (void)
0002d2  4970              LDR      r1,|L1.1172|
;;;1649   {
;;;1650   #if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
;;;1651       INT8U   y;
;;;1652   
;;;1653   
;;;1654       y             = OSUnMapTbl[OSRdyGrp];
0002d4  4a64              LDR      r2,|L1.1128|
0002d6  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
0002d8  5c88              LDRB     r0,[r1,r2]
;;;1655       OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
0002da  4964              LDR      r1,|L1.1132|
0002dc  5c09              LDRB     r1,[r1,r0]
0002de  4a6d              LDR      r2,|L1.1172|
0002e0  5c51              LDRB     r1,[r2,r1]
0002e2  eb0101c0          ADD      r1,r1,r0,LSL #3
0002e6  4a63              LDR      r2,|L1.1140|
0002e8  7011              STRB     r1,[r2,#0]
;;;1656   #else                                            /* We support up to 256 tasks                         */
;;;1657       INT8U   y;
;;;1658       INT16U *ptbl;
;;;1659   
;;;1660   
;;;1661       if ((OSRdyGrp & 0xFF) != 0) {
;;;1662           y = OSUnMapTbl[OSRdyGrp & 0xFF];
;;;1663       } else {
;;;1664           y = OSUnMapTbl[(OSRdyGrp >> 8) & 0xFF] + 8;
;;;1665       }
;;;1666       ptbl = &OSRdyTbl[y];
;;;1667       if ((*ptbl & 0xFF) != 0) {
;;;1668           OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
;;;1669       } else {
;;;1670           OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
;;;1671       }
;;;1672   #endif
;;;1673   }
0002ea  4770              BX       lr
;;;1674   
                          ENDP

                  OSIntExit PROC
;;;646    
;;;647    void  OSIntExit (void)
0002ec  b510              PUSH     {r4,lr}
;;;648    {
;;;649    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;650        OS_CPU_SR  cpu_sr = 0;
0002ee  2400              MOVS     r4,#0
;;;651    #endif
;;;652    
;;;653    
;;;654    
;;;655        if (OSRunning == OS_TRUE) {
0002f0  4866              LDR      r0,|L1.1164|
0002f2  7800              LDRB     r0,[r0,#0]  ; OSRunning
0002f4  2801              CMP      r0,#1
0002f6  d130              BNE      |L1.858|
;;;656            OS_ENTER_CRITICAL();
0002f8  f7fffffe          BL       OS_CPU_SR_Save
0002fc  4604              MOV      r4,r0
;;;657            if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
0002fe  484c              LDR      r0,|L1.1072|
000300  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000302  2800              CMP      r0,#0
000304  dd04              BLE      |L1.784|
;;;658                OSIntNesting--;
000306  484a              LDR      r0,|L1.1072|
000308  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00030a  1e40              SUBS     r0,r0,#1
00030c  4948              LDR      r1,|L1.1072|
00030e  7008              STRB     r0,[r1,#0]
                  |L1.784|
;;;659            }
;;;660            if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
000310  4847              LDR      r0,|L1.1072|
000312  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000314  b9f0              CBNZ     r0,|L1.852|
;;;661                if (OSLockNesting == 0) {                      /* ... and not locked.                      */
000316  485b              LDR      r0,|L1.1156|
000318  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00031a  b9d8              CBNZ     r0,|L1.852|
;;;662                    OS_SchedNew();
00031c  f7fffffe          BL       OS_SchedNew
;;;663                    if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
000320  4854              LDR      r0,|L1.1140|
000322  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
000324  4952              LDR      r1,|L1.1136|
000326  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000328  4288              CMP      r0,r1
00032a  d013              BEQ      |L1.852|
;;;664                        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
00032c  484b              LDR      r0,|L1.1116|
00032e  4951              LDR      r1,|L1.1140|
000330  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
000332  f8500021          LDR      r0,[r0,r1,LSL #2]
000336  4950              LDR      r1,|L1.1144|
000338  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;665    #if OS_TASK_PROFILE_EN > 0
;;;666                        OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
00033a  4608              MOV      r0,r1
00033c  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
00033e  6b00              LDR      r0,[r0,#0x30]
000340  1c40              ADDS     r0,r0,#1
000342  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
000344  6308              STR      r0,[r1,#0x30]
;;;667    #endif
;;;668                        OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
000346  4852              LDR      r0,|L1.1168|
000348  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
00034a  1c40              ADDS     r0,r0,#1
00034c  4950              LDR      r1,|L1.1168|
00034e  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;669                        OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
000350  f7fffffe          BL       OSIntCtxSw
                  |L1.852|
;;;670                    }
;;;671                }
;;;672            }
;;;673            OS_EXIT_CRITICAL();
000354  4620              MOV      r0,r4
000356  f7fffffe          BL       OS_CPU_SR_Restore
                  |L1.858|
;;;674        }
;;;675    }
00035a  bd10              POP      {r4,pc}
;;;676    /*$PAGE*/
                          ENDP

                  OSStart PROC
;;;780    
;;;781    void  OSStart (void)
00035c  b510              PUSH     {r4,lr}
;;;782    {
;;;783        if (OSRunning == OS_FALSE) {
00035e  484b              LDR      r0,|L1.1164|
000360  7800              LDRB     r0,[r0,#0]  ; OSRunning
000362  b990              CBNZ     r0,|L1.906|
;;;784            OS_SchedNew();                               /* Find highest priority's task priority number   */
000364  f7fffffe          BL       OS_SchedNew
;;;785            OSPrioCur     = OSPrioHighRdy;
000368  4842              LDR      r0,|L1.1140|
00036a  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
00036c  4940              LDR      r1,|L1.1136|
00036e  7008              STRB     r0,[r1,#0]
;;;786            OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
000370  483a              LDR      r0,|L1.1116|
000372  4940              LDR      r1,|L1.1140|
000374  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
000376  f8500021          LDR      r0,[r0,r1,LSL #2]
00037a  493f              LDR      r1,|L1.1144|
00037c  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;787            OSTCBCur      = OSTCBHighRdy;
00037e  4608              MOV      r0,r1
000380  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000382  493e              LDR      r1,|L1.1148|
000384  6008              STR      r0,[r1,#0]  ; OSTCBCur
;;;788            OSStartHighRdy();                            /* Execute target specific code to start task     */
000386  f7fffffe          BL       OSStartHighRdy
                  |L1.906|
;;;789        }
;;;790    }
00038a  bd10              POP      {r4,pc}
;;;791    /*$PAGE*/
                          ENDP

                  OSTimeTick PROC
;;;846    
;;;847    void  OSTimeTick (void)
00038c  b570              PUSH     {r4-r6,lr}
;;;848    {
;;;849        OS_TCB    *ptcb;
;;;850    #if OS_TICK_STEP_EN > 0
;;;851        BOOLEAN    step;
;;;852    #endif
;;;853    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
;;;854        OS_CPU_SR  cpu_sr = 0;
00038e  2500              MOVS     r5,#0
;;;855    #endif
;;;856    
;;;857    
;;;858    
;;;859    #if OS_TIME_TICK_HOOK_EN > 0
;;;860        OSTimeTickHook();                                      /* Call user definable hook                     */
;;;861    #endif
;;;862    #if OS_TIME_GET_SET_EN > 0
;;;863        OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
000390  f7fffffe          BL       OS_CPU_SR_Save
000394  4605              MOV      r5,r0
;;;864        OSTime++;
000396  483a              LDR      r0,|L1.1152|
000398  6800              LDR      r0,[r0,#0]  ; OSTime
00039a  1c40              ADDS     r0,r0,#1
00039c  4938              LDR      r1,|L1.1152|
00039e  6008              STR      r0,[r1,#0]  ; OSTime
;;;865        OS_EXIT_CRITICAL();
0003a0  4628              MOV      r0,r5
0003a2  f7fffffe          BL       OS_CPU_SR_Restore
;;;866    #endif
;;;867        if (OSRunning == OS_TRUE) {
0003a6  4839              LDR      r0,|L1.1164|
0003a8  7800              LDRB     r0,[r0,#0]  ; OSRunning
0003aa  2801              CMP      r0,#1
0003ac  d13f              BNE      |L1.1070|
;;;868    #if OS_TICK_STEP_EN > 0
;;;869            switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
;;;870                case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
;;;871                     step = OS_TRUE;
;;;872                     break;
;;;873    
;;;874                case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
;;;875                     step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
;;;876                     break;
;;;877    
;;;878                case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
;;;879                     step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
;;;880                     OSTickStepState = OS_TICK_STEP_WAIT;
;;;881                     break;
;;;882    
;;;883                default:                                       /* Invalid case, correct situation              */
;;;884                     step            = OS_TRUE;
;;;885                     OSTickStepState = OS_TICK_STEP_DIS;
;;;886                     break;
;;;887            }
;;;888            if (step == OS_FALSE) {                            /* Return if waiting for step command           */
;;;889                return;
;;;890            }
;;;891    #endif
;;;892            ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
0003ae  482c              LDR      r0,|L1.1120|
0003b0  6804              LDR      r4,[r0,#0]  ; OSTCBList
;;;893            while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
0003b2  e038              B        |L1.1062|
                  |L1.948|
;;;894                OS_ENTER_CRITICAL();
0003b4  f7fffffe          BL       OS_CPU_SR_Save
0003b8  4605              MOV      r5,r0
;;;895                if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
0003ba  8ca0              LDRH     r0,[r4,#0x24]
0003bc  b378              CBZ      r0,|L1.1054|
;;;896                    if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
0003be  8ca0              LDRH     r0,[r4,#0x24]
0003c0  1e40              SUBS     r0,r0,#1
0003c2  0400              LSLS     r0,r0,#16
0003c4  0c00              LSRS     r0,r0,#16
0003c6  84a0              STRH     r0,[r4,#0x24]
0003c8  d129              BNE      |L1.1054|
;;;897                                                               /* Check for timeout                            */
;;;898                        if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
0003ca  f8940026          LDRB     r0,[r4,#0x26]
0003ce  f0100f37          TST      r0,#0x37
0003d2  d009              BEQ      |L1.1000|
;;;899                            ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
0003d4  f8140f26          LDRB     r0,[r4,#0x26]!
0003d8  f0200037          BIC      r0,r0,#0x37
0003dc  7020              STRB     r0,[r4,#0]
;;;900                            ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
0003de  2001              MOVS     r0,#1
0003e0  7060              STRB     r0,[r4,#1]
0003e2  f1a40426          SUB      r4,r4,#0x26
0003e6  e002              B        |L1.1006|
                  |L1.1000|
;;;901                        } else {
;;;902                            ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
0003e8  2000              MOVS     r0,#0
0003ea  f8840027          STRB     r0,[r4,#0x27]
                  |L1.1006|
;;;903                        }
;;;904    
;;;905                        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
0003ee  f8940026          LDRB     r0,[r4,#0x26]
0003f2  f0100f08          TST      r0,#8
0003f6  d112              BNE      |L1.1054|
;;;906                            OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
0003f8  f104042a          ADD      r4,r4,#0x2a
0003fc  78a0              LDRB     r0,[r4,#2]
0003fe  491a              LDR      r1,|L1.1128|
000400  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
000402  ea400001          ORR      r0,r0,r1
000406  4918              LDR      r1,|L1.1128|
000408  7008              STRB     r0,[r1,#0]
;;;907                            OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00040a  7820              LDRB     r0,[r4,#0]
00040c  4917              LDR      r1,|L1.1132|
00040e  5c08              LDRB     r0,[r1,r0]
000410  7861              LDRB     r1,[r4,#1]
000412  ea400001          ORR      r0,r0,r1
000416  f814192a          LDRB     r1,[r4],#-0x2a
00041a  4a14              LDR      r2,|L1.1132|
00041c  5450              STRB     r0,[r2,r1]
                  |L1.1054|
;;;908                        }
;;;909                    }
;;;910                }
;;;911                ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
00041e  6964              LDR      r4,[r4,#0x14]
;;;912                OS_EXIT_CRITICAL();
000420  4628              MOV      r0,r5
000422  f7fffffe          BL       OS_CPU_SR_Restore
                  |L1.1062|
000426  f8940028          LDRB     r0,[r4,#0x28]         ;893
00042a  281f              CMP      r0,#0x1f              ;893
00042c  d1c2              BNE      |L1.948|
                  |L1.1070|
;;;913            }
;;;914        }
;;;915    }
00042e  bd70              POP      {r4-r6,pc}
                  |L1.1072|
                          DCD      OSIntNesting
                  |L1.1076|
                          DCD      OSIdleCtr
                  |L1.1080|
                          DCD      OSTaskIdleStk
                  |L1.1084|
                          DCD      OSTaskIdleStk+0x1fc
                  |L1.1088|
000440  75432f4f          DCB      "uC/OS-II Idle",0
000444  532d4949
000448  2049646c
00044c  6500    
00044e  00                DCB      0
00044f  00                DCB      0
                  |L1.1104|
                          DCD      OSEventTbl
                  |L1.1108|
                          DCD      OSEventFreeList
                  |L1.1112|
                          DCD      OSTCBTbl
                  |L1.1116|
                          DCD      OSTCBPrioTbl
                  |L1.1120|
                          DCD      OSTCBList
                  |L1.1124|
                          DCD      OSTCBFreeList
                  |L1.1128|
                          DCD      OSRdyGrp
                  |L1.1132|
                          DCD      OSRdyTbl
                  |L1.1136|
                          DCD      OSPrioCur
                  |L1.1140|
                          DCD      OSPrioHighRdy
                  |L1.1144|
                          DCD      OSTCBHighRdy
                  |L1.1148|
                          DCD      OSTCBCur
                  |L1.1152|
                          DCD      OSTime
                  |L1.1156|
                          DCD      OSLockNesting
                  |L1.1160|
                          DCD      OSTaskCtr
                  |L1.1164|
                          DCD      OSRunning
                  |L1.1168|
                          DCD      OSCtxSwCtr
                  |L1.1172|
                          DCD      OSUnMapTbl
                          ENDP

                  OSVersion PROC
;;;931    
;;;932    INT16U  OSVersion (void)
000498  f44f708f          MOV      r0,#0x11e
;;;933    {
;;;934        return (OS_VERSION);
;;;935    }
00049c  4770              BX       lr
;;;936    
                          ENDP

                  OS_Dummy PROC
;;;950    #if OS_TASK_DEL_EN > 0
;;;951    void  OS_Dummy (void)
00049e  4770              BX       lr
;;;952    {
;;;953    }
;;;954    #endif
                          ENDP

                  OS_EventTaskRemove PROC
;;;1133   #if (OS_EVENT_EN)
;;;1134   void  OS_EventTaskRemove (OS_TCB   *ptcb,
0004a0  b510              PUSH     {r4,lr}
;;;1135                             OS_EVENT *pevent)
;;;1136   {
;;;1137       INT8U  y;
;;;1138   
;;;1139   
;;;1140       y                       =  ptcb->OSTCBY;
0004a2  f890202a          LDRB     r2,[r0,#0x2a]
;;;1141       pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
0004a6  f101030b          ADD      r3,r1,#0xb
0004aa  5c9b              LDRB     r3,[r3,r2]
0004ac  f890402b          LDRB     r4,[r0,#0x2b]
0004b0  43a3              BICS     r3,r3,r4
0004b2  f101040b          ADD      r4,r1,#0xb
0004b6  54a3              STRB     r3,[r4,r2]
;;;1142       if (pevent->OSEventTbl[y] == 0) {
0004b8  4623              MOV      r3,r4
0004ba  5c9b              LDRB     r3,[r3,r2]
0004bc  b923              CBNZ     r3,|L1.1224|
;;;1143           pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
0004be  7a8b              LDRB     r3,[r1,#0xa]
0004c0  f890402c          LDRB     r4,[r0,#0x2c]
0004c4  43a3              BICS     r3,r3,r4
0004c6  728b              STRB     r3,[r1,#0xa]
                  |L1.1224|
;;;1144       }
;;;1145   }
0004c8  bd10              POP      {r4,pc}
;;;1146   #endif
                          ENDP

                  OS_EventTaskRdy PROC
;;;984    #if (OS_EVENT_EN)
;;;985    INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
0004ca  e92d4ff0          PUSH     {r4-r11,lr}
;;;986    {
0004ce  4605              MOV      r5,r0
0004d0  460f              MOV      r7,r1
0004d2  4690              MOV      r8,r2
0004d4  4699              MOV      r9,r3
;;;987        OS_TCB  *ptcb;
;;;988        INT8U    y;
;;;989        INT8U    x;
;;;990        INT8U    prio;
;;;991    #if OS_LOWEST_PRIO > 63
;;;992        INT16U  *ptbl;
;;;993    #endif
;;;994    
;;;995    
;;;996    #if OS_LOWEST_PRIO <= 63
;;;997        y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
0004d6  7aa8              LDRB     r0,[r5,#0xa]
0004d8  499b              LDR      r1,|L1.1864|
0004da  5c0e              LDRB     r6,[r1,r0]
;;;998        x    = OSUnMapTbl[pevent->OSEventTbl[y]];
0004dc  f105000b          ADD      r0,r5,#0xb
0004e0  5d80              LDRB     r0,[r0,r6]
0004e2  f811b000          LDRB     r11,[r1,r0]
;;;999        prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
0004e6  eb0b00c6          ADD      r0,r11,r6,LSL #3
0004ea  f0000aff          AND      r10,r0,#0xff
;;;1000   #else
;;;1001       if ((pevent->OSEventGrp & 0xFF) != 0) {             /* Find HPT waiting for message                */
;;;1002           y = OSUnMapTbl[ pevent->OSEventGrp & 0xFF];
;;;1003       } else {
;;;1004           y = OSUnMapTbl[(pevent->OSEventGrp >> 8) & 0xFF] + 8;
;;;1005       }
;;;1006       ptbl = &pevent->OSEventTbl[y];
;;;1007       if ((*ptbl & 0xFF) != 0) {
;;;1008           x = OSUnMapTbl[*ptbl & 0xFF];
;;;1009       } else {
;;;1010           x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
;;;1011       }
;;;1012       prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
;;;1013   #endif
;;;1014   
;;;1015       ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
0004ee  4897              LDR      r0,|L1.1868|
0004f0  f850402a          LDR      r4,[r0,r10,LSL #2]
;;;1016       ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
0004f4  2000              MOVS     r0,#0
0004f6  f1040420          ADD      r4,r4,#0x20
0004fa  80a0              STRH     r0,[r4,#4]
;;;1017   #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
;;;1018       ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
0004fc  6027              STR      r7,[r4,#0]
;;;1019   #else
;;;1020       pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
;;;1021   #endif
;;;1022       ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
0004fe  79a0              LDRB     r0,[r4,#6]
000500  ea200008          BIC      r0,r0,r8
000504  71a0              STRB     r0,[r4,#6]
;;;1023       ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
000506  f8849007          STRB     r9,[r4,#7]
;;;1024                                                           /* See if task is ready (could be susp'd)      */
;;;1025       if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
00050a  79a0              LDRB     r0,[r4,#6]
00050c  f1a40420          SUB      r4,r4,#0x20
000510  f0100f08          TST      r0,#8
000514  d10d              BNE      |L1.1330|
;;;1026           OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
000516  f894002c          LDRB     r0,[r4,#0x2c]
00051a  498d              LDR      r1,|L1.1872|
00051c  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
00051e  4308              ORRS     r0,r0,r1
000520  498b              LDR      r1,|L1.1872|
000522  7008              STRB     r0,[r1,#0]
;;;1027           OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
000524  488b              LDR      r0,|L1.1876|
000526  5d80              LDRB     r0,[r0,r6]
000528  f894102b          LDRB     r1,[r4,#0x2b]
00052c  4308              ORRS     r0,r0,r1
00052e  4989              LDR      r1,|L1.1876|
000530  5588              STRB     r0,[r1,r6]
                  |L1.1330|
;;;1028       }
;;;1029   
;;;1030       OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
000532  4629              MOV      r1,r5
000534  4620              MOV      r0,r4
000536  f7fffffe          BL       OS_EventTaskRemove
;;;1031   #if (OS_EVENT_MULTI_EN > 0)
;;;1032       if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
;;;1033           OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
;;;1034           ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
;;;1035       }
;;;1036   #endif
;;;1037   
;;;1038       return (prio);
00053a  4650              MOV      r0,r10
;;;1039   }
00053c  e8bd8ff0          POP      {r4-r11,pc}
;;;1040   #endif
                          ENDP

                  OS_EventTaskWait PROC
;;;1056   #if (OS_EVENT_EN)
;;;1057   void  OS_EventTaskWait (OS_EVENT *pevent)
000540  b510              PUSH     {r4,lr}
;;;1058   {
;;;1059       INT8U  y;
;;;1060   
;;;1061   
;;;1062       OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
000542  4a85              LDR      r2,|L1.1880|
000544  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000546  61d0              STR      r0,[r2,#0x1c]
;;;1063   
;;;1064       pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
000548  4a83              LDR      r2,|L1.1880|
00054a  6812              LDR      r2,[r2,#0]  ; OSTCBCur
00054c  f892302a          LDRB     r3,[r2,#0x2a]
000550  f100020b          ADD      r2,r0,#0xb
000554  5cd2              LDRB     r2,[r2,r3]
000556  4b80              LDR      r3,|L1.1880|
000558  681b              LDR      r3,[r3,#0]  ; OSTCBCur
00055a  f893302b          LDRB     r3,[r3,#0x2b]
00055e  431a              ORRS     r2,r2,r3
000560  4b7d              LDR      r3,|L1.1880|
000562  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000564  f893402a          LDRB     r4,[r3,#0x2a]
000568  f100030b          ADD      r3,r0,#0xb
00056c  551a              STRB     r2,[r3,r4]
;;;1065       pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
00056e  7a82              LDRB     r2,[r0,#0xa]
000570  4b79              LDR      r3,|L1.1880|
000572  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000574  f893302c          LDRB     r3,[r3,#0x2c]
000578  431a              ORRS     r2,r2,r3
00057a  7282              STRB     r2,[r0,#0xa]
;;;1066   
;;;1067       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00057c  4a76              LDR      r2,|L1.1880|
00057e  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000580  f892102a          LDRB     r1,[r2,#0x2a]
;;;1068       OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
000584  4a73              LDR      r2,|L1.1876|
000586  5c52              LDRB     r2,[r2,r1]
000588  4b73              LDR      r3,|L1.1880|
00058a  681b              LDR      r3,[r3,#0]  ; OSTCBCur
00058c  f893302b          LDRB     r3,[r3,#0x2b]
000590  439a              BICS     r2,r2,r3
000592  4b70              LDR      r3,|L1.1876|
000594  545a              STRB     r2,[r3,r1]
;;;1069       if (OSRdyTbl[y] == 0) {
000596  461a              MOV      r2,r3
000598  5c52              LDRB     r2,[r2,r1]
00059a  b942              CBNZ     r2,|L1.1454|
;;;1070           OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
00059c  4a6e              LDR      r2,|L1.1880|
00059e  6812              LDR      r2,[r2,#0]  ; OSTCBCur
0005a0  f892302c          LDRB     r3,[r2,#0x2c]
0005a4  4a6a              LDR      r2,|L1.1872|
0005a6  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
0005a8  439a              BICS     r2,r2,r3
0005aa  4b69              LDR      r3,|L1.1872|
0005ac  701a              STRB     r2,[r3,#0]
                  |L1.1454|
;;;1071       }
;;;1072   }
0005ae  bd10              POP      {r4,pc}
;;;1073   #endif
                          ENDP

                  OS_EventWaitListInit PROC
;;;1208   #if (OS_EVENT_EN)
;;;1209   void  OS_EventWaitListInit (OS_EVENT *pevent)
0005b0  2300              MOVS     r3,#0
;;;1210   {
;;;1211   #if OS_LOWEST_PRIO <= 63
;;;1212       INT8U  *ptbl;
;;;1213   #else
;;;1214       INT16U *ptbl;
;;;1215   #endif
;;;1216       INT8U   i;
;;;1217   
;;;1218   
;;;1219       pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
0005b2  7283              STRB     r3,[r0,#0xa]
;;;1220       ptbl               = &pevent->OSEventTbl[0];
0005b4  f100010b          ADD      r1,r0,#0xb
;;;1221   
;;;1222       for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
0005b8  2200              MOVS     r2,#0
0005ba  e004              B        |L1.1478|
                  |L1.1468|
;;;1223           *ptbl++ = 0;
0005bc  2300              MOVS     r3,#0
0005be  f8013b01          STRB     r3,[r1],#1
0005c2  1c53              ADDS     r3,r2,#1              ;1222
0005c4  b2da              UXTB     r2,r3                 ;1222
                  |L1.1478|
0005c6  2a04              CMP      r2,#4                 ;1222
0005c8  dbf8              BLT      |L1.1468|
;;;1224       }
;;;1225   }
0005ca  4770              BX       lr
;;;1226   #endif
                          ENDP

                  OS_MemCopy PROC
;;;1580   
;;;1581   void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
0005cc  e005              B        |L1.1498|
                  |L1.1486|
;;;1582   {
;;;1583       while (size > 0) {
;;;1584           *pdest++ = *psrc++;
0005ce  f8113b01          LDRB     r3,[r1],#1
0005d2  f8003b01          STRB     r3,[r0],#1
;;;1585           size--;
0005d6  1e53              SUBS     r3,r2,#1
0005d8  b29a              UXTH     r2,r3
                  |L1.1498|
0005da  2a00              CMP      r2,#0                 ;1583
0005dc  dcf7              BGT      |L1.1486|
;;;1586       }
;;;1587   }
0005de  4770              BX       lr
;;;1588   /*$PAGE*/
                          ENDP

                  OS_Sched PROC
;;;1605   
;;;1606   void  OS_Sched (void)
0005e0  b510              PUSH     {r4,lr}
;;;1607   {
;;;1608   #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
;;;1609       OS_CPU_SR  cpu_sr = 0;
0005e2  2400              MOVS     r4,#0
;;;1610   #endif
;;;1611   
;;;1612   
;;;1613   
;;;1614       OS_ENTER_CRITICAL();
0005e4  f7fffffe          BL       OS_CPU_SR_Save
0005e8  4604              MOV      r4,r0
;;;1615       if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
0005ea  485c              LDR      r0,|L1.1884|
0005ec  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
0005ee  b9f0              CBNZ     r0,|L1.1582|
;;;1616           if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
0005f0  485b              LDR      r0,|L1.1888|
0005f2  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
0005f4  b9d8              CBNZ     r0,|L1.1582|
;;;1617               OS_SchedNew();
0005f6  f7fffffe          BL       OS_SchedNew
;;;1618               if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
0005fa  485a              LDR      r0,|L1.1892|
0005fc  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
0005fe  495a              LDR      r1,|L1.1896|
000600  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000602  4288              CMP      r0,r1
000604  d013              BEQ      |L1.1582|
;;;1619                   OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
000606  4851              LDR      r0,|L1.1868|
000608  4956              LDR      r1,|L1.1892|
00060a  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
00060c  f8500021          LDR      r0,[r0,r1,LSL #2]
000610  4956              LDR      r1,|L1.1900|
000612  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;1620   #if OS_TASK_PROFILE_EN > 0
;;;1621                   OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
000614  4608              MOV      r0,r1
000616  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000618  6b00              LDR      r0,[r0,#0x30]
00061a  1c40              ADDS     r0,r0,#1
00061c  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
00061e  6308              STR      r0,[r1,#0x30]
;;;1622   #endif
;;;1623                   OSCtxSwCtr++;                          /* Increment context switch counter             */
000620  4853              LDR      r0,|L1.1904|
000622  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
000624  1c40              ADDS     r0,r0,#1
000626  4952              LDR      r1,|L1.1904|
000628  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1624                   OS_TASK_SW();                          /* Perform a context switch                     */
00062a  f7fffffe          BL       OSCtxSw
                  |L1.1582|
;;;1625               }
;;;1626           }
;;;1627       }
;;;1628       OS_EXIT_CRITICAL();
00062e  4620              MOV      r0,r4
000630  f7fffffe          BL       OS_CPU_SR_Restore
;;;1629   }
000634  bd10              POP      {r4,pc}
;;;1630   
                          ENDP

                  OS_TCBInit PROC
;;;1921   
;;;1922   INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
000636  e92d4ff8          PUSH     {r3-r11,lr}
;;;1923   {
00063a  4605              MOV      r5,r0
00063c  460e              MOV      r6,r1
00063e  4617              MOV      r7,r2
000640  4698              MOV      r8,r3
000642  e9ddab0b          LDRD     r10,r11,[sp,#0x2c]
000646  f8dd9028          LDR      r9,[sp,#0x28]
;;;1924       OS_TCB    *ptcb;
;;;1925   #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;1926       OS_CPU_SR  cpu_sr = 0;
00064a  2000              MOVS     r0,#0
00064c  9000              STR      r0,[sp,#0]
;;;1927   #endif
;;;1928   
;;;1929   
;;;1930   
;;;1931       OS_ENTER_CRITICAL();
00064e  f7fffffe          BL       OS_CPU_SR_Save
000652  9000              STR      r0,[sp,#0]
;;;1932       ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
000654  4847              LDR      r0,|L1.1908|
000656  6804              LDR      r4,[r0,#0]  ; OSTCBFreeList
;;;1933       if (ptcb != (OS_TCB *)0) {
000658  2c00              CMP      r4,#0
00065a  d070              BEQ      |L1.1854|
;;;1934           OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
00065c  f8540f14          LDR      r0,[r4,#0x14]!
000660  4944              LDR      r1,|L1.1908|
000662  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1935           OS_EXIT_CRITICAL();
000664  9800              LDR      r0,[sp,#0]
000666  f7fffffe          BL       OS_CPU_SR_Restore
;;;1936           ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
00066a  f8446c14          STR      r6,[r4,#-0x14]
;;;1937           ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
00066e  7525              STRB     r5,[r4,#0x14]
;;;1938           ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
000670  2000              MOVS     r0,#0
000672  74a0              STRB     r0,[r4,#0x12]
;;;1939           ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
000674  74e0              STRB     r0,[r4,#0x13]
;;;1940           ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
000676  8220              STRH     r0,[r4,#0x10]
;;;1941   
;;;1942   #if OS_TASK_CREATE_EXT_EN > 0
;;;1943           ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
000678  f844ac10          STR      r10,[r4,#-0x10]
;;;1944           ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
00067c  f8449c08          STR      r9,[r4,#-8]
;;;1945           ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
000680  f8447c0c          STR      r7,[r4,#-0xc]
;;;1946           ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
000684  f824bc04          STRH     r11,[r4,#-4]
;;;1947           ptcb->OSTCBId            = id;                     /* Store task ID                            */
000688  f8248c02          STRH     r8,[r4,#-2]
;;;1948   #else
;;;1949           pext                     = pext;                   /* Prevent compiler warning if not used     */
;;;1950           stk_size                 = stk_size;
;;;1951           pbos                     = pbos;
;;;1952           opt                      = opt;
;;;1953           id                       = id;
;;;1954   #endif
;;;1955   
;;;1956   #if OS_TASK_DEL_EN > 0
;;;1957           ptcb->OSTCBDelReq        = OS_ERR_NONE;
00068c  7660              STRB     r0,[r4,#0x19]
;;;1958   #endif
;;;1959   
;;;1960   #if OS_LOWEST_PRIO <= 63
;;;1961           ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
00068e  10e8              ASRS     r0,r5,#3
000690  75a0              STRB     r0,[r4,#0x16]
;;;1962           ptcb->OSTCBX             = (INT8U)(prio & 0x07);
000692  f0050007          AND      r0,r5,#7
000696  7560              STRB     r0,[r4,#0x15]
;;;1963           ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
000698  7da1              LDRB     r1,[r4,#0x16]
00069a  2001              MOVS     r0,#1
00069c  4088              LSLS     r0,r0,r1
00069e  7620              STRB     r0,[r4,#0x18]
;;;1964           ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
0006a0  7d61              LDRB     r1,[r4,#0x15]
0006a2  2001              MOVS     r0,#1
0006a4  4088              LSLS     r0,r0,r1
0006a6  75e0              STRB     r0,[r4,#0x17]
;;;1965   #else
;;;1966           ptcb->OSTCBY             = (INT8U)((prio >> 4) & 0xFF); /* Pre-compute X, Y, BitX and BitY     */
;;;1967           ptcb->OSTCBX             = (INT8U) (prio & 0x0F);
;;;1968           ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
;;;1969           ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
;;;1970   #endif
;;;1971   
;;;1972   #if (OS_EVENT_EN)
;;;1973           ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
0006a8  2000              MOVS     r0,#0
0006aa  60a0              STR      r0,[r4,#8]
;;;1974   #if (OS_EVENT_MULTI_EN > 0)
;;;1975           ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
;;;1976   #endif
;;;1977   #endif
;;;1978   
;;;1979   #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
;;;1980           ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
;;;1981   #endif
;;;1982   
;;;1983   #if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
;;;1984           ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
0006ac  60e0              STR      r0,[r4,#0xc]
;;;1985   #endif
;;;1986   
;;;1987   #if OS_TASK_PROFILE_EN > 0
;;;1988           ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
0006ae  61e0              STR      r0,[r4,#0x1c]
;;;1989           ptcb->OSTCBCyclesStart = 0L;
0006b0  6260              STR      r0,[r4,#0x24]
;;;1990           ptcb->OSTCBCyclesTot   = 0L;
0006b2  6220              STR      r0,[r4,#0x20]
;;;1991           ptcb->OSTCBStkBase     = (OS_STK *)0;
0006b4  62a0              STR      r0,[r4,#0x28]
;;;1992           ptcb->OSTCBStkUsed     = 0L;
0006b6  62e0              STR      r0,[r4,#0x2c]
;;;1993   #endif
;;;1994   
;;;1995   #if OS_TASK_NAME_SIZE > 1
;;;1996           ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
0006b8  203f              MOVS     r0,#0x3f
0006ba  f8840030          STRB     r0,[r4,#0x30]
0006be  f1a40414          SUB      r4,r4,#0x14
;;;1997           ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
0006c2  f04f0100          MOV      r1,#0
0006c6  f04f0045          MOV      r0,#0x45
0006ca  5501              STRB     r1,[r0,r4]
;;;1998   #endif
;;;1999   
;;;2000           OSTCBInitHook(ptcb);
0006cc  4620              MOV      r0,r4
0006ce  f7fffffe          BL       OSTCBInitHook
;;;2001   
;;;2002           OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
0006d2  4620              MOV      r0,r4
0006d4  f7fffffe          BL       OSTaskCreateHook
;;;2003   
;;;2004           OS_ENTER_CRITICAL();
0006d8  f7fffffe          BL       OS_CPU_SR_Save
0006dc  9000              STR      r0,[sp,#0]
;;;2005           OSTCBPrioTbl[prio] = ptcb;
0006de  481b              LDR      r0,|L1.1868|
0006e0  f8404025          STR      r4,[r0,r5,LSL #2]
;;;2006           ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
0006e4  4824              LDR      r0,|L1.1912|
0006e6  6800              LDR      r0,[r0,#0]  ; OSTCBList
0006e8  6160              STR      r0,[r4,#0x14]
;;;2007           ptcb->OSTCBPrev    = (OS_TCB *)0;
0006ea  2000              MOVS     r0,#0
0006ec  61a0              STR      r0,[r4,#0x18]
;;;2008           if (OSTCBList != (OS_TCB *)0) {
0006ee  4822              LDR      r0,|L1.1912|
0006f0  6800              LDR      r0,[r0,#0]  ; OSTCBList
0006f2  b110              CBZ      r0,|L1.1786|
;;;2009               OSTCBList->OSTCBPrev = ptcb;
0006f4  4820              LDR      r0,|L1.1912|
0006f6  6800              LDR      r0,[r0,#0]  ; OSTCBList
0006f8  6184              STR      r4,[r0,#0x18]
                  |L1.1786|
;;;2010           }
;;;2011           OSTCBList               = ptcb;
0006fa  481f              LDR      r0,|L1.1912|
0006fc  6004              STR      r4,[r0,#0]  ; OSTCBList
;;;2012           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
0006fe  f104042a          ADD      r4,r4,#0x2a
000702  78a0              LDRB     r0,[r4,#2]
000704  4912              LDR      r1,|L1.1872|
000706  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
000708  ea400001          ORR      r0,r0,r1
00070c  4910              LDR      r1,|L1.1872|
00070e  7008              STRB     r0,[r1,#0]
;;;2013           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000710  7820              LDRB     r0,[r4,#0]
000712  4910              LDR      r1,|L1.1876|
000714  5c08              LDRB     r0,[r1,r0]
000716  7861              LDRB     r1,[r4,#1]
000718  ea400001          ORR      r0,r0,r1
00071c  f814192a          LDRB     r1,[r4],#-0x2a
000720  4a0c              LDR      r2,|L1.1876|
000722  5450              STRB     r0,[r2,r1]
;;;2014           OSTaskCtr++;                                       /* Increment the #tasks counter             */
000724  4815              LDR      r0,|L1.1916|
000726  7800              LDRB     r0,[r0,#0]  ; OSTaskCtr
000728  f1000001          ADD      r0,r0,#1
00072c  4913              LDR      r1,|L1.1916|
00072e  7008              STRB     r0,[r1,#0]
;;;2015           OS_EXIT_CRITICAL();
000730  9800              LDR      r0,[sp,#0]
000732  f7fffffe          BL       OS_CPU_SR_Restore
;;;2016           return (OS_ERR_NONE);
000736  2000              MOVS     r0,#0
                  |L1.1848|
;;;2017       }
;;;2018       OS_EXIT_CRITICAL();
;;;2019       return (OS_ERR_TASK_NO_MORE_TCB);
;;;2020   }
000738  e8bd8ff8          POP      {r3-r11,pc}
00073c  e7ff              B        |L1.1854|
                  |L1.1854|
00073e  9800              LDR      r0,[sp,#0]            ;2018
000740  f7fffffe          BL       OS_CPU_SR_Restore
000744  2042              MOVS     r0,#0x42              ;2019
000746  e7f7              B        |L1.1848|
                          ENDP

                  |L1.1864|
                          DCD      OSUnMapTbl
                  |L1.1868|
                          DCD      OSTCBPrioTbl
                  |L1.1872|
                          DCD      OSRdyGrp
                  |L1.1876|
                          DCD      OSRdyTbl
                  |L1.1880|
                          DCD      OSTCBCur
                  |L1.1884|
                          DCD      OSIntNesting
                  |L1.1888|
                          DCD      OSLockNesting
                  |L1.1892|
                          DCD      OSPrioHighRdy
                  |L1.1896|
                          DCD      OSPrioCur
                  |L1.1900|
                          DCD      OSTCBHighRdy
                  |L1.1904|
                          DCD      OSCtxSwCtr
                  |L1.1908|
                          DCD      OSTCBFreeList
                  |L1.1912|
                          DCD      OSTCBList
                  |L1.1916|
                          DCD      OSTaskCtr

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  OSEventTbl
                          %        320
                  OSTaskIdleStk
                          %        512
                  OSTCBPrioTbl
                          %        128
                  OSTCBTbl
                          %        1428
                  OSMemTbl
                          %        180
                  OSQTbl
                          %        96
                  OSTmrTbl
                          %        832
                  OSTmrTaskStk
                          %        512
                  OSTmrWheelTbl
                          %        64

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  OSUnMapTbl
000000  00000100          DCB      0x00,0x00,0x01,0x00
000004  02000100          DCB      0x02,0x00,0x01,0x00
000008  03000100          DCB      0x03,0x00,0x01,0x00
00000c  02000100          DCB      0x02,0x00,0x01,0x00
000010  04000100          DCB      0x04,0x00,0x01,0x00
000014  02000100          DCB      0x02,0x00,0x01,0x00
000018  03000100          DCB      0x03,0x00,0x01,0x00
00001c  02000100          DCB      0x02,0x00,0x01,0x00
000020  05000100          DCB      0x05,0x00,0x01,0x00
000024  02000100          DCB      0x02,0x00,0x01,0x00
000028  03000100          DCB      0x03,0x00,0x01,0x00
00002c  02000100          DCB      0x02,0x00,0x01,0x00
000030  04000100          DCB      0x04,0x00,0x01,0x00
000034  02000100          DCB      0x02,0x00,0x01,0x00
000038  03000100          DCB      0x03,0x00,0x01,0x00
00003c  02000100          DCB      0x02,0x00,0x01,0x00
000040  06000100          DCB      0x06,0x00,0x01,0x00
000044  02000100          DCB      0x02,0x00,0x01,0x00
000048  03000100          DCB      0x03,0x00,0x01,0x00
00004c  02000100          DCB      0x02,0x00,0x01,0x00
000050  04000100          DCB      0x04,0x00,0x01,0x00
000054  02000100          DCB      0x02,0x00,0x01,0x00
000058  03000100          DCB      0x03,0x00,0x01,0x00
00005c  02000100          DCB      0x02,0x00,0x01,0x00
000060  05000100          DCB      0x05,0x00,0x01,0x00
000064  02000100          DCB      0x02,0x00,0x01,0x00
000068  03000100          DCB      0x03,0x00,0x01,0x00
00006c  02000100          DCB      0x02,0x00,0x01,0x00
000070  04000100          DCB      0x04,0x00,0x01,0x00
000074  02000100          DCB      0x02,0x00,0x01,0x00
000078  03000100          DCB      0x03,0x00,0x01,0x00
00007c  02000100          DCB      0x02,0x00,0x01,0x00
000080  07000100          DCB      0x07,0x00,0x01,0x00
000084  02000100          DCB      0x02,0x00,0x01,0x00
000088  03000100          DCB      0x03,0x00,0x01,0x00
00008c  02000100          DCB      0x02,0x00,0x01,0x00
000090  04000100          DCB      0x04,0x00,0x01,0x00
000094  02000100          DCB      0x02,0x00,0x01,0x00
000098  03000100          DCB      0x03,0x00,0x01,0x00
00009c  02000100          DCB      0x02,0x00,0x01,0x00
0000a0  05000100          DCB      0x05,0x00,0x01,0x00
0000a4  02000100          DCB      0x02,0x00,0x01,0x00
0000a8  03000100          DCB      0x03,0x00,0x01,0x00
0000ac  02000100          DCB      0x02,0x00,0x01,0x00
0000b0  04000100          DCB      0x04,0x00,0x01,0x00
0000b4  02000100          DCB      0x02,0x00,0x01,0x00
0000b8  03000100          DCB      0x03,0x00,0x01,0x00
0000bc  02000100          DCB      0x02,0x00,0x01,0x00
0000c0  06000100          DCB      0x06,0x00,0x01,0x00
0000c4  02000100          DCB      0x02,0x00,0x01,0x00
0000c8  03000100          DCB      0x03,0x00,0x01,0x00
0000cc  02000100          DCB      0x02,0x00,0x01,0x00
0000d0  04000100          DCB      0x04,0x00,0x01,0x00
0000d4  02000100          DCB      0x02,0x00,0x01,0x00
0000d8  03000100          DCB      0x03,0x00,0x01,0x00
0000dc  02000100          DCB      0x02,0x00,0x01,0x00
0000e0  05000100          DCB      0x05,0x00,0x01,0x00
0000e4  02000100          DCB      0x02,0x00,0x01,0x00
0000e8  03000100          DCB      0x03,0x00,0x01,0x00
0000ec  02000100          DCB      0x02,0x00,0x01,0x00
0000f0  04000100          DCB      0x04,0x00,0x01,0x00
0000f4  02000100          DCB      0x02,0x00,0x01,0x00
0000f8  03000100          DCB      0x03,0x00,0x01,0x00
0000fc  02000100          DCB      0x02,0x00,0x01,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  OSCtxSwCtr
                          DCD      0x00000000
                  OSEventFreeList
                          DCD      0x00000000
                  OSIntNesting
000008  00                DCB      0x00
                  OSLockNesting
000009  00                DCB      0x00
                  OSPrioCur
00000a  00                DCB      0x00
                  OSPrioHighRdy
00000b  00                DCB      0x00
                  OSRdyGrp
00000c  00                DCB      0x00
                  OSRdyTbl
00000d  000000            DCB      0x00,0x00,0x00
000010  00                DCB      0x00
                  OSRunning
000011  00                DCB      0x00
                  OSTaskCtr
000012  0000              DCB      0x00,0x00
                  OSIdleCtr
                          DCD      0x00000000
                  OSTCBCur
                          DCD      0x00000000
                  OSTCBFreeList
                          DCD      0x00000000
                  OSTCBHighRdy
                          DCD      0x00000000
                  OSTCBList
                          DCD      0x00000000
                  OSMemFreeList
                          DCD      0x00000000
                  OSQFreeList
                          DCD      0x00000000
                  OSTime
                          DCD      0x00000000
                  OSTmrFree
000034  0000              DCB      0x00,0x00
                  OSTmrUsed
000036  0000              DCB      0x00,0x00
                  OSTmrTime
                          DCD      0x00000000
                  OSTmrSem
                          DCD      0x00000000
                  OSTmrSemSignal
                          DCD      0x00000000
                  OSTmrFreeList
                          DCD      0x00000000
