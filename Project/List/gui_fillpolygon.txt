; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Obj\gui_fillpolygon.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\Obj\gui_fillpolygon.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\BaseDrive -I..\Ucosii -I..\Ucosii\Port -I..\Ucosii\Src -I..\Ucosii\Include -I..\Ucgui -I..\Ucgui\Config -I..\Ucgui\GUI_X -I..\Ucgui\GUI -I..\Ucgui\GUI\ConvertColor -I..\Ucgui\GUI\ConvertMono -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\LCDDriver -I..\Ucgui\GUI\MultiLayer -I..\Ucgui\GUI\Widget -I..\Ucgui\GUI\WM -I..\ExternalDrive\Lcd -I..\ExternalDrive\Touch -I..\Panel -I"D:\Program files\Keil\ARM\RV31\Inc" -I"D:\Program files\Keil\ARM\CMSIS\Include" -I"D:\Program files\Keil\ARM\Inc\ST\STM32F10x" -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\gui_fillpolygon.crf ..\Ucgui\GUI\Core\GUI_FillPolygon.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _DrawHLine PROC
;;;52     */
;;;53     static void _DrawHLine(int x0, int y, int x1) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;54       if (x0 < x1) {
000008  42ac              CMP      r4,r5
00000a  da05              BGE      |L1.24|
;;;55         LCD_HL_DrawHLine(x0, y, x1);
00000c  462a              MOV      r2,r5
00000e  4631              MOV      r1,r6
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       LCD_DrawHLine
000016  e004              B        |L1.34|
                  |L1.24|
;;;56       } else {
;;;57         LCD_HL_DrawHLine(x1, y, x0);
000018  4622              MOV      r2,r4
00001a  4631              MOV      r1,r6
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       LCD_DrawHLine
                  |L1.34|
;;;58       }
;;;59     }
000022  bd70              POP      {r4-r6,pc}
;;;60     
                          ENDP

                  _CheckYInterSect PROC
;;;74     */
;;;75     static int _CheckYInterSect(int y, int* px, const GUI_POINT*paPoint0, const GUI_POINT*paPoint1) {
000024  e92d43f0          PUSH     {r4-r9,lr}
000028  4604              MOV      r4,r0
00002a  468c              MOV      r12,r1
00002c  4615              MOV      r5,r2
;;;76       int x0, y0, x1, y1;
;;;77       if (paPoint0->y <= (paPoint1)->y) {
00002e  f9b50002          LDRSH    r0,[r5,#2]
000032  f9b38002          LDRSH    r8,[r3,#2]
000036  4540              CMP      r0,r8
000038  dc11              BGT      |L1.94|
;;;78         y0 = paPoint0->y;
00003a  f9b51002          LDRSH    r1,[r5,#2]
;;;79         if (y0 > y)      /* Check if there is an intersection ... (early out) */
00003e  42a1              CMP      r1,r4
000040  dd02              BLE      |L1.72|
;;;80           return 0;
000042  2000              MOVS     r0,#0
                  |L1.68|
;;;81         y1 = paPoint1->y;
;;;82         if (y1 < y)      /* Check if there is an intersection ... (early out) */
;;;83           return 0;
;;;84         x0 = paPoint0->x;
;;;85         x1 = paPoint1->x;
;;;86       } else {
;;;87         y0 = paPoint1->y;
;;;88         if (y0 > y)      /* Check if there is an intersection ... (early out) */
;;;89           return 0;
;;;90         y1 = paPoint0->y;
;;;91         if (y1 < y)      /* Check if there is an intersection ... (early out) */
;;;92           return 0;
;;;93         x0 = paPoint1->x;
;;;94         x1 = paPoint0->x;
;;;95       }
;;;96     /* Calculate intersection */
;;;97       {
;;;98         I32 Mul = (I32)(x1 - x0) * (I32)(y - y0);
;;;99         if (Mul > 0) {
;;;100          Mul += (y1 - y0) >> 1;	          /* for proper rounding */
;;;101        } else {
;;;102          Mul -= ((y1 - y0) >> 1) - 1;	    /* for proper rounding */
;;;103        }
;;;104        x0 += Mul / (y1 - y0);
;;;105      }
;;;106      *px = x0;
;;;107      return 1;
;;;108    } 
000044  e8bd83f0          POP      {r4-r9,pc}
                  |L1.72|
000048  f9b32002          LDRSH    r2,[r3,#2]            ;81
00004c  42a2              CMP      r2,r4                 ;82
00004e  da01              BGE      |L1.84|
000050  2000              MOVS     r0,#0                 ;83
000052  e7f7              B        |L1.68|
                  |L1.84|
000054  f9b56000          LDRSH    r6,[r5,#0]            ;84
000058  f9b37000          LDRSH    r7,[r3,#0]            ;85
00005c  e00f              B        |L1.126|
                  |L1.94|
00005e  f9b31002          LDRSH    r1,[r3,#2]            ;87
000062  42a1              CMP      r1,r4                 ;88
000064  dd01              BLE      |L1.106|
000066  2000              MOVS     r0,#0                 ;89
000068  e7ec              B        |L1.68|
                  |L1.106|
00006a  f9b52002          LDRSH    r2,[r5,#2]            ;90
00006e  42a2              CMP      r2,r4                 ;91
000070  da01              BGE      |L1.118|
000072  2000              MOVS     r0,#0                 ;92
000074  e7e6              B        |L1.68|
                  |L1.118|
000076  f9b36000          LDRSH    r6,[r3,#0]            ;93
00007a  f9b57000          LDRSH    r7,[r5,#0]            ;94
                  |L1.126|
00007e  eba70806          SUB      r8,r7,r6              ;98
000082  eba40901          SUB      r9,r4,r1              ;98
000086  fb08f009          MUL      r0,r8,r9              ;98
00008a  2800              CMP      r0,#0                 ;99
00008c  dd04              BLE      |L1.152|
00008e  eba20801          SUB      r8,r2,r1              ;100
000092  eb000068          ADD      r0,r0,r8,ASR #1       ;100
000096  e007              B        |L1.168|
                  |L1.152|
000098  eba20801          SUB      r8,r2,r1              ;102
00009c  f04f0901          MOV      r9,#1                 ;102
0000a0  ebc90868          RSB      r8,r9,r8,ASR #1       ;102
0000a4  eba00008          SUB      r0,r0,r8              ;102
                  |L1.168|
0000a8  eba20801          SUB      r8,r2,r1              ;104
0000ac  fb90f8f8          SDIV     r8,r0,r8              ;104
0000b0  4446              ADD      r6,r6,r8              ;104
0000b2  f8cc6000          STR      r6,[r12,#0]           ;106
0000b6  2001              MOVS     r0,#1                 ;107
0000b8  e7c4              B        |L1.68|
;;;109    
                          ENDP

                  _Add PROC
;;;115    */
;;;116    static void _Add(int x) {
0000ba  4601              MOV      r1,r0
;;;117      if (GL_FP_Cnt < GUI_FP_MAXCOUNT) {
0000bc  4899              LDR      r0,|L1.804|
0000be  6800              LDR      r0,[r0,#0]  ; GL_FP_Cnt
0000c0  280c              CMP      r0,#0xc
0000c2  da1d              BGE      |L1.256|
;;;118        int i;
;;;119        /* Move all entries to the right (bigger x-value) */
;;;120        for (i=GL_FP_Cnt; i ; i--) {
0000c4  4a97              LDR      r2,|L1.804|
0000c6  6810              LDR      r0,[r2,#0]  ; GL_FP_Cnt
0000c8  e00d              B        |L1.230|
                  |L1.202|
;;;121          if (_aX[i-1] < x)
0000ca  1e42              SUBS     r2,r0,#1
0000cc  4b96              LDR      r3,|L1.808|
0000ce  f9332012          LDRSH    r2,[r3,r2,LSL #1]
0000d2  428a              CMP      r2,r1
0000d4  da00              BGE      |L1.216|
;;;122            break;
0000d6  e008              B        |L1.234|
                  |L1.216|
;;;123          _aX[i] = _aX[i-1];
0000d8  1e42              SUBS     r2,r0,#1
0000da  4b93              LDR      r3,|L1.808|
0000dc  f8332012          LDRH     r2,[r3,r2,LSL #1]
0000e0  f8232010          STRH     r2,[r3,r0,LSL #1]
0000e4  1e40              SUBS     r0,r0,#1              ;120
                  |L1.230|
0000e6  2800              CMP      r0,#0                 ;120
0000e8  d1ef              BNE      |L1.202|
                  |L1.234|
0000ea  bf00              NOP                            ;122
;;;124        }
;;;125        /* Insert new entry */
;;;126        _aX[i]    = x;
0000ec  b20a              SXTH     r2,r1
0000ee  4b8e              LDR      r3,|L1.808|
0000f0  f8232010          STRH     r2,[r3,r0,LSL #1]
;;;127        GL_FP_Cnt++;
0000f4  4a8b              LDR      r2,|L1.804|
0000f6  6812              LDR      r2,[r2,#0]  ; GL_FP_Cnt
0000f8  1c52              ADDS     r2,r2,#1
0000fa  4b8a              LDR      r3,|L1.804|
0000fc  601a              STR      r2,[r3,#0]  ; GL_FP_Cnt
;;;128      }
0000fe  bf00              NOP      
                  |L1.256|
;;;129    }
000100  4770              BX       lr
;;;130    
                          ENDP

                  _Init PROC
;;;136    */
;;;137    static void _Init(void) {
000102  2000              MOVS     r0,#0
;;;138      GL_FP_Cnt = 0;
000104  4987              LDR      r1,|L1.804|
000106  6008              STR      r0,[r1,#0]  ; GL_FP_Cnt
;;;139    }
000108  4770              BX       lr
;;;140    
                          ENDP

                  _Flush PROC
;;;146    */
;;;147    static void _Flush(int x0, int y) {
00010a  e92d47f0          PUSH     {r4-r10,lr}
00010e  4604              MOV      r4,r0
000110  4688              MOV      r8,r1
;;;148      int i, x = 0;
000112  f04f0900          MOV      r9,#0
;;;149      char On=0;
000116  2600              MOVS     r6,#0
;;;150      for (i=0; i<GL_FP_Cnt; i++) {
000118  2500              MOVS     r5,#0
00011a  e00d              B        |L1.312|
                  |L1.284|
;;;151        int xNew = _aX[i];
00011c  4882              LDR      r0,|L1.808|
00011e  f9307015          LDRSH    r7,[r0,r5,LSL #1]
;;;152        if (On) {
000122  b12e              CBZ      r6,|L1.304|
;;;153          LCD_HL_DrawHLine(x0 + x, y, x0 + xNew);
000124  19e2              ADDS     r2,r4,r7
000126  eb040009          ADD      r0,r4,r9
00012a  4641              MOV      r1,r8
00012c  f7fffffe          BL       LCD_DrawHLine
                  |L1.304|
;;;154        }
;;;155        On ^= 1;
000130  f0860601          EOR      r6,r6,#1
;;;156        x = xNew;
000134  46b9              MOV      r9,r7
000136  1c6d              ADDS     r5,r5,#1              ;150
                  |L1.312|
000138  487a              LDR      r0,|L1.804|
00013a  6800              LDR      r0,[r0,#0]            ;150  ; GL_FP_Cnt
00013c  4285              CMP      r5,r0                 ;150
00013e  dbed              BLT      |L1.284|
;;;157      }
;;;158    }
000140  e8bd87f0          POP      {r4-r10,pc}
;;;159    
                          ENDP

                  _AddPoint PROC
;;;167    */
;;;168    static void _AddPoint(int x, int y, int y0, int y1, int xOff, int yOff) {
000144  e92d47f0          PUSH     {r4-r10,lr}
000148  4604              MOV      r4,r0
00014a  460d              MOV      r5,r1
00014c  4616              MOV      r6,r2
00014e  461f              MOV      r7,r3
000150  e9dd8908          LDRD     r8,r9,[sp,#0x20]
;;;169      if ((y0 ^ y1) >= 0) {
000154  ea960007          EORS     r0,r6,r7
000158  d407              BMI      |L1.362|
;;;170        x += xOff;
00015a  4444              ADD      r4,r4,r8
;;;171        LCD_HL_DrawHLine(x, y + yOff, x);    /* V-point, not crossing the polygon */
00015c  eb050109          ADD      r1,r5,r9
000160  4622              MOV      r2,r4
000162  4620              MOV      r0,r4
000164  f7fffffe          BL       LCD_DrawHLine
000168  e002              B        |L1.368|
                  |L1.362|
;;;172      } else {
;;;173        _Add(x);
00016a  4620              MOV      r0,r4
00016c  f7fffffe          BL       _Add
                  |L1.368|
;;;174      }
;;;175    }
000170  e8bd87f0          POP      {r4-r10,pc}
;;;176    
                          ENDP

                  _GetPrevPointDiffy PROC
;;;182    */
;;;183    static int _GetPrevPointDiffy(const GUI_POINT* paPoint, int i,
000174  b570              PUSH     {r4-r6,lr}
;;;184                                  const int NumPoints, const int y0) {
000176  4605              MOV      r5,r0
;;;185      int j, y1;
;;;186      for (j = 0; j < (NumPoints - 1) ; j++) {
000178  2600              MOVS     r6,#0
00017a  e00d              B        |L1.408|
                  |L1.380|
;;;187        i = (i != 0) ? i - 1 : NumPoints - 1;
00017c  b109              CBZ      r1,|L1.386|
00017e  1e48              SUBS     r0,r1,#1
000180  e000              B        |L1.388|
                  |L1.386|
000182  1e50              SUBS     r0,r2,#1
                  |L1.388|
000184  4601              MOV      r1,r0
;;;188        y1 = (paPoint + i)->y;
000186  eb050081          ADD      r0,r5,r1,LSL #2
00018a  f9b04002          LDRSH    r4,[r0,#2]
;;;189        if (y1 != y0) {
00018e  429c              CMP      r4,r3
000190  d001              BEQ      |L1.406|
;;;190          return y1;
000192  4620              MOV      r0,r4
                  |L1.404|
;;;191        }
;;;192      }
;;;193      return y0;
;;;194    }
000194  bd70              POP      {r4-r6,pc}
                  |L1.406|
000196  1c76              ADDS     r6,r6,#1              ;186
                  |L1.408|
000198  1e50              SUBS     r0,r2,#1              ;186
00019a  42b0              CMP      r0,r6                 ;186
00019c  dcee              BGT      |L1.380|
00019e  4618              MOV      r0,r3                 ;193
0001a0  e7f8              B        |L1.404|
;;;195    
                          ENDP

                  GL_FillPolygon PROC
;;;207    */
;;;208    void GL_FillPolygon  (const GUI_POINT*paPoint, int NumPoints, int xOff, int yOff) {
0001a2  e92d4ff0          PUSH     {r4-r11,lr}
0001a6  b087              SUB      sp,sp,#0x1c
0001a8  4606              MOV      r6,r0
0001aa  4689              MOV      r9,r1
0001ac  4692              MOV      r10,r2
0001ae  461f              MOV      r7,r3
;;;209      int i, y;
;;;210      int yMin = GUI_YMAX;
0001b0  f64070ff          MOV      r0,#0xfff
0001b4  9006              STR      r0,[sp,#0x18]
;;;211      int yMax = GUI_YMIN;
0001b6  4240              RSBS     r0,r0,#0
0001b8  9005              STR      r0,[sp,#0x14]
;;;212    /* First step : find uppermost and lowermost coordinates */
;;;213      for (i=0; i<NumPoints; i++) {
0001ba  2500              MOVS     r5,#0
0001bc  e00c              B        |L1.472|
                  |L1.446|
;;;214        y = (paPoint + i)->y;
0001be  eb060085          ADD      r0,r6,r5,LSL #2
0001c2  f9b04002          LDRSH    r4,[r0,#2]
;;;215        if (y < yMin)
0001c6  9806              LDR      r0,[sp,#0x18]
0001c8  4284              CMP      r4,r0
0001ca  da00              BGE      |L1.462|
;;;216          yMin = y;
0001cc  9406              STR      r4,[sp,#0x18]
                  |L1.462|
;;;217        if (y > yMax)
0001ce  9805              LDR      r0,[sp,#0x14]
0001d0  4284              CMP      r4,r0
0001d2  dd00              BLE      |L1.470|
;;;218          yMax = y;
0001d4  9405              STR      r4,[sp,#0x14]
                  |L1.470|
0001d6  1c6d              ADDS     r5,r5,#1              ;213
                  |L1.472|
0001d8  454d              CMP      r5,r9                 ;213
0001da  dbf0              BLT      |L1.446|
;;;219      }
;;;220    /* Use Clipping rect to reduce calculation (if possible) */
;;;221      if (GUI_Context.pClipRect_HL) {
0001dc  4853              LDR      r0,|L1.812|
0001de  6900              LDR      r0,[r0,#0x10]  ; GUI_Context
0001e0  b1d8              CBZ      r0,|L1.538|
;;;222        if (yMax > (GUI_Context.pClipRect_HL->y1 - yOff))
0001e2  4852              LDR      r0,|L1.812|
0001e4  6900              LDR      r0,[r0,#0x10]  ; GUI_Context
0001e6  f9b00006          LDRSH    r0,[r0,#6]
0001ea  1bc1              SUBS     r1,r0,r7
0001ec  9805              LDR      r0,[sp,#0x14]
0001ee  4281              CMP      r1,r0
0001f0  da05              BGE      |L1.510|
;;;223          yMax = (GUI_Context.pClipRect_HL->y1 - yOff);
0001f2  484e              LDR      r0,|L1.812|
0001f4  6900              LDR      r0,[r0,#0x10]  ; GUI_Context
0001f6  f9b00006          LDRSH    r0,[r0,#6]
0001fa  1bc0              SUBS     r0,r0,r7
0001fc  9005              STR      r0,[sp,#0x14]
                  |L1.510|
;;;224        if (yMin < (GUI_Context.pClipRect_HL->y0 - yOff))
0001fe  484b              LDR      r0,|L1.812|
000200  6900              LDR      r0,[r0,#0x10]  ; GUI_Context
000202  f9b00002          LDRSH    r0,[r0,#2]
000206  1bc1              SUBS     r1,r0,r7
000208  9806              LDR      r0,[sp,#0x18]
00020a  4281              CMP      r1,r0
00020c  dd05              BLE      |L1.538|
;;;225          yMin = (GUI_Context.pClipRect_HL->y0 - yOff);
00020e  4847              LDR      r0,|L1.812|
000210  6900              LDR      r0,[r0,#0x10]  ; GUI_Context
000212  f9b00002          LDRSH    r0,[r0,#2]
000216  1bc0              SUBS     r0,r0,r7
000218  9006              STR      r0,[sp,#0x18]
                  |L1.538|
;;;226      }
;;;227    /* Second step: Calculate and draw horizontal lines */
;;;228      for (y=yMin; y<=yMax; y++) {
00021a  9c06              LDR      r4,[sp,#0x18]
00021c  e05b              B        |L1.726|
                  |L1.542|
;;;229        _Init();
00021e  f7fffffe          BL       _Init
;;;230        /* find next intersection and count lines*/
;;;231        for (i=0; i<NumPoints; i++) {
000222  2500              MOVS     r5,#0
000224  e050              B        |L1.712|
                  |L1.550|
;;;232          int i1 = (i < (NumPoints - 1)) ? i + 1 : 0;
000226  f1a90001          SUB      r0,r9,#1
00022a  42a8              CMP      r0,r5
00022c  dd01              BLE      |L1.562|
00022e  1c68              ADDS     r0,r5,#1
000230  e000              B        |L1.564|
                  |L1.562|
000232  2000              MOVS     r0,#0
                  |L1.564|
000234  9004              STR      r0,[sp,#0x10]
;;;233          int y0 = (paPoint + i )->y;
000236  eb060085          ADD      r0,r6,r5,LSL #2
00023a  f9b0b002          LDRSH    r11,[r0,#2]
;;;234          int y1 = (paPoint + i1)->y;
00023e  9804              LDR      r0,[sp,#0x10]
000240  eb060080          ADD      r0,r6,r0,LSL #2
000244  f9b08002          LDRSH    r8,[r0,#2]
;;;235          /* Check if starting point is on line */
;;;236          if (y0 == y) {
000248  45a3              CMP      r11,r4
00024a  d124              BNE      |L1.662|
;;;237            if (y1 == y) {  /* Add the entire line */
00024c  45a0              CMP      r8,r4
00024e  d10c              BNE      |L1.618|
;;;238              _DrawHLine((paPoint + i )->x + xOff , y + yOff, (paPoint + i1)->x + xOff);
000250  9b04              LDR      r3,[sp,#0x10]
000252  f9363023          LDRSH    r3,[r6,r3,LSL #2]
000256  eb03020a          ADD      r2,r3,r10
00025a  19e1              ADDS     r1,r4,r7
00025c  f9363025          LDRSH    r3,[r6,r5,LSL #2]
000260  eb03000a          ADD      r0,r3,r10
000264  f7fffffe          BL       _DrawHLine
000268  e02d              B        |L1.710|
                  |L1.618|
;;;239            } else {        /* Add only one point */
;;;240              int yPrev = _GetPrevPointDiffy(paPoint, i, NumPoints, y);
00026a  4623              MOV      r3,r4
00026c  464a              MOV      r2,r9
00026e  4629              MOV      r1,r5
000270  4630              MOV      r0,r6
000272  f7fffffe          BL       _GetPrevPointDiffy
000276  9003              STR      r0,[sp,#0xc]
;;;241              if (yPrev != y) {
000278  9803              LDR      r0,[sp,#0xc]
00027a  42a0              CMP      r0,r4
00027c  d00a              BEQ      |L1.660|
;;;242                _AddPoint((paPoint + i)->x, y, yPrev - y, y1 - y, xOff, yOff);
00027e  eba80304          SUB      r3,r8,r4
000282  e9cda700          STRD     r10,r7,[sp,#0]
000286  9903              LDR      r1,[sp,#0xc]
000288  1b0a              SUBS     r2,r1,r4
00028a  f9360025          LDRSH    r0,[r6,r5,LSL #2]
00028e  4621              MOV      r1,r4
000290  f7fffffe          BL       _AddPoint
                  |L1.660|
;;;243              } 
;;;244            }
000294  e017              B        |L1.710|
                  |L1.662|
;;;245          } else if (y1 != y) {  /* Ignore if end-point is on the line */
000296  45a0              CMP      r8,r4
000298  d015              BEQ      |L1.710|
;;;246            if (((y1 >= y) && (y0 <= y)) || ((y0 >= y) && (y1 <= y))) {
00029a  45a0              CMP      r8,r4
00029c  db01              BLT      |L1.674|
00029e  45a3              CMP      r11,r4
0002a0  dd03              BLE      |L1.682|
                  |L1.674|
0002a2  45a3              CMP      r11,r4
0002a4  db0f              BLT      |L1.710|
0002a6  45a0              CMP      r8,r4
0002a8  dc0d              BGT      |L1.710|
                  |L1.682|
;;;247              int xIntersect;
;;;248              if (_CheckYInterSect(y, &xIntersect, paPoint + i, paPoint + i1)) {
0002aa  9804              LDR      r0,[sp,#0x10]
0002ac  eb060380          ADD      r3,r6,r0,LSL #2
0002b0  eb060285          ADD      r2,r6,r5,LSL #2
0002b4  a903              ADD      r1,sp,#0xc
0002b6  4620              MOV      r0,r4
0002b8  f7fffffe          BL       _CheckYInterSect
0002bc  b110              CBZ      r0,|L1.708|
;;;249                _Add(xIntersect);
0002be  9803              LDR      r0,[sp,#0xc]
0002c0  f7fffffe          BL       _Add
                  |L1.708|
;;;250              }
;;;251            }
0002c4  bf00              NOP      
                  |L1.710|
0002c6  1c6d              ADDS     r5,r5,#1              ;231
                  |L1.712|
0002c8  454d              CMP      r5,r9                 ;231
0002ca  dbac              BLT      |L1.550|
;;;252          }
;;;253        }
;;;254        _Flush(xOff, y + yOff);
0002cc  19e1              ADDS     r1,r4,r7
0002ce  4650              MOV      r0,r10
0002d0  f7fffffe          BL       _Flush
0002d4  1c64              ADDS     r4,r4,#1              ;228
                  |L1.726|
0002d6  9805              LDR      r0,[sp,#0x14]         ;228
0002d8  4284              CMP      r4,r0                 ;228
0002da  dda0              BLE      |L1.542|
;;;255      }  
;;;256    }
0002dc  b007              ADD      sp,sp,#0x1c
0002de  e8bd8ff0          POP      {r4-r11,pc}
;;;257    
                          ENDP

                  GUI_FillPolygon PROC
;;;261    */
;;;262    void GUI_FillPolygon(const GUI_POINT* pPoints, int NumPoints, int x0, int y0) {
0002e2  e92d41f0          PUSH     {r4-r8,lr}
0002e6  4606              MOV      r6,r0
0002e8  460f              MOV      r7,r1
0002ea  4614              MOV      r4,r2
0002ec  461d              MOV      r5,r3
;;;263      GUI_LOCK();
0002ee  f7fffffe          BL       GUI_Lock
;;;264      #if (GUI_WINSUPPORT)
;;;265        WM_ADDORG(x0, y0);
0002f2  480e              LDR      r0,|L1.812|
0002f4  6c00              LDR      r0,[r0,#0x40]  ; GUI_Context
0002f6  4404              ADD      r4,r4,r0
0002f8  480c              LDR      r0,|L1.812|
0002fa  6c40              LDR      r0,[r0,#0x44]  ; GUI_Context
0002fc  4405              ADD      r5,r5,r0
;;;266        WM_ITERATE_START(NULL); {
0002fe  2000              MOVS     r0,#0
000300  f7fffffe          BL       WM__InitIVRSearch
000304  b150              CBZ      r0,|L1.796|
000306  bf00              NOP      
                  |L1.776|
;;;267      #endif
;;;268      GL_FillPolygon (pPoints, NumPoints, x0, y0);
000308  462b              MOV      r3,r5
00030a  4622              MOV      r2,r4
00030c  4639              MOV      r1,r7
00030e  4630              MOV      r0,r6
000310  f7fffffe          BL       GL_FillPolygon
;;;269      #if (GUI_WINSUPPORT)
;;;270        } WM_ITERATE_END();
000314  f7fffffe          BL       WM__GetNextIVR
000318  2800              CMP      r0,#0
00031a  d1f5              BNE      |L1.776|
                  |L1.796|
;;;271      #endif
;;;272      GUI_UNLOCK();
00031c  f7fffffe          BL       GUI_Unlock
;;;273    }
000320  e8bd81f0          POP      {r4-r8,pc}
;;;274    
                          ENDP

                  |L1.804|
                          DCD      GL_FP_Cnt
                  |L1.808|
                          DCD      _aX
                  |L1.812|
                          DCD      GUI_Context

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  _aX
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  GL_FP_Cnt
                          DCD      0x00000000
