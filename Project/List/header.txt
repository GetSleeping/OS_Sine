; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Obj\header.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\Obj\header.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\BaseDrive -I..\Ucosii -I..\Ucosii\Port -I..\Ucosii\Src -I..\Ucosii\Include -I..\Ucgui -I..\Ucgui\Config -I..\Ucgui\GUI_X -I..\Ucgui\GUI -I..\Ucgui\GUI\ConvertColor -I..\Ucgui\GUI\ConvertMono -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\LCDDriver -I..\Ucgui\GUI\MultiLayer -I..\Ucgui\GUI\Widget -I..\Ucgui\GUI\WM -I..\ExternalDrive\Lcd -I..\ExternalDrive\Touch -I..\Panel -I"D:\Program files\Keil\ARM\RV31\Inc" -I"D:\Program files\Keil\ARM\CMSIS\Include" -I"D:\Program files\Keil\ARM\Inc\ST\STM32F10x" -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\header.crf ..\Ucgui\GUI\Widget\HEADER.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _Paint PROC
;;;94     */
;;;95     static void _Paint(/*HEADER_Handle hObj, */HEADER_Obj* pObj) {
000000  e92d4ffe          PUSH     {r1-r11,lr}
000004  4605              MOV      r5,r0
;;;96       GUI_RECT Rect;
;;;97       int i, xPos = -pObj->ScrollPos;
000006  6be8              LDR      r0,[r5,#0x3c]
000008  4246              RSBS     r6,r0,#0
;;;98       int NumItems = GUI_ARRAY_GetNumItems(&pObj->Columns);
00000a  f1050030          ADD      r0,r5,#0x30
00000e  f7fffffe          BL       GUI_ARRAY_GetNumItems
000012  9000              STR      r0,[sp,#0]
;;;99       int EffectSize = pObj->Widget.pEffect->EffectSize;
000014  6a28              LDR      r0,[r5,#0x20]
000016  6947              LDR      r7,[r0,#0x14]
;;;100      LCD_SetBkColor(pObj->BkColor);
000018  6aa8              LDR      r0,[r5,#0x28]
00001a  f7fffffe          BL       LCD_SetBkColor
;;;101      GUI_SetFont(pObj->pFont);
00001e  6c28              LDR      r0,[r5,#0x40]
000020  f7fffffe          BL       GUI_SetFont
;;;102      GUI_Clear();
000024  f7fffffe          BL       GUI_Clear
;;;103      for (i = 0; i < NumItems; i++) {
000028  f04f0800          MOV      r8,#0
00002c  e0a4              B        |L1.376|
                  |L1.46|
;;;104        HEADER_COLUMN * pColumn = (HEADER_COLUMN*)GUI_ARRAY_GetpItem(&pObj->Columns, i);
00002e  4641              MOV      r1,r8
000030  f1050030          ADD      r0,r5,#0x30
000034  f7fffffe          BL       GUI_ARRAY_GetpItem
000038  4604              MOV      r4,r0
;;;105        GUI_GetClientRect(&Rect);
00003a  a801              ADD      r0,sp,#4
00003c  f7fffffe          BL       GUI_GetClientRect
;;;106        Rect.x0 = xPos;
000040  b230              SXTH     r0,r6
000042  f8ad0004          STRH     r0,[sp,#4]
;;;107        Rect.x1 = Rect.x0 + pColumn->Width;
000046  f8bd0004          LDRH     r0,[sp,#4]
00004a  6821              LDR      r1,[r4,#0]
00004c  4408              ADD      r0,r0,r1
00004e  b200              SXTH     r0,r0
000050  f8ad0008          STRH     r0,[sp,#8]
;;;108        if (pColumn->hDrawObj) {
000054  88e0              LDRH     r0,[r4,#6]
000056  2800              CMP      r0,#0
000058  d054              BEQ      |L1.260|
;;;109          int xOff = 0, yOff = 0;
00005a  f04f0900          MOV      r9,#0
00005e  46ca              MOV      r10,r9
;;;110          switch (pColumn->Align & GUI_TA_HORIZONTAL) {
000060  88a0              LDRH     r0,[r4,#4]
000062  f0000003          AND      r0,r0,#3
000066  2801              CMP      r0,#1
000068  d002              BEQ      |L1.112|
00006a  2802              CMP      r0,#2
00006c  d114              BNE      |L1.152|
00006e  e007              B        |L1.128|
                  |L1.112|
;;;111            case GUI_TA_RIGHT:
;;;112              xOff = (pColumn->Width - GUI_DRAW__GetXSize(pColumn->hDrawObj));
000070  f9b40006          LDRSH    r0,[r4,#6]
000074  f7fffffe          BL       GUI_DRAW__GetXSize
000078  6821              LDR      r1,[r4,#0]
00007a  eba10900          SUB      r9,r1,r0
;;;113              break;
00007e  e00b              B        |L1.152|
                  |L1.128|
;;;114            case GUI_TA_HCENTER:
;;;115              xOff = (pColumn->Width - GUI_DRAW__GetXSize(pColumn->hDrawObj)) / 2;
000080  f9b40006          LDRSH    r0,[r4,#6]
000084  f7fffffe          BL       GUI_DRAW__GetXSize
000088  6821              LDR      r1,[r4,#0]
00008a  eba10b00          SUB      r11,r1,r0
00008e  eb0b70db          ADD      r0,r11,r11,LSR #31
000092  ea4f0960          ASR      r9,r0,#1
;;;116              break;
000096  bf00              NOP      
                  |L1.152|
000098  bf00              NOP                            ;113
;;;117          }
;;;118          switch (pColumn->Align & GUI_TA_VERTICAL) {
00009a  88a0              LDRH     r0,[r4,#4]
00009c  f000000c          AND      r0,r0,#0xc
0000a0  2804              CMP      r0,#4
0000a2  d002              BEQ      |L1.170|
0000a4  280c              CMP      r0,#0xc
0000a6  d11e              BNE      |L1.230|
0000a8  e00c              B        |L1.196|
                  |L1.170|
;;;119    	      case GUI_TA_BOTTOM:
;;;120              yOff = ((Rect.y1 - Rect.y0 + 1) - GUI_DRAW__GetYSize(pColumn->hDrawObj));
0000aa  f9b40006          LDRSH    r0,[r4,#6]
0000ae  f7fffffe          BL       GUI_DRAW__GetYSize
0000b2  f9bd100a          LDRSH    r1,[sp,#0xa]
0000b6  f9bd2006          LDRSH    r2,[sp,#6]
0000ba  1a89              SUBS     r1,r1,r2
0000bc  1c49              ADDS     r1,r1,#1
0000be  eba10a00          SUB      r10,r1,r0
;;;121              break;
0000c2  e010              B        |L1.230|
                  |L1.196|
;;;122    	      case GUI_TA_VCENTER:
;;;123              yOff = ((Rect.y1 - Rect.y0 + 1) - GUI_DRAW__GetYSize(pColumn->hDrawObj)) / 2;
0000c4  f9b40006          LDRSH    r0,[r4,#6]
0000c8  f7fffffe          BL       GUI_DRAW__GetYSize
0000cc  f9bd100a          LDRSH    r1,[sp,#0xa]
0000d0  f9bd2006          LDRSH    r2,[sp,#6]
0000d4  1a89              SUBS     r1,r1,r2
0000d6  1c49              ADDS     r1,r1,#1
0000d8  eba10b00          SUB      r11,r1,r0
0000dc  eb0b70db          ADD      r0,r11,r11,LSR #31
0000e0  ea4f0a60          ASR      r10,r0,#1
;;;124              break;
0000e4  bf00              NOP      
                  |L1.230|
0000e6  bf00              NOP                            ;121
;;;125          }
;;;126          WM_SetUserClipRect(&Rect);
0000e8  a801              ADD      r0,sp,#4
0000ea  f7fffffe          BL       WM_SetUserClipRect
;;;127          GUI_DRAW__Draw(pColumn->hDrawObj, xPos + xOff, yOff);
0000ee  eb060109          ADD      r1,r6,r9
0000f2  f9b40006          LDRSH    r0,[r4,#6]
0000f6  4652              MOV      r2,r10
0000f8  f7fffffe          BL       GUI_DRAW__Draw
;;;128          WM_SetUserClipRect(NULL);
0000fc  2000              MOVS     r0,#0
0000fe  f7fffffe          BL       WM_SetUserClipRect
;;;129        }
000102  bf00              NOP      
                  |L1.260|
;;;130        WIDGET__EFFECT_DrawUpRect(&pObj->Widget, &Rect);
000104  a901              ADD      r1,sp,#4
000106  4628              MOV      r0,r5
000108  f7fffffe          BL       WIDGET__EFFECT_DrawUpRect
;;;131        xPos += Rect.x1 - Rect.x0;
00010c  f9bd0008          LDRSH    r0,[sp,#8]
000110  f9bd1004          LDRSH    r1,[sp,#4]
000114  1a40              SUBS     r0,r0,r1
000116  4406              ADD      r6,r6,r0
;;;132        Rect.x0 += EffectSize + _DefaultBorderH;
000118  f8bd0004          LDRH     r0,[sp,#4]
00011c  49fe              LDR      r1,|L1.1304|
00011e  6809              LDR      r1,[r1,#0]  ; _DefaultBorderH
000120  4439              ADD      r1,r1,r7
000122  4408              ADD      r0,r0,r1
000124  b200              SXTH     r0,r0
000126  f8ad0004          STRH     r0,[sp,#4]
;;;133        Rect.x1 -= EffectSize + _DefaultBorderH;
00012a  f8bd0008          LDRH     r0,[sp,#8]
00012e  49fa              LDR      r1,|L1.1304|
000130  6809              LDR      r1,[r1,#0]  ; _DefaultBorderH
000132  4439              ADD      r1,r1,r7
000134  1a40              SUBS     r0,r0,r1
000136  b200              SXTH     r0,r0
000138  f8ad0008          STRH     r0,[sp,#8]
;;;134        Rect.y0 += EffectSize + _DefaultBorderV;
00013c  f8bd0006          LDRH     r0,[sp,#6]
000140  49f6              LDR      r1,|L1.1308|
000142  6809              LDR      r1,[r1,#0]  ; _DefaultBorderV
000144  4439              ADD      r1,r1,r7
000146  4408              ADD      r0,r0,r1
000148  b200              SXTH     r0,r0
00014a  f8ad0006          STRH     r0,[sp,#6]
;;;135        Rect.y1 -= EffectSize + _DefaultBorderV;
00014e  f8bd000a          LDRH     r0,[sp,#0xa]
000152  49f2              LDR      r1,|L1.1308|
000154  6809              LDR      r1,[r1,#0]  ; _DefaultBorderV
000156  4439              ADD      r1,r1,r7
000158  1a40              SUBS     r0,r0,r1
00015a  b200              SXTH     r0,r0
00015c  f8ad000a          STRH     r0,[sp,#0xa]
;;;136        LCD_SetColor(pObj->TextColor);
000160  6ae8              LDR      r0,[r5,#0x2c]
000162  f7fffffe          BL       LCD_SetColor
;;;137        GUI_DispStringInRect(pColumn->acText, &Rect, pColumn->Align);
000166  f9b42004          LDRSH    r2,[r4,#4]
00016a  a901              ADD      r1,sp,#4
00016c  f1040008          ADD      r0,r4,#8
000170  f7fffffe          BL       GUI_DispStringInRect
000174  f1080801          ADD      r8,r8,#1              ;103
                  |L1.376|
000178  9800              LDR      r0,[sp,#0]            ;103
00017a  4580              CMP      r8,r0                 ;103
00017c  f6ffaf57          BLT      |L1.46|
;;;138      }
;;;139      GUI_GetClientRect(&Rect);
000180  a801              ADD      r0,sp,#4
000182  f7fffffe          BL       GUI_GetClientRect
;;;140      Rect.x0 = xPos;
000186  b230              SXTH     r0,r6
000188  f8ad0004          STRH     r0,[sp,#4]
;;;141      Rect.x1 = 0xfff;
00018c  f64070ff          MOV      r0,#0xfff
000190  f8ad0008          STRH     r0,[sp,#8]
;;;142      WIDGET__EFFECT_DrawUpRect(&pObj->Widget, &Rect);
000194  a901              ADD      r1,sp,#4
000196  4628              MOV      r0,r5
000198  f7fffffe          BL       WIDGET__EFFECT_DrawUpRect
;;;143    }
00019c  e8bd8ffe          POP      {r1-r11,pc}
;;;144    
                          ENDP

                  _RestoreOldCursor PROC
;;;148    */
;;;149    static void _RestoreOldCursor(void) {
0001a0  b510              PUSH     {r4,lr}
;;;150      if (_pOldCursor) {
0001a2  48df              LDR      r0,|L1.1312|
0001a4  6800              LDR      r0,[r0,#0]  ; _pOldCursor
0001a6  b130              CBZ      r0,|L1.438|
;;;151        #if GUI_SUPPORT_CURSOR
;;;152          GUI_CURSOR_Select(_pOldCursor);
0001a8  48dd              LDR      r0,|L1.1312|
0001aa  6800              LDR      r0,[r0,#0]  ; _pOldCursor
0001ac  f7fffffe          BL       GUI_CURSOR_Select
;;;153        #endif
;;;154        _pOldCursor = 0;
0001b0  2000              MOVS     r0,#0
0001b2  49db              LDR      r1,|L1.1312|
0001b4  6008              STR      r0,[r1,#0]  ; _pOldCursor
                  |L1.438|
;;;155      }
;;;156    }
0001b6  bd10              POP      {r4,pc}
;;;157    
                          ENDP

                  _FreeAttached PROC
;;;163    */
;;;164    static void _FreeAttached(HEADER_Obj * pObj) {
0001b8  e92d41f0          PUSH     {r4-r8,lr}
0001bc  4604              MOV      r4,r0
;;;165      int i, NumItems;
;;;166      NumItems = GUI_ARRAY_GetNumItems(&pObj->Columns);
0001be  f1040030          ADD      r0,r4,#0x30
0001c2  f7fffffe          BL       GUI_ARRAY_GetNumItems
0001c6  4607              MOV      r7,r0
;;;167      for (i = 0; i < NumItems; i++) {
0001c8  2500              MOVS     r5,#0
0001ca  e00c              B        |L1.486|
                  |L1.460|
;;;168        HEADER_COLUMN * pColumn = (HEADER_COLUMN*)GUI_ARRAY_GetpItem(&pObj->Columns, i);
0001cc  4629              MOV      r1,r5
0001ce  f1040030          ADD      r0,r4,#0x30
0001d2  f7fffffe          BL       GUI_ARRAY_GetpItem
0001d6  4606              MOV      r6,r0
;;;169        if (pColumn->hDrawObj) {
0001d8  88f0              LDRH     r0,[r6,#6]
0001da  b118              CBZ      r0,|L1.484|
;;;170          GUI_ALLOC_Free(pColumn->hDrawObj);
0001dc  f9b60006          LDRSH    r0,[r6,#6]
0001e0  f7fffffe          BL       GUI_ALLOC_Free
                  |L1.484|
0001e4  1c6d              ADDS     r5,r5,#1              ;167
                  |L1.486|
0001e6  42bd              CMP      r5,r7                 ;167
0001e8  dbf0              BLT      |L1.460|
;;;171        }
;;;172      }
;;;173      /* Delete attached objects (if any) */
;;;174      GUI_ARRAY_Delete(&pObj->Columns);
0001ea  f1040030          ADD      r0,r4,#0x30
0001ee  f7fffffe          BL       GUI_ARRAY_Delete
;;;175      _RestoreOldCursor();
0001f2  f7fffffe          BL       _RestoreOldCursor
;;;176    }
0001f6  e8bd81f0          POP      {r4-r8,pc}
;;;177    
                          ENDP

                  _GetItemIndex PROC
;;;182    #if (HEADER_SUPPORT_DRAG)
;;;183    static int _GetItemIndex(HEADER_Handle hObj, HEADER_Obj * pObj, int x, int y) {
0001fa  e92d4ff8          PUSH     {r3-r11,lr}
0001fe  4681              MOV      r9,r0
000200  460d              MOV      r5,r1
000202  4616              MOV      r6,r2
000204  4698              MOV      r8,r3
;;;184      int Item = -1;
000206  f04f30ff          MOV      r0,#0xffffffff
00020a  9000              STR      r0,[sp,#0]
;;;185      if ((y >= 0) && (y < WM_GetWindowSizeY(hObj))) {
00020c  f1b80f00          CMP      r8,#0
000210  db34              BLT      |L1.636|
000212  4648              MOV      r0,r9
000214  f7fffffe          BL       WM_GetWindowSizeY
000218  4540              CMP      r0,r8
00021a  dd2f              BLE      |L1.636|
;;;186        if (hObj) {
00021c  f1b90f00          CMP      r9,#0
000220  d02c              BEQ      |L1.636|
;;;187          int Index, xPos = 0, NumColumns;
000222  2700              MOVS     r7,#0
;;;188          NumColumns = GUI_ARRAY_GetNumItems(&pObj->Columns);
000224  f1050030          ADD      r0,r5,#0x30
000228  f7fffffe          BL       GUI_ARRAY_GetNumItems
00022c  4682              MOV      r10,r0
;;;189          for (Index = 0; Index < NumColumns; Index++) {
00022e  2400              MOVS     r4,#0
000230  e020              B        |L1.628|
                  |L1.562|
;;;190            HEADER_COLUMN * pColumn;
;;;191            pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
000232  4621              MOV      r1,r4
000234  f1050030          ADD      r0,r5,#0x30
000238  f7fffffe          BL       GUI_ARRAY_GetpItem
00023c  4683              MOV      r11,r0
;;;192            xPos += pColumn->Width;
00023e  f8db0000          LDR      r0,[r11,#0]
000242  4407              ADD      r7,r7,r0
;;;193            if ((xPos >= (x - 4)) && (xPos <= (x + 4))) {
000244  1f30              SUBS     r0,r6,#4
000246  42b8              CMP      r0,r7
000248  dc13              BGT      |L1.626|
00024a  1d30              ADDS     r0,r6,#4
00024c  4287              CMP      r7,r0
00024e  dc10              BGT      |L1.626|
;;;194              Item = Index;
000250  9400              STR      r4,[sp,#0]
;;;195              if ((Index < (NumColumns - 1)) && (x < xPos)) {
000252  f1aa0001          SUB      r0,r10,#1
000256  42a0              CMP      r0,r4
000258  dd0b              BLE      |L1.626|
00025a  42be              CMP      r6,r7
00025c  da09              BGE      |L1.626|
;;;196                pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index + 1);
00025e  1c61              ADDS     r1,r4,#1
000260  f1050030          ADD      r0,r5,#0x30
000264  f7fffffe          BL       GUI_ARRAY_GetpItem
000268  4683              MOV      r11,r0
;;;197                if (pColumn->Width == 0) {
00026a  f8db0000          LDR      r0,[r11,#0]
00026e  b900              CBNZ     r0,|L1.626|
;;;198                  break;
000270  e002              B        |L1.632|
                  |L1.626|
000272  1c64              ADDS     r4,r4,#1              ;189
                  |L1.628|
000274  4554              CMP      r4,r10                ;189
000276  dbdc              BLT      |L1.562|
                  |L1.632|
000278  bf00              NOP      
;;;199                }
;;;200              }
;;;201            }
;;;202          }
;;;203        }
00027a  bf00              NOP      
                  |L1.636|
;;;204      }
;;;205      return Item;
00027c  9800              LDR      r0,[sp,#0]
;;;206    }
00027e  e8bd8ff8          POP      {r3-r11,pc}
;;;207    #endif
                          ENDP

                  HEADER_SetItemWidth PROC
;;;638    */
;;;639    void HEADER_SetItemWidth(HEADER_Handle hObj, unsigned int Index, int Width) {
000282  e92d47f0          PUSH     {r4-r10,lr}
000286  4605              MOV      r5,r0
000288  460e              MOV      r6,r1
00028a  4614              MOV      r4,r2
;;;640      if (hObj && (Width >= 0)) {
00028c  b34d              CBZ      r5,|L1.738|
00028e  2c00              CMP      r4,#0
000290  db27              BLT      |L1.738|
;;;641        HEADER_Obj * pObj;
;;;642        WM_LOCK();
000292  f7fffffe          BL       GUI_Lock
;;;643        pObj = HEADER_H2P(hObj);
000296  4628              MOV      r0,r5
000298  f7fffffe          BL       GUI_ALLOC_h2p
00029c  4680              MOV      r8,r0
;;;644        if (Index <= GUI_ARRAY_GetNumItems(&pObj->Columns)) {
00029e  f1080030          ADD      r0,r8,#0x30
0002a2  f7fffffe          BL       GUI_ARRAY_GetNumItems
0002a6  42b0              CMP      r0,r6
0002a8  d318              BCC      |L1.732|
;;;645          HEADER_COLUMN * pColumn;
;;;646          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
0002aa  4631              MOV      r1,r6
0002ac  f1080030          ADD      r0,r8,#0x30
0002b0  f7fffffe          BL       GUI_ARRAY_GetpItem
0002b4  4607              MOV      r7,r0
;;;647          if (pColumn) {
0002b6  b187              CBZ      r7,|L1.730|
;;;648            pColumn->Width = Width;
0002b8  603c              STR      r4,[r7,#0]
;;;649            WM_InvalidateWindow(hObj);
0002ba  4628              MOV      r0,r5
0002bc  f7fffffe          BL       WM_InvalidateWindow
;;;650            WM__SendMsgNoData(WM_GetParent(hObj), WM_NOTIFY_CLIENTCHANGE);
0002c0  4628              MOV      r0,r5
0002c2  f7fffffe          BL       WM_GetParent
0002c6  4681              MOV      r9,r0
0002c8  2125              MOVS     r1,#0x25
0002ca  f7fffffe          BL       WM__SendMsgNoData
;;;651            WM_InvalidateWindow(WM_GetParent(hObj));
0002ce  4628              MOV      r0,r5
0002d0  f7fffffe          BL       WM_GetParent
0002d4  4681              MOV      r9,r0
0002d6  f7fffffe          BL       WM_InvalidateWindow
                  |L1.730|
;;;652          }
;;;653        }
0002da  bf00              NOP      
                  |L1.732|
;;;654        WM_UNLOCK();
0002dc  f7fffffe          BL       GUI_Unlock
;;;655      }
0002e0  bf00              NOP      
                  |L1.738|
;;;656    }
0002e2  e8bd87f0          POP      {r4-r10,pc}
;;;657    
                          ENDP

                  HEADER_GetItemWidth PROC
;;;676    */
;;;677    int HEADER_GetItemWidth(HEADER_Handle hObj, unsigned int Index) {
0002e6  e92d41f0          PUSH     {r4-r8,lr}
0002ea  4604              MOV      r4,r0
0002ec  460d              MOV      r5,r1
;;;678      int Width = 0;
0002ee  2700              MOVS     r7,#0
;;;679      if (hObj) {
0002f0  b1bc              CBZ      r4,|L1.802|
;;;680        HEADER_Obj * pObj;
;;;681        WM_LOCK();
0002f2  f7fffffe          BL       GUI_Lock
;;;682        pObj = HEADER_H2P(hObj);
0002f6  4620              MOV      r0,r4
0002f8  f7fffffe          BL       GUI_ALLOC_h2p
0002fc  4606              MOV      r6,r0
;;;683        if (Index <= GUI_ARRAY_GetNumItems(&pObj->Columns)) {
0002fe  f1060030          ADD      r0,r6,#0x30
000302  f7fffffe          BL       GUI_ARRAY_GetNumItems
000306  42a8              CMP      r0,r5
000308  d308              BCC      |L1.796|
;;;684          HEADER_COLUMN * pColumn;
;;;685          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
00030a  4629              MOV      r1,r5
00030c  f1060030          ADD      r0,r6,#0x30
000310  f7fffffe          BL       GUI_ARRAY_GetpItem
000314  4680              MOV      r8,r0
;;;686          Width = pColumn->Width;
000316  f8d87000          LDR      r7,[r8,#0]
;;;687        }
00031a  bf00              NOP      
                  |L1.796|
;;;688        WM_UNLOCK();
00031c  f7fffffe          BL       GUI_Unlock
;;;689      }
000320  bf00              NOP      
                  |L1.802|
;;;690      return Width;
000322  4638              MOV      r0,r7
;;;691    }
000324  e8bd81f0          POP      {r4-r8,pc}
;;;692    
                          ENDP

                  _HandlePID PROC
;;;213    #if (HEADER_SUPPORT_DRAG)
;;;214    static void _HandlePID(HEADER_Handle hObj, HEADER_Obj * pObj, int x, int y, int Pressed) {
000328  e92d47f0          PUSH     {r4-r10,lr}
00032c  4681              MOV      r9,r0
00032e  460c              MOV      r4,r1
000330  4615              MOV      r5,r2
000332  469a              MOV      r10,r3
000334  9e08              LDR      r6,[sp,#0x20]
;;;215      int Hit = _GetItemIndex(hObj, pObj, x, y);
000336  4653              MOV      r3,r10
000338  462a              MOV      r2,r5
00033a  4621              MOV      r1,r4
00033c  4648              MOV      r0,r9
00033e  f7fffffe          BL       _GetItemIndex
000342  4607              MOV      r7,r0
;;;216      /* set capture position () */
;;;217      if ((Pressed == 1) && (Hit >= 0) && (pObj->CapturePosX == -1)) {
000344  2e01              CMP      r6,#1
000346  d106              BNE      |L1.854|
000348  2f00              CMP      r7,#0
00034a  db04              BLT      |L1.854|
00034c  6b60              LDR      r0,[r4,#0x34]
00034e  1c40              ADDS     r0,r0,#1
000350  d101              BNE      |L1.854|
;;;218        pObj->CapturePosX = x;
000352  6365              STR      r5,[r4,#0x34]
;;;219        pObj->CaptureItem = Hit;
000354  63a7              STR      r7,[r4,#0x38]
                  |L1.854|
;;;220      }
;;;221      /* set mouse cursor and capture () */
;;;222      if (Hit >= 0) {
000356  2f00              CMP      r7,#0
000358  db0c              BLT      |L1.884|
;;;223        WM_SetCapture(hObj, 1);
00035a  2101              MOVS     r1,#1
00035c  4648              MOV      r0,r9
00035e  f7fffffe          BL       WM_SetCapture
;;;224        #if GUI_SUPPORT_CURSOR
;;;225          if (!_pOldCursor) {
000362  486f              LDR      r0,|L1.1312|
000364  6800              LDR      r0,[r0,#0]  ; _pOldCursor
000366  b928              CBNZ     r0,|L1.884|
;;;226            _pOldCursor = GUI_CURSOR_Select(_pDefaultCursor);
000368  486e              LDR      r0,|L1.1316|
00036a  6800              LDR      r0,[r0,#0]  ; _pDefaultCursor
00036c  f7fffffe          BL       GUI_CURSOR_Select
000370  496b              LDR      r1,|L1.1312|
000372  6008              STR      r0,[r1,#0]  ; _pOldCursor
                  |L1.884|
;;;227          }
;;;228        #endif
;;;229      }
;;;230      /* modify header */
;;;231      if ((pObj->CapturePosX >= 0) && (x != pObj->CapturePosX) && (Pressed == 1)) {
000374  6b60              LDR      r0,[r4,#0x34]
000376  2800              CMP      r0,#0
000378  db16              BLT      |L1.936|
00037a  6b60              LDR      r0,[r4,#0x34]
00037c  42a8              CMP      r0,r5
00037e  d013              BEQ      |L1.936|
000380  2e01              CMP      r6,#1
000382  d111              BNE      |L1.936|
;;;232        int NewSize = HEADER_GetItemWidth(hObj, pObj->CaptureItem) + x - pObj->CapturePosX;
000384  4648              MOV      r0,r9
000386  6ba1              LDR      r1,[r4,#0x38]
000388  f7fffffe          BL       HEADER_GetItemWidth
00038c  4428              ADD      r0,r0,r5
00038e  6b61              LDR      r1,[r4,#0x34]
000390  eba00801          SUB      r8,r0,r1
;;;233        if (NewSize >= 0) {
000394  f1b80f00          CMP      r8,#0
000398  db05              BLT      |L1.934|
;;;234          HEADER_SetItemWidth(hObj, pObj->CaptureItem, NewSize);
00039a  4642              MOV      r2,r8
00039c  4648              MOV      r0,r9
00039e  6ba1              LDR      r1,[r4,#0x38]
0003a0  f7fffffe          BL       HEADER_SetItemWidth
;;;235          pObj->CapturePosX = x;
0003a4  6365              STR      r5,[r4,#0x34]
                  |L1.934|
;;;236        }
;;;237      }
0003a6  bf00              NOP      
                  |L1.936|
;;;238      /* release capture & restore cursor */
;;;239      if (Pressed <= 0) {
0003a8  2e00              CMP      r6,#0
0003aa  dc06              BGT      |L1.954|
;;;240        #if (GUI_SUPPORT_MOUSE)
;;;241        if (Hit == -1)
;;;242        #endif
;;;243        {
;;;244          _RestoreOldCursor();
0003ac  f7fffffe          BL       _RestoreOldCursor
;;;245          pObj->CapturePosX = -1;
0003b0  f04f30ff          MOV      r0,#0xffffffff
0003b4  6360              STR      r0,[r4,#0x34]
;;;246          WM_ReleaseCapture();
0003b6  f7fffffe          BL       WM_ReleaseCapture
                  |L1.954|
;;;247        }
;;;248      }
;;;249    }
0003ba  e8bd87f0          POP      {r4-r10,pc}
;;;250    #endif
                          ENDP

                  _OnTouch PROC
;;;269    #if (HEADER_SUPPORT_DRAG)
;;;270    static void _OnTouch(HEADER_Handle hObj, HEADER_Obj * pObj, WM_MESSAGE * pMsg) {
0003be  e92d43f8          PUSH     {r3-r9,lr}
0003c2  4680              MOV      r8,r0
0003c4  460f              MOV      r7,r1
0003c6  4616              MOV      r6,r2
;;;271      int Notification;
;;;272      const GUI_PID_STATE * pState = (const GUI_PID_STATE *)pMsg->Data.p;
0003c8  68b4              LDR      r4,[r6,#8]
;;;273      if (pState) {
0003ca  b14c              CBZ      r4,|L1.992|
;;;274        _HandlePID(hObj, pObj, pState->x + pObj->ScrollPos, pState->y, pState->Pressed);
0003cc  7a20              LDRB     r0,[r4,#8]
0003ce  9000              STR      r0,[sp,#0]
0003d0  6820              LDR      r0,[r4,#0]
0003d2  6bf9              LDR      r1,[r7,#0x3c]
0003d4  1842              ADDS     r2,r0,r1
0003d6  4639              MOV      r1,r7
0003d8  4640              MOV      r0,r8
0003da  6863              LDR      r3,[r4,#4]
0003dc  f7fffffe          BL       _HandlePID
                  |L1.992|
;;;275      }
;;;276      if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
0003e0  68b0              LDR      r0,[r6,#8]
0003e2  b128              CBZ      r0,|L1.1008|
;;;277        if (pState->Pressed) {
0003e4  7a20              LDRB     r0,[r4,#8]
0003e6  b108              CBZ      r0,|L1.1004|
;;;278          Notification = WM_NOTIFICATION_CLICKED;
0003e8  2501              MOVS     r5,#1
0003ea  e002              B        |L1.1010|
                  |L1.1004|
;;;279        } else {
;;;280          Notification = WM_NOTIFICATION_RELEASED;
0003ec  2502              MOVS     r5,#2
0003ee  e000              B        |L1.1010|
                  |L1.1008|
;;;281        }
;;;282      } else {
;;;283        Notification = WM_NOTIFICATION_MOVED_OUT;
0003f0  2503              MOVS     r5,#3
                  |L1.1010|
;;;284      }
;;;285      WM_NotifyParent(hObj, Notification);
0003f2  4629              MOV      r1,r5
0003f4  4640              MOV      r0,r8
0003f6  f7fffffe          BL       WM_NotifyParent
;;;286    }
0003fa  e8bd83f8          POP      {r3-r9,pc}
;;;287    #endif
                          ENDP

                  _HEADER_Callback PROC
;;;292    */
;;;293    static void _HEADER_Callback (WM_MESSAGE *pMsg) {
0003fe  b570              PUSH     {r4-r6,lr}
000400  4604              MOV      r4,r0
;;;294      HEADER_Handle hObj;
;;;295      HEADER_Obj * pObj;
;;;296      hObj = pMsg->hWin;
000402  f9b45004          LDRSH    r5,[r4,#4]
;;;297      /* Let widget handle the standard messages */
;;;298      if (WIDGET_HandleActive(hObj, pMsg) == 0) {
000406  4621              MOV      r1,r4
000408  4628              MOV      r0,r5
00040a  f7fffffe          BL       WIDGET_HandleActive
00040e  b900              CBNZ     r0,|L1.1042|
                  |L1.1040|
;;;299        return;
;;;300      }
;;;301      WM_LOCK();
;;;302      pObj = HEADER_H2P(hObj);
;;;303      switch (pMsg->MsgId) {
;;;304        case WM_PAINT:
;;;305          _Paint(/*hObj, */pObj);
;;;306          break;
;;;307    #if (HEADER_SUPPORT_DRAG)
;;;308        case WM_TOUCH:
;;;309          _OnTouch(hObj, pObj, pMsg);
;;;310          break;
;;;311    #endif
;;;312    #if (HEADER_SUPPORT_DRAG & GUI_SUPPORT_MOUSE)
;;;313        case WM_MOUSEOVER:
;;;314          _OnMouseOver(hObj, pObj, pMsg);
;;;315          break;
;;;316    #endif
;;;317        case WM_DELETE:
;;;318          _FreeAttached(pObj); /* No return here ... WM_DefaultProc needs to be called */
;;;319        default:
;;;320          WM_DefaultProc(pMsg);
;;;321      }
;;;322      WM_UNLOCK();
;;;323    }
000410  bd70              POP      {r4-r6,pc}
                  |L1.1042|
000412  f7fffffe          BL       GUI_Lock
000416  4628              MOV      r0,r5                 ;302
000418  f7fffffe          BL       GUI_ALLOC_h2p
00041c  4606              MOV      r6,r0                 ;302
00041e  6820              LDR      r0,[r4,#0]            ;303
000420  280b              CMP      r0,#0xb               ;303
000422  d00d              BEQ      |L1.1088|
000424  280c              CMP      r0,#0xc               ;303
000426  d005              BEQ      |L1.1076|
000428  280f              CMP      r0,#0xf               ;303
00042a  d10d              BNE      |L1.1096|
00042c  4630              MOV      r0,r6                 ;305
00042e  f7fffffe          BL       _Paint
000432  e00d              B        |L1.1104|
                  |L1.1076|
000434  4622              MOV      r2,r4                 ;309
000436  4631              MOV      r1,r6                 ;309
000438  4628              MOV      r0,r5                 ;309
00043a  f7fffffe          BL       _OnTouch
00043e  e007              B        |L1.1104|
                  |L1.1088|
000440  4630              MOV      r0,r6                 ;318
000442  f7fffffe          BL       _FreeAttached
000446  bf00              NOP                            ;319
                  |L1.1096|
000448  4620              MOV      r0,r4                 ;320
00044a  f7fffffe          BL       WM_DefaultProc
00044e  bf00              NOP                            ;303
                  |L1.1104|
000450  bf00              NOP                            ;306
000452  f7fffffe          BL       GUI_Unlock
000456  bf00              NOP      
000458  e7da              B        |L1.1040|
;;;324    
                          ENDP

                  HEADER_CreateEx PROC
;;;342    */
;;;343    HEADER_Handle HEADER_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent,
00045a  e92d5fff          PUSH     {r0-r12,lr}
;;;344                                  int WinFlags, int ExFlags, int Id)
;;;345    {
00045e  4607              MOV      r7,r0
000460  4688              MOV      r8,r1
000462  4691              MOV      r9,r2
000464  461d              MOV      r5,r3
000466  e9ddab0e          LDRD     r10,r11,[sp,#0x38]
;;;346      HEADER_Handle hObj;
;;;347      GUI_USE_PARA(ExFlags);
00046a  9810              LDR      r0,[sp,#0x40]
00046c  9010              STR      r0,[sp,#0x40]
;;;348      /* Create the window */
;;;349      WM_LOCK();
00046e  f7fffffe          BL       GUI_Lock
;;;350      if ((xsize == 0) && (x0 == 0) && (y0 == 0)) {
000472  f1b90f00          CMP      r9,#0
000476  d113              BNE      |L1.1184|
000478  b997              CBNZ     r7,|L1.1184|
00047a  f1b80f00          CMP      r8,#0
00047e  d10f              BNE      |L1.1184|
;;;351        GUI_RECT Rect;
;;;352        WM_GetInsideRectEx(hParent, &Rect);
000480  a902              ADD      r1,sp,#8
000482  4650              MOV      r0,r10
000484  f7fffffe          BL       WM_GetInsideRectEx
;;;353        xsize = Rect.x1 - Rect.x0 + 1;
000488  f9bd000c          LDRSH    r0,[sp,#0xc]
00048c  f9bd1008          LDRSH    r1,[sp,#8]
000490  1a40              SUBS     r0,r0,r1
000492  f1000901          ADD      r9,r0,#1
;;;354        x0    = Rect.x0;
000496  f9bd7008          LDRSH    r7,[sp,#8]
;;;355        y0    = Rect.y0;
00049a  f9bd800a          LDRSH    r8,[sp,#0xa]
;;;356      }
00049e  bf00              NOP      
                  |L1.1184|
;;;357      if (ysize == 0) {
0004a0  b985              CBNZ     r5,|L1.1220|
;;;358        const WIDGET_EFFECT* pEffect = WIDGET_GetDefaultEffect();
0004a2  f7fffffe          BL       WIDGET_GetDefaultEffect
0004a6  4604              MOV      r4,r0
;;;359        ysize  = GUI_GetYDistOfFont(_pDefaultFont);
0004a8  481f              LDR      r0,|L1.1320|
0004aa  6800              LDR      r0,[r0,#0]  ; _pDefaultFont
0004ac  f7fffffe          BL       GUI_GetYDistOfFont
0004b0  4605              MOV      r5,r0
;;;360        ysize += 2 * _DefaultBorderV;
0004b2  481a              LDR      r0,|L1.1308|
0004b4  6800              LDR      r0,[r0,#0]  ; _DefaultBorderV
0004b6  2102              MOVS     r1,#2
0004b8  fb015500          MLA      r5,r1,r0,r5
;;;361        ysize += 2 * (unsigned)pEffect->EffectSize;
0004bc  6960              LDR      r0,[r4,#0x14]
0004be  fb015500          MLA      r5,r1,r0,r5
;;;362      }
0004c2  bf00              NOP      
                  |L1.1220|
;;;363      WinFlags |= WM_CF_ANCHOR_LEFT | WM_CF_ANCHOR_RIGHT;
0004c4  f44b7b20          ORR      r11,r11,#0x280
;;;364      hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, &_HEADER_Callback,
0004c8  2124              MOVS     r1,#0x24
0004ca  4a18              LDR      r2,|L1.1324|
0004cc  fa1ff08b          UXTH     r0,r11
0004d0  462b              MOV      r3,r5
0004d2  e9cda000          STRD     r10,r0,[sp,#0]
0004d6  e9cd2102          STRD     r2,r1,[sp,#8]
0004da  464a              MOV      r2,r9
0004dc  4641              MOV      r1,r8
0004de  4638              MOV      r0,r7
0004e0  f7fffffe          BL       WM_CreateWindowAsChild
0004e4  4606              MOV      r6,r0
;;;365                                    sizeof(HEADER_Obj) - sizeof(WM_Obj));
;;;366      if (hObj) {
0004e6  b33e              CBZ      r6,|L1.1336|
;;;367        HEADER_Obj* pObj = HEADER_H2P(hObj);
0004e8  4630              MOV      r0,r6
0004ea  f7fffffe          BL       GUI_ALLOC_h2p
0004ee  4604              MOV      r4,r0
;;;368        /* Init sub-classes */
;;;369        GUI_ARRAY_CREATE(&pObj->Columns);
;;;370        /* init widget specific variables */
;;;371        WIDGET__Init(&pObj->Widget, Id, 0);
0004f0  2200              MOVS     r2,#0
0004f2  4620              MOV      r0,r4
0004f4  9911              LDR      r1,[sp,#0x44]
0004f6  f7fffffe          BL       WIDGET__Init
;;;372        /* init member variables */
;;;373        HEADER_INIT_ID(pObj);
;;;374        pObj->BkColor     = _DefaultBkColor;
0004fa  480d              LDR      r0,|L1.1328|
0004fc  6800              LDR      r0,[r0,#0]  ; _DefaultBkColor
0004fe  62a0              STR      r0,[r4,#0x28]
;;;375        pObj->TextColor   = _DefaultTextColor;
000500  480c              LDR      r0,|L1.1332|
000502  6800              LDR      r0,[r0,#0]  ; _DefaultTextColor
000504  62e0              STR      r0,[r4,#0x2c]
;;;376        pObj->pFont       = _pDefaultFont;
000506  4808              LDR      r0,|L1.1320|
000508  6800              LDR      r0,[r0,#0]  ; _pDefaultFont
00050a  6420              STR      r0,[r4,#0x40]
;;;377        pObj->CapturePosX = -1;
00050c  f04f30ff          MOV      r0,#0xffffffff
000510  6360              STR      r0,[r4,#0x34]
;;;378        pObj->CaptureItem = -1;
000512  63a0              STR      r0,[r4,#0x38]
;;;379        pObj->ScrollPos   = 0;
000514  2000              MOVS     r0,#0
000516  e010              B        |L1.1338|
                  |L1.1304|
                          DCD      _DefaultBorderH
                  |L1.1308|
                          DCD      _DefaultBorderV
                  |L1.1312|
                          DCD      _pOldCursor
                  |L1.1316|
                          DCD      _pDefaultCursor
                  |L1.1320|
                          DCD      _pDefaultFont
                  |L1.1324|
                          DCD      _HEADER_Callback
                  |L1.1328|
                          DCD      _DefaultBkColor
                  |L1.1332|
                          DCD      _DefaultTextColor
                  |L1.1336|
000538  e001              B        |L1.1342|
                  |L1.1338|
00053a  63e0              STR      r0,[r4,#0x3c]
;;;380      } else {
00053c  bf00              NOP      
                  |L1.1342|
;;;381        GUI_DEBUG_ERROROUT_IF(hObj==0, "HEADER_Create failed")
;;;382      }
;;;383      WM_UNLOCK();
00053e  f7fffffe          BL       GUI_Unlock
;;;384      return hObj;
000542  4630              MOV      r0,r6
;;;385    }
000544  b004              ADD      sp,sp,#0x10
000546  e8bd9ff0          POP      {r4-r12,pc}
;;;386    
                          ENDP

                  HEADER_Create PROC
;;;334    */
;;;335    HEADER_Handle HEADER_Create(int x0, int y0, int xsize, int ysize, WM_HWIN hParent, int Id, int Flags, int ExFlags) {
00054a  e92d5fff          PUSH     {r0-r12,lr}
00054e  4604              MOV      r4,r0
000550  460d              MOV      r5,r1
000552  4616              MOV      r6,r2
000554  461f              MOV      r7,r3
000556  e9ddab10          LDRD     r10,r11,[sp,#0x40]
00055a  e9dd890e          LDRD     r8,r9,[sp,#0x38]
;;;336      return HEADER_CreateEx(x0, y0, xsize, ysize, hParent, Flags, ExFlags, Id);
00055e  463b              MOV      r3,r7
000560  4632              MOV      r2,r6
000562  4629              MOV      r1,r5
000564  4620              MOV      r0,r4
000566  e88d0d00          STM      sp,{r8,r10,r11}
00056a  f8cd900c          STR      r9,[sp,#0xc]
00056e  f7fffffe          BL       HEADER_CreateEx
;;;337    }
000572  b004              ADD      sp,sp,#0x10
000574  e8bd9ff0          POP      {r4-r12,pc}
;;;338    
                          ENDP

                  HEADER_SetDefaultCursor PROC
;;;396    */
;;;397    const GUI_CURSOR GUI_UNI_PTR * HEADER_SetDefaultCursor(const GUI_CURSOR * pCursor) {
000578  4601              MOV      r1,r0
;;;398      const GUI_CURSOR GUI_UNI_PTR * pOldCursor = _pDefaultCursor;
00057a  4acc              LDR      r2,|L1.2220|
00057c  6810              LDR      r0,[r2,#0]  ; _pDefaultCursor
;;;399      _pDefaultCursor = pCursor;
00057e  6011              STR      r1,[r2,#0]  ; _pDefaultCursor
;;;400      return pOldCursor;
;;;401    }
000580  4770              BX       lr
;;;402    
                          ENDP

                  HEADER_SetDefaultBkColor PROC
;;;406    */
;;;407    GUI_COLOR HEADER_SetDefaultBkColor(GUI_COLOR Color) {
000582  4601              MOV      r1,r0
;;;408      GUI_COLOR OldColor = _DefaultBkColor;
000584  4aca              LDR      r2,|L1.2224|
000586  6810              LDR      r0,[r2,#0]  ; _DefaultBkColor
;;;409      _DefaultBkColor = Color;
000588  6011              STR      r1,[r2,#0]  ; _DefaultBkColor
;;;410      return OldColor;
;;;411    }
00058a  4770              BX       lr
;;;412    
                          ENDP

                  HEADER_SetDefaultTextColor PROC
;;;416    */
;;;417    GUI_COLOR HEADER_SetDefaultTextColor(GUI_COLOR Color) {
00058c  4601              MOV      r1,r0
;;;418      GUI_COLOR OldColor = _DefaultTextColor;
00058e  4ac9              LDR      r2,|L1.2228|
000590  6810              LDR      r0,[r2,#0]  ; _DefaultTextColor
;;;419      _DefaultTextColor = Color;
000592  6011              STR      r1,[r2,#0]  ; _DefaultTextColor
;;;420      return OldColor;
;;;421    }
000594  4770              BX       lr
;;;422    
                          ENDP

                  HEADER_SetDefaultBorderH PROC
;;;426    */
;;;427    int HEADER_SetDefaultBorderH(int Spacing) {
000596  4601              MOV      r1,r0
;;;428      int OldSpacing = _DefaultBorderH;
000598  4ac7              LDR      r2,|L1.2232|
00059a  6810              LDR      r0,[r2,#0]  ; _DefaultBorderH
;;;429      _DefaultBorderH = Spacing;
00059c  6011              STR      r1,[r2,#0]  ; _DefaultBorderH
;;;430      return OldSpacing;
;;;431    }
00059e  4770              BX       lr
;;;432    
                          ENDP

                  HEADER_SetDefaultBorderV PROC
;;;436    */
;;;437    int HEADER_SetDefaultBorderV(int Spacing) {
0005a0  4601              MOV      r1,r0
;;;438      int OldSpacing = _DefaultBorderV;
0005a2  4ac6              LDR      r2,|L1.2236|
0005a4  6810              LDR      r0,[r2,#0]  ; _DefaultBorderV
;;;439      _DefaultBorderV = Spacing;
0005a6  6011              STR      r1,[r2,#0]  ; _DefaultBorderV
;;;440      return OldSpacing;
;;;441    }
0005a8  4770              BX       lr
;;;442    
                          ENDP

                  HEADER_SetDefaultFont PROC
;;;446    */
;;;447    const GUI_FONT GUI_UNI_PTR * HEADER_SetDefaultFont(const GUI_FONT GUI_UNI_PTR * pFont) {
0005aa  4601              MOV      r1,r0
;;;448      const GUI_FONT GUI_UNI_PTR * pOldFont = _pDefaultFont;
0005ac  4ac4              LDR      r2,|L1.2240|
0005ae  6810              LDR      r0,[r2,#0]  ; _pDefaultFont
;;;449      _pDefaultFont = pFont;
0005b0  6011              STR      r1,[r2,#0]  ; _pDefaultFont
;;;450      return pOldFont;
;;;451    }
0005b2  4770              BX       lr
;;;452    
                          ENDP

                  HEADER_GetDefaultCursor PROC
;;;456    */
;;;457    const GUI_CURSOR GUI_UNI_PTR *  HEADER_GetDefaultCursor(void)    { return _pDefaultCursor; }
0005b4  48bd              LDR      r0,|L1.2220|
0005b6  6800              LDR      r0,[r0,#0]  ; _pDefaultCursor
0005b8  4770              BX       lr
;;;458    GUI_COLOR          HEADER_GetDefaultBkColor(void)   { return _DefaultBkColor; }
                          ENDP

                  HEADER_GetDefaultBkColor PROC
0005ba  48bd              LDR      r0,|L1.2224|
0005bc  6800              LDR      r0,[r0,#0]  ; _DefaultBkColor
0005be  4770              BX       lr
;;;459    GUI_COLOR          HEADER_GetDefaultTextColor(void) { return _DefaultTextColor; }
                          ENDP

                  HEADER_GetDefaultTextColor PROC
0005c0  48bc              LDR      r0,|L1.2228|
0005c2  6800              LDR      r0,[r0,#0]  ; _DefaultTextColor
0005c4  4770              BX       lr
;;;460    int                HEADER_GetDefaultBorderH(void)   { return _DefaultBorderH; }
                          ENDP

                  HEADER_GetDefaultBorderH PROC
0005c6  48bc              LDR      r0,|L1.2232|
0005c8  6800              LDR      r0,[r0,#0]  ; _DefaultBorderH
0005ca  4770              BX       lr
;;;461    int                HEADER_GetDefaultBorderV(void)   { return _DefaultBorderV; }
                          ENDP

                  HEADER_GetDefaultBorderV PROC
0005cc  48bb              LDR      r0,|L1.2236|
0005ce  6800              LDR      r0,[r0,#0]  ; _DefaultBorderV
0005d0  4770              BX       lr
;;;462    const GUI_FONT GUI_UNI_PTR *    HEADER_GetDefaultFont(void)      { return _pDefaultFont; }
                          ENDP

                  HEADER_GetDefaultFont PROC
0005d2  48bb              LDR      r0,|L1.2240|
0005d4  6800              LDR      r0,[r0,#0]  ; _pDefaultFont
0005d6  4770              BX       lr
;;;463    
                          ENDP

                  HEADER_SetFont PROC
;;;473    */
;;;474    void HEADER_SetFont(HEADER_Handle hObj, const GUI_FONT GUI_UNI_PTR * pFont) {
0005d8  b570              PUSH     {r4-r6,lr}
0005da  4604              MOV      r4,r0
0005dc  460d              MOV      r5,r1
;;;475      if (hObj) {
0005de  b164              CBZ      r4,|L1.1530|
;;;476        HEADER_Obj * pObj;
;;;477        WM_LOCK();
0005e0  f7fffffe          BL       GUI_Lock
;;;478        pObj = HEADER_H2P(hObj);
0005e4  4620              MOV      r0,r4
0005e6  f7fffffe          BL       GUI_ALLOC_h2p
0005ea  4606              MOV      r6,r0
;;;479        pObj->pFont = pFont;
0005ec  6435              STR      r5,[r6,#0x40]
;;;480        WM_InvalidateWindow(hObj);
0005ee  4620              MOV      r0,r4
0005f0  f7fffffe          BL       WM_InvalidateWindow
;;;481        WM_UNLOCK();
0005f4  f7fffffe          BL       GUI_Unlock
;;;482      }
0005f8  bf00              NOP      
                  |L1.1530|
;;;483    }
0005fa  bd70              POP      {r4-r6,pc}
;;;484    
                          ENDP

                  HEADER_SetHeight PROC
;;;488    */
;;;489    void HEADER_SetHeight(HEADER_Handle hObj, int Height) {
0005fc  b57c              PUSH     {r2-r6,lr}
0005fe  4604              MOV      r4,r0
000600  460d              MOV      r5,r1
;;;490      if (hObj) {
000602  b1a4              CBZ      r4,|L1.1582|
;;;491        GUI_RECT Rect;
;;;492        WM_GetClientRectEx(hObj, &Rect);
000604  4669              MOV      r1,sp
000606  4620              MOV      r0,r4
000608  f7fffffe          BL       WM_GetClientRectEx
;;;493        WM_SetSize(hObj, Rect.x1 - Rect.x0 + 1, Height);
00060c  f9bd0004          LDRSH    r0,[sp,#4]
000610  f9bd2000          LDRSH    r2,[sp,#0]
000614  1a80              SUBS     r0,r0,r2
000616  1c41              ADDS     r1,r0,#1
000618  462a              MOV      r2,r5
00061a  4620              MOV      r0,r4
00061c  f7fffffe          BL       WM_SetSize
;;;494        WM_InvalidateWindow(WM_GetParent(hObj));
000620  4620              MOV      r0,r4
000622  f7fffffe          BL       WM_GetParent
000626  4606              MOV      r6,r0
000628  f7fffffe          BL       WM_InvalidateWindow
;;;495      }
00062c  bf00              NOP      
                  |L1.1582|
;;;496    }
00062e  bd7c              POP      {r2-r6,pc}
;;;497    
                          ENDP

                  HEADER_SetTextColor PROC
;;;501    */
;;;502    void HEADER_SetTextColor(HEADER_Handle hObj, GUI_COLOR Color) {
000630  b570              PUSH     {r4-r6,lr}
000632  4604              MOV      r4,r0
000634  460d              MOV      r5,r1
;;;503      if (hObj) {
000636  b164              CBZ      r4,|L1.1618|
;;;504        HEADER_Obj * pObj;
;;;505        WM_LOCK();
000638  f7fffffe          BL       GUI_Lock
;;;506        pObj = HEADER_H2P(hObj);
00063c  4620              MOV      r0,r4
00063e  f7fffffe          BL       GUI_ALLOC_h2p
000642  4606              MOV      r6,r0
;;;507        pObj->TextColor = Color;
000644  62f5              STR      r5,[r6,#0x2c]
;;;508        WM_InvalidateWindow(hObj);
000646  4620              MOV      r0,r4
000648  f7fffffe          BL       WM_InvalidateWindow
;;;509        WM_UNLOCK();
00064c  f7fffffe          BL       GUI_Unlock
;;;510      }
000650  bf00              NOP      
                  |L1.1618|
;;;511    }
000652  bd70              POP      {r4-r6,pc}
;;;512    
                          ENDP

                  HEADER_SetBkColor PROC
;;;516    */
;;;517    void HEADER_SetBkColor(HEADER_Handle hObj, GUI_COLOR Color) {
000654  b570              PUSH     {r4-r6,lr}
000656  4604              MOV      r4,r0
000658  460d              MOV      r5,r1
;;;518      if (hObj) {
00065a  b164              CBZ      r4,|L1.1654|
;;;519        HEADER_Obj * pObj;
;;;520        WM_LOCK();
00065c  f7fffffe          BL       GUI_Lock
;;;521        pObj = HEADER_H2P(hObj);
000660  4620              MOV      r0,r4
000662  f7fffffe          BL       GUI_ALLOC_h2p
000666  4606              MOV      r6,r0
;;;522        pObj->BkColor = Color;
000668  62b5              STR      r5,[r6,#0x28]
;;;523        WM_InvalidateWindow(hObj);
00066a  4620              MOV      r0,r4
00066c  f7fffffe          BL       WM_InvalidateWindow
;;;524        WM_UNLOCK();
000670  f7fffffe          BL       GUI_Unlock
;;;525      }
000674  bf00              NOP      
                  |L1.1654|
;;;526    }
000676  bd70              POP      {r4-r6,pc}
;;;527    
                          ENDP

                  HEADER_SetTextAlign PROC
;;;531    */
;;;532    void HEADER_SetTextAlign(HEADER_Handle hObj, unsigned int Index, int Align) {
000678  e92d41f0          PUSH     {r4-r8,lr}
00067c  4604              MOV      r4,r0
00067e  460d              MOV      r5,r1
000680  4616              MOV      r6,r2
;;;533      if (hObj) {
000682  b1dc              CBZ      r4,|L1.1724|
;;;534        HEADER_Obj * pObj;
;;;535        WM_LOCK();
000684  f7fffffe          BL       GUI_Lock
;;;536        pObj = HEADER_H2P(hObj);
000688  4620              MOV      r0,r4
00068a  f7fffffe          BL       GUI_ALLOC_h2p
00068e  4607              MOV      r7,r0
;;;537        if (Index <= GUI_ARRAY_GetNumItems(&pObj->Columns)) {
000690  f1070030          ADD      r0,r7,#0x30
000694  f7fffffe          BL       GUI_ARRAY_GetNumItems
000698  42a8              CMP      r0,r5
00069a  d30c              BCC      |L1.1718|
;;;538          HEADER_COLUMN * pColumn;
;;;539          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
00069c  4629              MOV      r1,r5
00069e  f1070030          ADD      r0,r7,#0x30
0006a2  f7fffffe          BL       GUI_ARRAY_GetpItem
0006a6  4680              MOV      r8,r0
;;;540          pColumn->Align = Align;
0006a8  b230              SXTH     r0,r6
0006aa  f8a80004          STRH     r0,[r8,#4]
;;;541          WM_InvalidateWindow(hObj);
0006ae  4620              MOV      r0,r4
0006b0  f7fffffe          BL       WM_InvalidateWindow
;;;542        }
0006b4  bf00              NOP      
                  |L1.1718|
;;;543        WM_UNLOCK();
0006b6  f7fffffe          BL       GUI_Unlock
;;;544      }
0006ba  bf00              NOP      
                  |L1.1724|
;;;545    }
0006bc  e8bd81f0          POP      {r4-r8,pc}
;;;546    
                          ENDP

                  HEADER_SetScrollPos PROC
;;;550    */
;;;551    void HEADER_SetScrollPos(HEADER_Handle hObj, int ScrollPos) {
0006c0  e92d41f0          PUSH     {r4-r8,lr}
0006c4  4605              MOV      r5,r0
0006c6  460c              MOV      r4,r1
;;;552      if (hObj && (ScrollPos >= 0)) {
0006c8  b1bd              CBZ      r5,|L1.1786|
0006ca  2c00              CMP      r4,#0
0006cc  db15              BLT      |L1.1786|
;;;553        HEADER_Obj* pObj;
;;;554        WM_LOCK();
0006ce  f7fffffe          BL       GUI_Lock
;;;555        pObj = HEADER_H2P(hObj);
0006d2  4628              MOV      r0,r5
0006d4  f7fffffe          BL       GUI_ALLOC_h2p
0006d8  4606              MOV      r6,r0
;;;556        if (ScrollPos != pObj->ScrollPos) {
0006da  6bf0              LDR      r0,[r6,#0x3c]
0006dc  42a0              CMP      r0,r4
0006de  d009              BEQ      |L1.1780|
;;;557          pObj->ScrollPos = ScrollPos;
0006e0  63f4              STR      r4,[r6,#0x3c]
;;;558          WM_Invalidate(hObj);
0006e2  4628              MOV      r0,r5
0006e4  f7fffffe          BL       WM_InvalidateWindow
;;;559          WM_InvalidateWindow(WM_GetParent(hObj));
0006e8  4628              MOV      r0,r5
0006ea  f7fffffe          BL       WM_GetParent
0006ee  4607              MOV      r7,r0
0006f0  f7fffffe          BL       WM_InvalidateWindow
                  |L1.1780|
;;;560        }
;;;561        WM_UNLOCK();
0006f4  f7fffffe          BL       GUI_Unlock
;;;562      }
0006f8  bf00              NOP      
                  |L1.1786|
;;;563    }
0006fa  e8bd81f0          POP      {r4-r8,pc}
;;;564    
                          ENDP

                  HEADER_AddItem PROC
;;;568    */
;;;569    void HEADER_AddItem(HEADER_Handle hObj, int Width, const char * s, int Align) {
0006fe  e92d4ffe          PUSH     {r1-r11,lr}
000702  4607              MOV      r7,r0
000704  460d              MOV      r5,r1
000706  4616              MOV      r6,r2
000708  4698              MOV      r8,r3
;;;570      if (hObj) {
00070a  2f00              CMP      r7,#0
00070c  d04e              BEQ      |L1.1964|
;;;571        HEADER_Obj * pObj;
;;;572        HEADER_COLUMN Column;
;;;573        int Index;
;;;574        WM_LOCK();
00070e  f7fffffe          BL       GUI_Lock
;;;575        pObj = HEADER_H2P(hObj);
000712  4638              MOV      r0,r7
000714  f7fffffe          BL       GUI_ALLOC_h2p
000718  4604              MOV      r4,r0
;;;576        if (!Width) {
00071a  b995              CBNZ     r5,|L1.1858|
;;;577          const GUI_FONT GUI_UNI_PTR * pFont = GUI_SetFont(pObj->pFont);
00071c  6c20              LDR      r0,[r4,#0x40]
00071e  f7fffffe          BL       GUI_SetFont
000722  4681              MOV      r9,r0
;;;578          Width = GUI_GetStringDistX(s) + 2 * (pObj->Widget.pEffect->EffectSize + _DefaultBorderH);
000724  4630              MOV      r0,r6
000726  f7fffffe          BL       GUI_GetStringDistX
00072a  6a21              LDR      r1,[r4,#0x20]
00072c  6949              LDR      r1,[r1,#0x14]
00072e  4a62              LDR      r2,|L1.2232|
000730  6812              LDR      r2,[r2,#0]  ; _DefaultBorderH
000732  4411              ADD      r1,r1,r2
000734  2202              MOVS     r2,#2
000736  fb020501          MLA      r5,r2,r1,r0
;;;579          GUI_SetFont(pFont);
00073a  4648              MOV      r0,r9
00073c  f7fffffe          BL       GUI_SetFont
;;;580        }
000740  bf00              NOP      
                  |L1.1858|
;;;581        Column.Width    = Width;
000742  9500              STR      r5,[sp,#0]
;;;582        Column.Align    = Align;
000744  fa0ff088          SXTH     r0,r8
000748  f8ad0004          STRH     r0,[sp,#4]
;;;583        Column.hDrawObj = 0;
00074c  2000              MOVS     r0,#0
00074e  f8ad0006          STRH     r0,[sp,#6]
;;;584        Index = GUI_ARRAY_GetNumItems(&pObj->Columns);
000752  f1040030          ADD      r0,r4,#0x30
000756  f7fffffe          BL       GUI_ARRAY_GetNumItems
00075a  4682              MOV      r10,r0
;;;585        if (GUI_ARRAY_AddItem(&pObj->Columns, &Column, sizeof(HEADER_COLUMN) + strlen(s) + 1) == 0) {
00075c  4630              MOV      r0,r6
00075e  f7fffffe          BL       strlen
000762  f100090d          ADD      r9,r0,#0xd
000766  464a              MOV      r2,r9
000768  4669              MOV      r1,sp
00076a  f1040030          ADD      r0,r4,#0x30
00076e  f7fffffe          BL       GUI_ARRAY_AddItem
000772  b9c0              CBNZ     r0,|L1.1958|
;;;586          HEADER_COLUMN * pColumn;
;;;587          pObj = HEADER_H2P(hObj);
000774  4638              MOV      r0,r7
000776  f7fffffe          BL       GUI_ALLOC_h2p
00077a  4604              MOV      r4,r0
;;;588          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
00077c  4651              MOV      r1,r10
00077e  f1040030          ADD      r0,r4,#0x30
000782  f7fffffe          BL       GUI_ARRAY_GetpItem
000786  4681              MOV      r9,r0
;;;589          strcpy(pColumn->acText, s);
000788  4631              MOV      r1,r6
00078a  f1090008          ADD      r0,r9,#8
00078e  f7fffffe          BL       strcpy
;;;590          WM_InvalidateWindow(hObj);
000792  4638              MOV      r0,r7
000794  f7fffffe          BL       WM_InvalidateWindow
;;;591          WM_InvalidateWindow(WM_GetParent(hObj));
000798  4638              MOV      r0,r7
00079a  f7fffffe          BL       WM_GetParent
00079e  4683              MOV      r11,r0
0007a0  f7fffffe          BL       WM_InvalidateWindow
;;;592        }
0007a4  bf00              NOP      
                  |L1.1958|
;;;593        WM_UNLOCK();
0007a6  f7fffffe          BL       GUI_Unlock
;;;594      }
0007aa  bf00              NOP      
                  |L1.1964|
;;;595    }
0007ac  e8bd8ffe          POP      {r1-r11,pc}
;;;596    
                          ENDP

                  HEADER_DeleteItem PROC
;;;600    */
;;;601    void HEADER_DeleteItem(HEADER_Handle hObj, unsigned Index) {
0007b0  e92d41f0          PUSH     {r4-r8,lr}
0007b4  4604              MOV      r4,r0
0007b6  460d              MOV      r5,r1
;;;602      if (hObj) {
0007b8  b1e4              CBZ      r4,|L1.2036|
;;;603        HEADER_Obj* pObj;
;;;604        WM_LOCK();
0007ba  f7fffffe          BL       GUI_Lock
;;;605        pObj = HEADER_H2P(hObj);
0007be  4620              MOV      r0,r4
0007c0  f7fffffe          BL       GUI_ALLOC_h2p
0007c4  4606              MOV      r6,r0
;;;606        if (Index < GUI_ARRAY_GetNumItems(&pObj->Columns)) {
0007c6  f1060030          ADD      r0,r6,#0x30
0007ca  f7fffffe          BL       GUI_ARRAY_GetNumItems
0007ce  42a8              CMP      r0,r5
0007d0  d90d              BLS      |L1.2030|
;;;607          GUI_ARRAY_DeleteItem(&pObj->Columns, Index);
0007d2  4629              MOV      r1,r5
0007d4  f1060030          ADD      r0,r6,#0x30
0007d8  f7fffffe          BL       GUI_ARRAY_DeleteItem
;;;608          WM_InvalidateWindow(hObj);
0007dc  4620              MOV      r0,r4
0007de  f7fffffe          BL       WM_InvalidateWindow
;;;609          WM_InvalidateWindow(WM_GetParent(hObj));
0007e2  4620              MOV      r0,r4
0007e4  f7fffffe          BL       WM_GetParent
0007e8  4607              MOV      r7,r0
0007ea  f7fffffe          BL       WM_InvalidateWindow
                  |L1.2030|
;;;610        }
;;;611        WM_UNLOCK();
0007ee  f7fffffe          BL       GUI_Unlock
;;;612      }
0007f2  bf00              NOP      
                  |L1.2036|
;;;613    }
0007f4  e8bd81f0          POP      {r4-r8,pc}
;;;614    
                          ENDP

                  HEADER_SetItemText PROC
;;;618    */
;;;619    void HEADER_SetItemText(HEADER_Handle hObj, unsigned int Index, const char* s) {
0007f8  e92d47f0          PUSH     {r4-r10,lr}
0007fc  4605              MOV      r5,r0
0007fe  460e              MOV      r6,r1
000800  4614              MOV      r4,r2
;;;620      if (hObj) {
000802  b31d              CBZ      r5,|L1.2124|
;;;621        HEADER_Obj* pObj;
;;;622        WM_LOCK();
000804  f7fffffe          BL       GUI_Lock
;;;623        pObj = HEADER_H2P(hObj);
000808  4628              MOV      r0,r5
00080a  f7fffffe          BL       GUI_ALLOC_h2p
00080e  4607              MOV      r7,r0
;;;624        if (Index < GUI_ARRAY_GetNumItems(&pObj->Columns)) {
000810  f1070030          ADD      r0,r7,#0x30
000814  f7fffffe          BL       GUI_ARRAY_GetNumItems
000818  42b0              CMP      r0,r6
00081a  d914              BLS      |L1.2118|
;;;625          HEADER_COLUMN* pColumn;
;;;626          pColumn = (HEADER_COLUMN*)GUI_ARRAY_ResizeItem(&pObj->Columns, Index, sizeof(HEADER_COLUMN) + strlen(s));
00081c  4620              MOV      r0,r4
00081e  f7fffffe          BL       strlen
000822  f100090c          ADD      r9,r0,#0xc
000826  464a              MOV      r2,r9
000828  4631              MOV      r1,r6
00082a  f1070030          ADD      r0,r7,#0x30
00082e  f7fffffe          BL       GUI_ARRAY_ResizeItem
000832  4680              MOV      r8,r0
;;;627          if (pColumn) {
000834  f1b80f00          CMP      r8,#0
000838  d004              BEQ      |L1.2116|
;;;628            strcpy(pColumn->acText, s);
00083a  4621              MOV      r1,r4
00083c  f1080008          ADD      r0,r8,#8
000840  f7fffffe          BL       strcpy
                  |L1.2116|
;;;629          }
;;;630        }
000844  bf00              NOP      
                  |L1.2118|
;;;631        WM_UNLOCK();
000846  f7fffffe          BL       GUI_Unlock
;;;632      }
00084a  bf00              NOP      
                  |L1.2124|
;;;633    }
00084c  e8bd87f0          POP      {r4-r10,pc}
;;;634    
                          ENDP

                  HEADER_GetHeight PROC
;;;661    */
;;;662    int HEADER_GetHeight(HEADER_Handle hObj) {
000850  b57c              PUSH     {r2-r6,lr}
000852  4604              MOV      r4,r0
;;;663      int Height = 0;
000854  2500              MOVS     r5,#0
;;;664      if (hObj) {
000856  b19c              CBZ      r4,|L1.2176|
;;;665        GUI_RECT Rect;
;;;666        WM_GetClientRectEx(hObj, &Rect);
000858  4669              MOV      r1,sp
00085a  4620              MOV      r0,r4
00085c  f7fffffe          BL       WM_GetClientRectEx
;;;667        GUI_MoveRect(&Rect, -Rect.x0, -Rect.y0);
000860  f9bd0002          LDRSH    r0,[sp,#2]
000864  4242              RSBS     r2,r0,#0
000866  f9bd0000          LDRSH    r0,[sp,#0]
00086a  4241              RSBS     r1,r0,#0
00086c  4668              MOV      r0,sp
00086e  f7fffffe          BL       GUI_MoveRect
;;;668        Height = Rect.y1 - Rect.y0 + 1;
000872  f9bd0006          LDRSH    r0,[sp,#6]
000876  f9bd1002          LDRSH    r1,[sp,#2]
00087a  1a40              SUBS     r0,r0,r1
00087c  1c45              ADDS     r5,r0,#1
;;;669      }
00087e  bf00              NOP      
                  |L1.2176|
;;;670      return Height;
000880  4628              MOV      r0,r5
;;;671    }
000882  bd7c              POP      {r2-r6,pc}
;;;672    
                          ENDP

                  HEADER_GetNumItems PROC
;;;696    */
;;;697    int  HEADER_GetNumItems(HEADER_Handle hObj) {
000884  b570              PUSH     {r4-r6,lr}
000886  4604              MOV      r4,r0
;;;698      int NumCols = 0;
000888  2500              MOVS     r5,#0
;;;699      if (hObj) {
00088a  b16c              CBZ      r4,|L1.2216|
;;;700        HEADER_Obj * pObj;
;;;701        WM_LOCK();
00088c  f7fffffe          BL       GUI_Lock
;;;702        pObj = HEADER_H2P(hObj);
000890  4620              MOV      r0,r4
000892  f7fffffe          BL       GUI_ALLOC_h2p
000896  4606              MOV      r6,r0
;;;703        NumCols = GUI_ARRAY_GetNumItems(&pObj->Columns);
000898  f1060030          ADD      r0,r6,#0x30
00089c  f7fffffe          BL       GUI_ARRAY_GetNumItems
0008a0  4605              MOV      r5,r0
;;;704        WM_UNLOCK();
0008a2  f7fffffe          BL       GUI_Unlock
;;;705      }
0008a6  bf00              NOP      
                  |L1.2216|
;;;706      return NumCols;
0008a8  4628              MOV      r0,r5
;;;707    }
0008aa  bd70              POP      {r4-r6,pc}
;;;708    
                          ENDP

                  |L1.2220|
                          DCD      _pDefaultCursor
                  |L1.2224|
                          DCD      _DefaultBkColor
                  |L1.2228|
                          DCD      _DefaultTextColor
                  |L1.2232|
                          DCD      _DefaultBorderH
                  |L1.2236|
                          DCD      _DefaultBorderV
                  |L1.2240|
                          DCD      _pDefaultFont

                          AREA ||.data||, DATA, ALIGN=2

                  _pDefaultCursor
                          DCD      GUI_CursorHeaderM
                  _DefaultBkColor
                          DCD      0x00aaaaaa
                  _DefaultTextColor
                          DCD      0x00000000
                  _DefaultBorderH
                          DCD      0x00000002
                  _DefaultBorderV
                          DCD      0x00000000
                  _pDefaultFont
                          DCD      GUI_Font13_1
                  _pOldCursor
                          DCD      0x00000000
