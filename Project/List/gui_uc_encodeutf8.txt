; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Obj\gui_uc_encodeutf8.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\Obj\gui_uc_encodeutf8.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\BaseDrive -I..\Ucosii -I..\Ucosii\Port -I..\Ucosii\Src -I..\Ucosii\Include -I..\Ucgui -I..\Ucgui\Config -I..\Ucgui\GUI_X -I..\Ucgui\GUI -I..\Ucgui\GUI\ConvertColor -I..\Ucgui\GUI\ConvertMono -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\LCDDriver -I..\Ucgui\GUI\MultiLayer -I..\Ucgui\GUI\Widget -I..\Ucgui\GUI\WM -I..\ExternalDrive\Lcd -I..\ExternalDrive\Touch -I..\Panel -I"D:\Program files\Keil\ARM\RV31\Inc" -I"D:\Program files\Keil\ARM\CMSIS\Include" -I"D:\Program files\Keil\ARM\Inc\ST\STM32F10x" -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\gui_uc_encodeutf8.crf ..\Ucgui\GUI\Core\GUI_UC_EncodeUTF8.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _GetCharCode PROC
;;;34     */
;;;35     static U16 _GetCharCode(const char GUI_UNI_PTR * s) {
000000  4602              MOV      r2,r0
;;;36       U16 r;
;;;37       U8 Char = *(const U8*)s;
000002  7811              LDRB     r1,[r2,#0]
;;;38       if ((Char & 0x80) == 0) {                /* Single byte (ASCII)  */
000004  f0110f80          TST      r1,#0x80
000008  d101              BNE      |L1.14|
;;;39         r = Char;
00000a  4608              MOV      r0,r1
00000c  e021              B        |L1.82|
                  |L1.14|
;;;40       } else if ((Char & 0xe0) == 0xc0) {      /* Double byte sequence */
00000e  f00103e0          AND      r3,r1,#0xe0
000012  2bc0              CMP      r3,#0xc0
000014  d108              BNE      |L1.40|
;;;41         r = (Char & 0x1f) << 6;
000016  06cb              LSLS     r3,r1,#27
000018  0d58              LSRS     r0,r3,#21
;;;42         Char = *(++s);
00001a  1c53              ADDS     r3,r2,#1
00001c  461a              MOV      r2,r3
00001e  7819              LDRB     r1,[r3,#0]
;;;43         Char &= 0x3f;
000020  f001013f          AND      r1,r1,#0x3f
;;;44         r |= Char;
000024  4308              ORRS     r0,r0,r1
000026  e014              B        |L1.82|
                  |L1.40|
;;;45       } else if ((Char & 0xf0) == 0xe0) {      /* 3 byte sequence      */
000028  f00103f0          AND      r3,r1,#0xf0
00002c  2be0              CMP      r3,#0xe0
00002e  d10f              BNE      |L1.80|
;;;46         r = (Char & 0x0f) << 12;
000030  070b              LSLS     r3,r1,#28
000032  0c18              LSRS     r0,r3,#16
;;;47         Char = *(++s);
000034  1c53              ADDS     r3,r2,#1
000036  461a              MOV      r2,r3
000038  7819              LDRB     r1,[r3,#0]
;;;48         Char &= 0x3f;
00003a  f001013f          AND      r1,r1,#0x3f
;;;49         r |= (Char << 6);
00003e  ea401081          ORR      r0,r0,r1,LSL #6
;;;50         Char = *(++s);
000042  1c53              ADDS     r3,r2,#1
000044  461a              MOV      r2,r3
000046  7819              LDRB     r1,[r3,#0]
;;;51         Char &= 0x3f;
000048  f001013f          AND      r1,r1,#0x3f
;;;52         r |= Char;
00004c  4308              ORRS     r0,r0,r1
00004e  e000              B        |L1.82|
                  |L1.80|
;;;53       } else {
;;;54         GUI_DEBUG_ERROROUT("Illegal character during UTF-8 decoding!");
;;;55         r = 1;       /* Illegal character. To avoid endless loops in upper layers, we return 1 rather than 0. */
000050  2001              MOVS     r0,#1
                  |L1.82|
;;;56       }
;;;57       return r;
;;;58     }
000052  4770              BX       lr
;;;59     
                          ENDP

                  _GetCharSize PROC
;;;66     */
;;;67     static int _GetCharSize(const char GUI_UNI_PTR * s) {
000054  4602              MOV      r2,r0
;;;68       U8 Char = *s;
000056  7811              LDRB     r1,[r2,#0]
;;;69       if ((Char & 0x80) == 0) {
000058  f0110f80          TST      r1,#0x80
00005c  d101              BNE      |L1.98|
;;;70         return 1;
00005e  2001              MOVS     r0,#1
                  |L1.96|
;;;71       } else if ((Char & 0xe0) == 0xc0) {
;;;72         return 2;
;;;73       } else if ((Char & 0xf0) == 0xe0) {
;;;74         return 3;
;;;75       }
;;;76       GUI_DEBUG_ERROROUT("Illegal character during UTF-8 decoding!");
;;;77       return 1;       /* Illegal character. To avoid endless loops in upper layers, we return 1 rather than 0. */
;;;78     }
000060  4770              BX       lr
                  |L1.98|
000062  f00100e0          AND      r0,r1,#0xe0           ;71
000066  28c0              CMP      r0,#0xc0              ;71
000068  d101              BNE      |L1.110|
00006a  2002              MOVS     r0,#2                 ;72
00006c  e7f8              B        |L1.96|
                  |L1.110|
00006e  f00100f0          AND      r0,r1,#0xf0           ;73
000072  28e0              CMP      r0,#0xe0              ;73
000074  d101              BNE      |L1.122|
000076  2003              MOVS     r0,#3                 ;74
000078  e7f2              B        |L1.96|
                  |L1.122|
00007a  2001              MOVS     r0,#1                 ;77
00007c  e7f0              B        |L1.96|
;;;79     
                          ENDP

                  _CalcSizeOfChar PROC
;;;86     */
;;;87     static int _CalcSizeOfChar(U16 Char) {
00007e  4601              MOV      r1,r0
;;;88       int r;
;;;89       if (Char & 0xF800) {                /* Single byte (ASCII)  */
000080  f4114f78          TST      r1,#0xf800
000084  d001              BEQ      |L1.138|
;;;90         r = 3;
000086  2003              MOVS     r0,#3
000088  e006              B        |L1.152|
                  |L1.138|
;;;91       } else if (Char & 0xFF80) {         /* Double byte sequence */
00008a  f64f7280          MOV      r2,#0xff80
00008e  4211              TST      r1,r2
000090  d001              BEQ      |L1.150|
;;;92         r = 2;
000092  2002              MOVS     r0,#2
000094  e000              B        |L1.152|
                  |L1.150|
;;;93       } else {                            /* 3 byte sequence      */
;;;94         r = 1;
000096  2001              MOVS     r0,#1
                  |L1.152|
;;;95       }
;;;96       return r;
;;;97     }
000098  4770              BX       lr
;;;98     
                          ENDP

                  _Encode PROC
;;;105    */
;;;106    static int _Encode(char *s, U16 Char) {
00009a  b570              PUSH     {r4-r6,lr}
00009c  4604              MOV      r4,r0
00009e  460d              MOV      r5,r1
;;;107      int r;
;;;108      r = _CalcSizeOfChar(Char);
0000a0  4628              MOV      r0,r5
0000a2  f7fffffe          BL       _CalcSizeOfChar
0000a6  4606              MOV      r6,r0
;;;109      switch (r) {
0000a8  2e01              CMP      r6,#1
0000aa  d004              BEQ      |L1.182|
0000ac  2e02              CMP      r6,#2
0000ae  d004              BEQ      |L1.186|
0000b0  2e03              CMP      r6,#3
0000b2  d11e              BNE      |L1.242|
0000b4  e00c              B        |L1.208|
                  |L1.182|
;;;110      case 1:
;;;111        *s = (char)Char;
0000b6  7025              STRB     r5,[r4,#0]
;;;112        break;
0000b8  e01b              B        |L1.242|
                  |L1.186|
;;;113      case 2:
;;;114        *s++ = 0xC0 | (Char >> 6);
0000ba  20c0              MOVS     r0,#0xc0
0000bc  ea4010a5          ORR      r0,r0,r5,ASR #6
0000c0  f8040b01          STRB     r0,[r4],#1
;;;115        *s   = 0x80 | (Char & 0x3F);
0000c4  f005003f          AND      r0,r5,#0x3f
0000c8  f0400080          ORR      r0,r0,#0x80
0000cc  7020              STRB     r0,[r4,#0]
;;;116        break;
0000ce  e010              B        |L1.242|
                  |L1.208|
;;;117      case 3:
;;;118        *s++ = 0xE0 | (Char >> 12);
0000d0  20e0              MOVS     r0,#0xe0
0000d2  ea403025          ORR      r0,r0,r5,ASR #12
0000d6  f8040b01          STRB     r0,[r4],#1
;;;119        *s++ = 0x80 | ((Char >> 6) & 0x3F);
0000da  f3c51085          UBFX     r0,r5,#6,#6
0000de  f0400080          ORR      r0,r0,#0x80
0000e2  f8040b01          STRB     r0,[r4],#1
;;;120        *s   = 0x80 | (Char & 0x3F);
0000e6  f005003f          AND      r0,r5,#0x3f
0000ea  f0400080          ORR      r0,r0,#0x80
0000ee  7020              STRB     r0,[r4,#0]
;;;121        break;
0000f0  bf00              NOP      
                  |L1.242|
0000f2  bf00              NOP                            ;112
;;;122      }
;;;123      return r;
0000f4  4630              MOV      r0,r6
;;;124    }
0000f6  bd70              POP      {r4-r6,pc}
;;;125    
                          ENDP

                  GUI_UC_SetEncodeUTF8 PROC
;;;146    */
;;;147    void GUI_UC_SetEncodeUTF8(void) {
0000f8  b510              PUSH     {r4,lr}
;;;148      GUI_LOCK();
0000fa  f7fffffe          BL       GUI_Lock
;;;149      GUI_Context.pUC_API = &_API_Table;
0000fe  4803              LDR      r0,|L1.268|
000100  4903              LDR      r1,|L1.272|
000102  61c8              STR      r0,[r1,#0x1c]  ; GUI_Context
;;;150      GUI_UNLOCK();
000104  f7fffffe          BL       GUI_Unlock
;;;151    }
000108  bd10              POP      {r4,pc}
;;;152    
                          ENDP

00010a  0000              DCW      0x0000
                  |L1.268|
                          DCD      _API_Table
                  |L1.272|
                          DCD      GUI_Context

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  _API_Table
                          DCD      _GetCharCode
                          DCD      _GetCharSize
                          DCD      _CalcSizeOfChar
                          DCD      _Encode
