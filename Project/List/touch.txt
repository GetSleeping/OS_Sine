; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Obj\touch.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\Obj\touch.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\BaseDrive -I..\Ucosii -I..\Ucosii\Port -I..\Ucosii\Src -I..\Ucosii\Include -I..\Ucgui -I..\Ucgui\Config -I..\Ucgui\GUI_X -I..\Ucgui\GUI -I..\Ucgui\GUI\ConvertColor -I..\Ucgui\GUI\ConvertMono -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\Core -I..\Ucgui\GUI\LCDDriver -I..\Ucgui\GUI\MultiLayer -I..\Ucgui\GUI\Widget -I..\Ucgui\GUI\WM -I..\ExternalDrive\Lcd -I..\ExternalDrive\Touch -I..\Panel -I"D:\Program files\Keil\ARM\RV31\Inc" -I"D:\Program files\Keil\ARM\CMSIS\Include" -I"D:\Program files\Keil\ARM\Inc\ST\STM32F10x" -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\touch.crf ..\ExternalDrive\Touch\Touch.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Delay PROC
;;;11     
;;;12     static void Delay(unsigned int counter)
000000  e006              B        |L1.16|
                  |L1.2|
;;;13     {
;;;14         unsigned int i;
;;;15         for(;counter == 0;counter--)
;;;16             for(i = 0;i<1000;i++);
000002  2100              MOVS     r1,#0
000004  e000              B        |L1.8|
                  |L1.6|
000006  1c49              ADDS     r1,r1,#1
                  |L1.8|
000008  f5b17f7a          CMP      r1,#0x3e8
00000c  d3fb              BCC      |L1.6|
00000e  1e40              SUBS     r0,r0,#1              ;15
                  |L1.16|
000010  2800              CMP      r0,#0                 ;15
000012  d0f6              BEQ      |L1.2|
;;;17     }
000014  4770              BX       lr
;;;18     
                          ENDP

                  Touch_Gpio_Init PROC
;;;19     //触摸IO口初始化
;;;20     static void Touch_Gpio_Init(void)
000016  b508              PUSH     {r3,lr}
;;;21     {
;;;22     	GPIO_InitTypeDef GPIO_InitStructure;
;;;23     	
;;;24     	/* Enable SPI and GPIO clocks */
;;;25     	if(TOUCH_SPI == SPI1) 
;;;26     	    RCC_APB2PeriphClockCmd(TOUCH_SPI_RCC , ENABLE);
;;;27     	else if(TOUCH_SPI == SPI2) 
;;;28     	    RCC_APB1PeriphClockCmd(TOUCH_SPI_RCC , ENABLE);
000018  2101              MOVS     r1,#1
00001a  0388              LSLS     r0,r1,#14
00001c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;29     	else if(TOUCH_SPI == SPI3)
;;;30     	{						   
;;;31     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
;;;32     		GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);//GPIO_Remap_SWJ_Disable 	
;;;33     		RCC_APB1PeriphClockCmd(TOUCH_SPI_RCC , ENABLE);
;;;34     	}
;;;35     
;;;36     	RCC_APB2PeriphClockCmd( SPI_RCC_APB2Periph  | TOUCH_CS_APB2Periph | 
000020  2101              MOVS     r1,#1
000022  f44f7084          MOV      r0,#0x108
000026  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;37     	                        TOUCH_IRQ_APB2Periph | FLASH_CS_APB2Periph | 
;;;38     							SD_CS_APB2Periph, ENABLE);
;;;39     	
;;;40     	/* Configure SPI pins: SCK, MISO and MOSI */
;;;41     	GPIO_InitStructure.GPIO_Pin = SPI_SCK_GPIO_Pin | SPI_MOSI_GPIO_Pin;
00002a  f44f4020          MOV      r0,#0xa000
00002e  f8ad0000          STRH     r0,[sp,#0]
;;;42     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000032  2018              MOVS     r0,#0x18
000034  f88d0003          STRB     r0,[sp,#3]
;;;43     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000038  2003              MOVS     r0,#3
00003a  f88d0002          STRB     r0,[sp,#2]
;;;44     	GPIO_Init(SPI_GPIO, &GPIO_InitStructure);
00003e  4669              MOV      r1,sp
000040  48f9              LDR      r0,|L1.1064|
000042  f7fffffe          BL       GPIO_Init
;;;45     	GPIO_InitStructure.GPIO_Pin = SPI_MISO_GPIO_Pin ;
000046  f44f4080          MOV      r0,#0x4000
00004a  f8ad0000          STRH     r0,[sp,#0]
;;;46     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00004e  2004              MOVS     r0,#4
000050  f88d0003          STRB     r0,[sp,#3]
;;;47     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000054  2003              MOVS     r0,#3
000056  f88d0002          STRB     r0,[sp,#2]
;;;48     	GPIO_Init(SPI_GPIO, &GPIO_InitStructure);
00005a  4669              MOV      r1,sp
00005c  48f2              LDR      r0,|L1.1064|
00005e  f7fffffe          BL       GPIO_Init
;;;49     	
;;;50     	/* Configure TOUCH_IRQ select */
;;;51     	GPIO_InitStructure.GPIO_Pin = TOUCH_IRQ_GPIO_Pin;
000062  2080              MOVS     r0,#0x80
000064  f8ad0000          STRH     r0,[sp,#0]
;;;52     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
000068  2048              MOVS     r0,#0x48
00006a  f88d0003          STRB     r0,[sp,#3]
;;;53     	GPIO_Init(TOUCH_IRQ_GPIO, &GPIO_InitStructure);
00006e  4669              MOV      r1,sp
000070  48ee              LDR      r0,|L1.1068|
000072  f7fffffe          BL       GPIO_Init
;;;54     	
;;;55     	/* Configure TOUCH_CS select */
;;;56     	GPIO_InitStructure.GPIO_Pin = TOUCH_CS_GPIO_Pin;
000076  f44f5080          MOV      r0,#0x1000
00007a  f8ad0000          STRH     r0,[sp,#0]
;;;57     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00007e  2010              MOVS     r0,#0x10
000080  f88d0003          STRB     r0,[sp,#3]
;;;58     	GPIO_Init(TOUCH_CS_GPIO, &GPIO_InitStructure);
000084  4669              MOV      r1,sp
000086  48e8              LDR      r0,|L1.1064|
000088  f7fffffe          BL       GPIO_Init
;;;59      
;;;60     	/* Configure FLASH_CS select */
;;;61     	GPIO_InitStructure.GPIO_Pin = FLASH_CS_GPIO_Pin;
00008c  f44f6000          MOV      r0,#0x800
000090  f8ad0000          STRH     r0,[sp,#0]
;;;62     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000094  2010              MOVS     r0,#0x10
000096  f88d0003          STRB     r0,[sp,#3]
;;;63     	GPIO_Init(FLASH_CS_GPIO, &GPIO_InitStructure);
00009a  4669              MOV      r1,sp
00009c  48e3              LDR      r0,|L1.1068|
00009e  f7fffffe          BL       GPIO_Init
;;;64     	
;;;65     	/* Configure TOUCH_CS select */
;;;66     	GPIO_InitStructure.GPIO_Pin = SD_CS_GPIO_Pin;
0000a2  f44f4000          MOV      r0,#0x8000
0000a6  f8ad0000          STRH     r0,[sp,#0]
;;;67     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
0000aa  2010              MOVS     r0,#0x10
0000ac  f88d0003          STRB     r0,[sp,#3]
;;;68     	GPIO_Init(SD_CS_GPIO, &GPIO_InitStructure);
0000b0  4669              MOV      r1,sp
0000b2  48de              LDR      r0,|L1.1068|
0000b4  f7fffffe          BL       GPIO_Init
;;;69     	
;;;70     	NotSelect_TOUCH_CS();
0000b8  f44f5180          MOV      r1,#0x1000
0000bc  48da              LDR      r0,|L1.1064|
0000be  f7fffffe          BL       GPIO_SetBits
;;;71     	NotSelect_FLASH_CS();
0000c2  f44f6100          MOV      r1,#0x800
0000c6  48d9              LDR      r0,|L1.1068|
0000c8  f7fffffe          BL       GPIO_SetBits
;;;72     	NotSelect_SD_CS();
0000cc  f44f4100          MOV      r1,#0x8000
0000d0  48d6              LDR      r0,|L1.1068|
0000d2  f7fffffe          BL       GPIO_SetBits
;;;73          
;;;74     }
0000d6  bd08              POP      {r3,pc}
;;;75     
                          ENDP

                  TouchSPIx_Init PROC
;;;76     /*SPIX初始化*/
;;;77     static void  TouchSPIx_Init(void)
0000d8  b500              PUSH     {lr}
;;;78     {  
0000da  b085              SUB      sp,sp,#0x14
;;;79     	SPI_InitTypeDef  SPI_InitStructure;
;;;80     	
;;;81     	NotSelect_TOUCH_CS();
0000dc  f44f5180          MOV      r1,#0x1000
0000e0  48d1              LDR      r0,|L1.1064|
0000e2  f7fffffe          BL       GPIO_SetBits
;;;82     	
;;;83     	/* SPI1 configuration */
;;;84     	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
0000e6  2000              MOVS     r0,#0
0000e8  f8ad0000          STRH     r0,[sp,#0]
;;;85     	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
0000ec  f44f7082          MOV      r0,#0x104
0000f0  f8ad0002          STRH     r0,[sp,#2]
;;;86     	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
0000f4  2000              MOVS     r0,#0
0000f6  f8ad0004          STRH     r0,[sp,#4]
;;;87     	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
0000fa  f8ad0006          STRH     r0,[sp,#6]
;;;88     	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
0000fe  f8ad0008          STRH     r0,[sp,#8]
;;;89     	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
000102  f44f7000          MOV      r0,#0x200
000106  f8ad000a          STRH     r0,[sp,#0xa]
;;;90     	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;//	 SPI_BaudRatePrescaler_32
00010a  2038              MOVS     r0,#0x38
00010c  f8ad000c          STRH     r0,[sp,#0xc]
;;;91     	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
000110  2000              MOVS     r0,#0
000112  f8ad000e          STRH     r0,[sp,#0xe]
;;;92     	SPI_InitStructure.SPI_CRCPolynomial = 7;
000116  2007              MOVS     r0,#7
000118  f8ad0010          STRH     r0,[sp,#0x10]
;;;93     	SPI_Init(TOUCH_SPI, &SPI_InitStructure);
00011c  4669              MOV      r1,sp
00011e  48c4              LDR      r0,|L1.1072|
000120  f7fffffe          BL       SPI_Init
;;;94     	
;;;95     	/* Enable SPI1  */
;;;96     	SPI_Cmd(TOUCH_SPI, ENABLE);
000124  2101              MOVS     r1,#1
000126  48c2              LDR      r0,|L1.1072|
000128  f7fffffe          BL       SPI_Cmd
;;;97     }
00012c  b005              ADD      sp,sp,#0x14
00012e  bd00              POP      {pc}
;;;98     //触摸中断实始化
                          ENDP

                  TOUCH_EXTI_Configuration PROC
;;;99     static void TOUCH_EXTI_Configuration(void)
000130  b51c              PUSH     {r2-r4,lr}
;;;100    {
;;;101    	EXTI_InitTypeDef EXTI_InitStructure;
;;;102    
;;;103    	GPIO_EXTILineConfig(GPIO_PortSourceGPIOG, TOUCH_IRQ_CONFIG); 
000132  2107              MOVS     r1,#7
000134  2006              MOVS     r0,#6
000136  f7fffffe          BL       GPIO_EXTILineConfig
;;;104    
;;;105    	EXTI_InitStructure.EXTI_Line = TOUCH_IRQ_LINE; 
00013a  2080              MOVS     r0,#0x80
00013c  9000              STR      r0,[sp,#0]
;;;106    	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
00013e  2000              MOVS     r0,#0
000140  f88d0004          STRB     r0,[sp,#4]
;;;107    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
000144  200c              MOVS     r0,#0xc
000146  f88d0005          STRB     r0,[sp,#5]
;;;108    	EXTI_InitStructure.EXTI_LineCmd	= ENABLE;
00014a  2001              MOVS     r0,#1
00014c  f88d0006          STRB     r0,[sp,#6]
;;;109    	EXTI_Init(&EXTI_InitStructure);
000150  4668              MOV      r0,sp
000152  f7fffffe          BL       EXTI_Init
;;;110    
;;;111    	EXTI_GenerateSWInterrupt(TOUCH_IRQ_LINE); // 配置 管脚NRF_IRQ_LINE用作外部中断线路
000156  2080              MOVS     r0,#0x80
000158  f7fffffe          BL       EXTI_GenerateSWInterrupt
;;;112    }
00015c  bd1c              POP      {r2-r4,pc}
;;;113    
                          ENDP

                  SPI_SendByte PROC
;;;114    /*SPI读写一字节*/
;;;115    uchar SPI_SendByte(unsigned char byte)
00015e  b510              PUSH     {r4,lr}
;;;116    {
000160  4604              MOV      r4,r0
;;;117    	/* Loop while DR register in not emplty */
;;;118    	while (SPI_I2S_GetFlagStatus(TOUCH_SPI, SPI_I2S_FLAG_TXE) == RESET);
000162  bf00              NOP      
                  |L1.356|
000164  2102              MOVS     r1,#2
000166  48b2              LDR      r0,|L1.1072|
000168  f7fffffe          BL       SPI_I2S_GetFlagStatus
00016c  2800              CMP      r0,#0
00016e  d0f9              BEQ      |L1.356|
;;;119    	
;;;120    	/* Send byte through the SPI1 peripheral */
;;;121    	SPI_I2S_SendData(TOUCH_SPI, byte);
000170  4621              MOV      r1,r4
000172  48af              LDR      r0,|L1.1072|
000174  f7fffffe          BL       SPI_I2S_SendData
;;;122    	
;;;123    	/* Wait to receive a byte */
;;;124    	while (SPI_I2S_GetFlagStatus(TOUCH_SPI, SPI_I2S_FLAG_RXNE) == RESET);
000178  bf00              NOP      
                  |L1.378|
00017a  2101              MOVS     r1,#1
00017c  48ac              LDR      r0,|L1.1072|
00017e  f7fffffe          BL       SPI_I2S_GetFlagStatus
000182  2800              CMP      r0,#0
000184  d0f9              BEQ      |L1.378|
;;;125    	
;;;126    	/* Return the byte read from the SPI bus */
;;;127    	return SPI_I2S_ReceiveData(TOUCH_SPI);
000186  48aa              LDR      r0,|L1.1072|
000188  f7fffffe          BL       SPI_I2S_ReceiveData
00018c  b2c0              UXTB     r0,r0
;;;128    }
00018e  bd10              POP      {r4,pc}
;;;129    
                          ENDP

                  ADS_Read_AD PROC
;;;342    //从7846/7843/XPT2046/UH7843/UH7846读取adc值	   
;;;343    uint16_t ADS_Read_AD(uint8_t CMD)	  
000190  b570              PUSH     {r4-r6,lr}
;;;344    { 	 
000192  4606              MOV      r6,r0
;;;345    //	u8 i;	  
;;;346    	uint16_t Num,Date; 
;;;347    
;;;348    	Select_TOUCH_CS();
000194  f44f5180          MOV      r1,#0x1000
000198  48a3              LDR      r0,|L1.1064|
00019a  f7fffffe          BL       GPIO_ResetBits
;;;349    
;;;350        SPI_SendByte(CMD); 
00019e  4630              MOV      r0,r6
0001a0  f7fffffe          BL       SPI_SendByte
;;;351    	//for(i=100;i>0;i--); 
;;;352    	Num=0;
0001a4  2500              MOVS     r5,#0
;;;353    	Date=0;
0001a6  2400              MOVS     r4,#0
;;;354    	Num = SPI_SendByte(0x00);
0001a8  2000              MOVS     r0,#0
0001aa  f7fffffe          BL       SPI_SendByte
0001ae  4605              MOV      r5,r0
;;;355    	Date = Num << 8;
0001b0  022c              LSLS     r4,r5,#8
;;;356    	Num = SPI_SendByte(0x00);
0001b2  2000              MOVS     r0,#0
0001b4  f7fffffe          BL       SPI_SendByte
0001b8  4605              MOV      r5,r0
;;;357    
;;;358    	Date |= Num; 
0001ba  432c              ORRS     r4,r4,r5
;;;359    
;;;360        Date >>=3;
0001bc  10e4              ASRS     r4,r4,#3
;;;361        Date &=0XFFF;
0001be  f3c4040b          UBFX     r4,r4,#0,#12
;;;362    
;;;363    	NotSelect_TOUCH_CS();
0001c2  f44f5180          MOV      r1,#0x1000
0001c6  4898              LDR      r0,|L1.1064|
0001c8  f7fffffe          BL       GPIO_SetBits
;;;364    	return(Date); 
0001cc  4620              MOV      r0,r4
;;;365    }
0001ce  bd70              POP      {r4-r6,pc}
;;;366    
                          ENDP

                  ADS_Read_XY PROC
;;;371    #define LOST_VAL 1	  //丢弃值
;;;372    uint16_t ADS_Read_XY(uint8_t xy)
0001d0  e92d41fc          PUSH     {r2-r8,lr}
;;;373    {
0001d4  4680              MOV      r8,r0
;;;374    	uint16_t i, j;
;;;375    	uint16_t buf[READ_TIMES];
;;;376    	uint16_t sum=0;
0001d6  2600              MOVS     r6,#0
;;;377    	uint16_t temp;
;;;378    	for(i=0;i<READ_TIMES;i++)
0001d8  2400              MOVS     r4,#0
0001da  e006              B        |L1.490|
                  |L1.476|
;;;379    	{				 
;;;380    		buf[i]=ADS_Read_AD(xy);	    
0001dc  4640              MOV      r0,r8
0001de  f7fffffe          BL       ADS_Read_AD
0001e2  f82d0014          STRH     r0,[sp,r4,LSL #1]
0001e6  1c60              ADDS     r0,r4,#1              ;378
0001e8  b284              UXTH     r4,r0                 ;378
                  |L1.490|
0001ea  2c03              CMP      r4,#3                 ;378
0001ec  dbf6              BLT      |L1.476|
;;;381    	}				    
;;;382    	for(i=0;i<READ_TIMES-1; i++)//排序
0001ee  2400              MOVS     r4,#0
0001f0  e016              B        |L1.544|
                  |L1.498|
;;;383    	{
;;;384    		for(j=i+1;j<READ_TIMES;j++)
0001f2  1c60              ADDS     r0,r4,#1
0001f4  b285              UXTH     r5,r0
0001f6  e00f              B        |L1.536|
                  |L1.504|
;;;385    		{
;;;386    			if(buf[i]>buf[j])//升序排列
0001f8  f83d0014          LDRH     r0,[sp,r4,LSL #1]
0001fc  f83d1015          LDRH     r1,[sp,r5,LSL #1]
000200  4288              CMP      r0,r1
000202  dd07              BLE      |L1.532|
;;;387    			{
;;;388    				temp=buf[i];
000204  f83d7014          LDRH     r7,[sp,r4,LSL #1]
;;;389    				buf[i]=buf[j];
000208  f83d0015          LDRH     r0,[sp,r5,LSL #1]
00020c  f82d0014          STRH     r0,[sp,r4,LSL #1]
;;;390    				buf[j]=temp;
000210  f82d7015          STRH     r7,[sp,r5,LSL #1]
                  |L1.532|
000214  1c68              ADDS     r0,r5,#1              ;384
000216  b285              UXTH     r5,r0                 ;384
                  |L1.536|
000218  2d03              CMP      r5,#3                 ;384
00021a  dbed              BLT      |L1.504|
00021c  1c60              ADDS     r0,r4,#1              ;382
00021e  b284              UXTH     r4,r0                 ;382
                  |L1.544|
000220  2c02              CMP      r4,#2                 ;382
000222  dbe6              BLT      |L1.498|
;;;391    			}
;;;392    		}
;;;393    	}	  
;;;394    	sum=0;
000224  2600              MOVS     r6,#0
;;;395    	for(i=LOST_VAL;i<READ_TIMES-LOST_VAL;i++)sum+=buf[i];
000226  2401              MOVS     r4,#1
000228  e005              B        |L1.566|
                  |L1.554|
00022a  f83d0014          LDRH     r0,[sp,r4,LSL #1]
00022e  4430              ADD      r0,r0,r6
000230  b286              UXTH     r6,r0
000232  1c60              ADDS     r0,r4,#1
000234  b284              UXTH     r4,r0
                  |L1.566|
000236  2c02              CMP      r4,#2
000238  dbf7              BLT      |L1.554|
;;;396    	temp=sum/(READ_TIMES-2*LOST_VAL);
00023a  4637              MOV      r7,r6
;;;397    	return temp;   
00023c  4638              MOV      r0,r7
;;;398    } 
00023e  e8bd81fc          POP      {r2-r8,pc}
;;;399    
                          ENDP

                  Read_ADS PROC
;;;401    //最小值不能少于100.
;;;402    u8 Read_ADS(uint16_t *x,uint16_t *y)
000242  e92d41f0          PUSH     {r4-r8,lr}
;;;403    {
000246  4604              MOV      r4,r0
000248  460d              MOV      r5,r1
;;;404    	uint16_t xtemp,ytemp;			 	 		  
;;;405    	xtemp=ADS_Read_XY(CMD_RDX);
00024a  20d0              MOVS     r0,#0xd0
00024c  f7fffffe          BL       ADS_Read_XY
000250  4606              MOV      r6,r0
;;;406    	ytemp=ADS_Read_XY(CMD_RDY);
000252  2090              MOVS     r0,#0x90
000254  f7fffffe          BL       ADS_Read_XY
000258  4607              MOV      r7,r0
;;;407    //	xtemp=ADS_Read_AD(CMD_RDX);
;;;408    //	ytemp=ADS_Read_AD(CMD_RDY);
;;;409    	  												   
;;;410    	if(xtemp<100||ytemp<100)return 0;//读数失败
00025a  2e64              CMP      r6,#0x64
00025c  db01              BLT      |L1.610|
00025e  2f64              CMP      r7,#0x64
000260  da02              BGE      |L1.616|
                  |L1.610|
000262  2000              MOVS     r0,#0
                  |L1.612|
;;;411    	*x=xtemp;
;;;412    	*y=ytemp;
;;;413    	return 1;//读数成功
;;;414    }
000264  e8bd81f0          POP      {r4-r8,pc}
                  |L1.616|
000268  8026              STRH     r6,[r4,#0]            ;411
00026a  802f              STRH     r7,[r5,#0]            ;412
00026c  2001              MOVS     r0,#1                 ;413
00026e  e7f9              B        |L1.612|
;;;415    
                          ENDP

                  Read_ADS2 PROC
;;;133    #define ERR_RANGE 50 //误差范围 
;;;134    uint8_t Read_ADS2(uint16_t *x,uint16_t *y) 
000270  b57f              PUSH     {r0-r6,lr}
;;;135    {
000272  4604              MOV      r4,r0
000274  460d              MOV      r5,r1
;;;136    	u16 x1,y1;
;;;137     	u16 x2,y2;
;;;138     	u8 flag;    
;;;139        flag=Read_ADS(&x1,&y1);   
000276  a902              ADD      r1,sp,#8
000278  a803              ADD      r0,sp,#0xc
00027a  f7fffffe          BL       Read_ADS
00027e  4606              MOV      r6,r0
;;;140        if(flag==0)return(0);
000280  b916              CBNZ     r6,|L1.648|
000282  2000              MOVS     r0,#0
                  |L1.644|
;;;141        flag=Read_ADS(&x2,&y2);	   
;;;142        if(flag==0)return(0);   
;;;143        if(((x2<=x1&&x1<x2+ERR_RANGE)||(x1<=x2&&x2<x1+ERR_RANGE))//前后两次采样在+-50内
;;;144        &&((y2<=y1&&y1<y2+ERR_RANGE)||(y1<=y2&&y2<y1+ERR_RANGE)))
;;;145        {
;;;146            *x=(x1+x2)/2;
;;;147            *y=(y1+y2)/2;
;;;148            return 1;
;;;149        }else return 0;	  
;;;150    } 
000284  b004              ADD      sp,sp,#0x10
000286  bd70              POP      {r4-r6,pc}
                  |L1.648|
000288  4669              MOV      r1,sp                 ;141
00028a  a801              ADD      r0,sp,#4              ;141
00028c  f7fffffe          BL       Read_ADS
000290  4606              MOV      r6,r0                 ;141
000292  b90e              CBNZ     r6,|L1.664|
000294  2000              MOVS     r0,#0                 ;142
000296  e7f5              B        |L1.644|
                  |L1.664|
000298  f8bd0004          LDRH     r0,[sp,#4]            ;143
00029c  f8bd100c          LDRH     r1,[sp,#0xc]          ;143
0002a0  4288              CMP      r0,r1                 ;143
0002a2  dc06              BGT      |L1.690|
0002a4  f8bd100c          LDRH     r1,[sp,#0xc]          ;143
0002a8  f8bd0004          LDRH     r0,[sp,#4]            ;143
0002ac  3032              ADDS     r0,r0,#0x32           ;143
0002ae  4281              CMP      r1,r0                 ;143
0002b0  db0c              BLT      |L1.716|
                  |L1.690|
0002b2  f8bd000c          LDRH     r0,[sp,#0xc]          ;143
0002b6  f8bd1004          LDRH     r1,[sp,#4]            ;143
0002ba  4288              CMP      r0,r1                 ;143
0002bc  dc36              BGT      |L1.812|
0002be  f8bd1004          LDRH     r1,[sp,#4]            ;143
0002c2  f8bd000c          LDRH     r0,[sp,#0xc]          ;143
0002c6  3032              ADDS     r0,r0,#0x32           ;143
0002c8  4281              CMP      r1,r0                 ;143
0002ca  da2f              BGE      |L1.812|
                  |L1.716|
0002cc  f8bd0000          LDRH     r0,[sp,#0]            ;144
0002d0  f8bd1008          LDRH     r1,[sp,#8]            ;144
0002d4  4288              CMP      r0,r1                 ;144
0002d6  dc06              BGT      |L1.742|
0002d8  f8bd1008          LDRH     r1,[sp,#8]            ;144
0002dc  f8bd0000          LDRH     r0,[sp,#0]            ;144
0002e0  3032              ADDS     r0,r0,#0x32           ;144
0002e2  4281              CMP      r1,r0                 ;144
0002e4  db0c              BLT      |L1.768|
                  |L1.742|
0002e6  f8bd0008          LDRH     r0,[sp,#8]            ;144
0002ea  f8bd1000          LDRH     r1,[sp,#0]            ;144
0002ee  4288              CMP      r0,r1                 ;144
0002f0  dc1c              BGT      |L1.812|
0002f2  f8bd1000          LDRH     r1,[sp,#0]            ;144
0002f6  f8bd0008          LDRH     r0,[sp,#8]            ;144
0002fa  3032              ADDS     r0,r0,#0x32           ;144
0002fc  4281              CMP      r1,r0                 ;144
0002fe  da15              BGE      |L1.812|
                  |L1.768|
000300  f8bd100c          LDRH     r1,[sp,#0xc]          ;146
000304  f8bd2004          LDRH     r2,[sp,#4]            ;146
000308  1888              ADDS     r0,r1,r2              ;146
00030a  eb0071d0          ADD      r1,r0,r0,LSR #31      ;146
00030e  f3c1014f          UBFX     r1,r1,#1,#16          ;146
000312  8021              STRH     r1,[r4,#0]            ;146
000314  f8bd1008          LDRH     r1,[sp,#8]            ;147
000318  f8bd2000          LDRH     r2,[sp,#0]            ;147
00031c  1888              ADDS     r0,r1,r2              ;147
00031e  eb0071d0          ADD      r1,r0,r0,LSR #31      ;147
000322  f3c1014f          UBFX     r1,r1,#1,#16          ;147
000326  8029              STRH     r1,[r5,#0]            ;147
000328  2001              MOVS     r0,#1                 ;148
00032a  e7ab              B        |L1.644|
                  |L1.812|
00032c  2000              MOVS     r0,#0                 ;149
00032e  e7a9              B        |L1.644|
;;;151    /*****************************************************************************
                          ENDP

                  Pen_Int_Set PROC
;;;158    *****************************************************************************/	 
;;;159    void Pen_Int_Set(uint8_t en)
000330  b130              CBZ      r0,|L1.832|
;;;160    {
;;;161    	if(en)EXTI->IMR|=1<<7;   //开启line13上的中断	  	
000332  4940              LDR      r1,|L1.1076|
000334  6809              LDR      r1,[r1,#0]
000336  f0410180          ORR      r1,r1,#0x80
00033a  4a3e              LDR      r2,|L1.1076|
00033c  6011              STR      r1,[r2,#0]
00033e  e005              B        |L1.844|
                  |L1.832|
;;;162    	else EXTI->IMR&=~(1<<7); //关闭line13上的中断	   
000340  493c              LDR      r1,|L1.1076|
000342  6809              LDR      r1,[r1,#0]
000344  f0210180          BIC      r1,r1,#0x80
000348  4a3a              LDR      r2,|L1.1076|
00034a  6011              STR      r1,[r2,#0]
                  |L1.844|
;;;163    }
00034c  4770              BX       lr
;;;164    //读取一次坐标值	
                          ENDP

                  Read_TP_Once PROC
;;;165    //仅仅读取一次,知道PEN松开才返回!					   
;;;166    uint8_t Read_TP_Once(void)
00034e  b510              PUSH     {r4,lr}
;;;167    {
;;;168    //	u8 t=0;	    
;;;169    	Pen_Int_Set(0);//关闭中断
000350  2000              MOVS     r0,#0
000352  f7fffffe          BL       Pen_Int_Set
;;;170    
;;;171    
;;;172    	Pen_Point.Key_Sta=Key_Up;
000356  2000              MOVS     r0,#0
000358  4937              LDR      r1,|L1.1080|
00035a  7208              STRB     r0,[r1,#8]
;;;173    
;;;174    	if(Read_ADS2(&Pen_Point.X,&Pen_Point.Y))
00035c  1d89              ADDS     r1,r1,#6
00035e  1e88              SUBS     r0,r1,#2
000360  f7fffffe          BL       Read_ADS2
000364  b138              CBZ      r0,|L1.886|
;;;175    	{
;;;176    	    Delay(10);
000366  200a              MOVS     r0,#0xa
000368  f7fffffe          BL       Delay
;;;177    		Pen_Int_Set(1);//开启中断
00036c  2001              MOVS     r0,#1
00036e  f7fffffe          BL       Pen_Int_Set
;;;178    	    return 1;
000372  2001              MOVS     r0,#1
                  |L1.884|
;;;179    	}
;;;180    	else
;;;181    	{ 
;;;182    		Pen_Int_Set(1);//开启中断
;;;183    	    return 0;
;;;184    	}	
;;;185    }
000374  bd10              POP      {r4,pc}
                  |L1.886|
000376  2001              MOVS     r0,#1                 ;182
000378  f7fffffe          BL       Pen_Int_Set
00037c  2000              MOVS     r0,#0                 ;183
00037e  e7f9              B        |L1.884|
;;;186    //////////////////////////////////////////////////
                          ENDP

                  Drow_Touch_Point PROC
;;;189    //用来校准用的
;;;190    void Drow_Touch_Point(uint8_t x,uint16_t y)
000380  b570              PUSH     {r4-r6,lr}
;;;191    {
000382  4604              MOV      r4,r0
000384  460d              MOV      r5,r1
;;;192    	Draw_Circle(x,y,6,Red);//画中心圈
000386  f44f4378          MOV      r3,#0xf800
00038a  2206              MOVS     r2,#6
00038c  4629              MOV      r1,r5
00038e  4620              MOV      r0,r4
000390  f7fffffe          BL       Draw_Circle
;;;193    }
000394  bd70              POP      {r4-r6,pc}
;;;194    //触摸屏校准代码
                          ENDP

                  Touch_Adjust PROC
;;;195    //得到四个校准参数
;;;196    void Touch_Adjust(void)
000396  e92d4ff0          PUSH     {r4-r11,lr}
;;;197    {								 
00039a  b087              SUB      sp,sp,#0x1c
;;;198    	uint16_t pos_temp[4][2];//坐标缓存值
;;;199    	uint8_t  cnt=0;	
00039c  f04f0800          MOV      r8,#0
;;;200    	uint16_t d1,d2;
;;;201    	uint32_t tem1,tem2;
;;;202    	float fac; 	   
;;;203    	cnt=0;				 
0003a0  bf00              NOP      
;;;204    	LCD_Clear(White);//清屏 
0003a2  f64f70ff          MOV      r0,#0xffff
0003a6  f7fffffe          BL       LCD_Clear
;;;205    	Drow_Touch_Point(20,20);//画点1 
0003aa  2114              MOVS     r1,#0x14
0003ac  4608              MOV      r0,r1
0003ae  f7fffffe          BL       Drow_Touch_Point
;;;206    	Pen_Point.Key_Sta=Key_Up;//消除触发信号 
0003b2  2000              MOVS     r0,#0
0003b4  4920              LDR      r1,|L1.1080|
0003b6  7208              STRB     r0,[r1,#8]
;;;207    	Pen_Point.xfac=0;//xfac用来标记是否校准过,所以校准之前必须清掉!以免错误	 
0003b8  60c8              STR      r0,[r1,#0xc]  ; Pen_Point
;;;208    	while(1)
0003ba  e204              B        |L1.1990|
                  |L1.956|
;;;209    	{
;;;210    		if(Pen_Point.Key_Sta==Key_Down)//按键按下了
0003bc  481e              LDR      r0,|L1.1080|
0003be  7a00              LDRB     r0,[r0,#8]  ; Pen_Point
0003c0  2801              CMP      r0,#1
0003c2  d16f              BNE      |L1.1188|
;;;211    		{
;;;212    			if(Read_TP_Once())//得到单次按键值
0003c4  f7fffffe          BL       Read_TP_Once
0003c8  b168              CBZ      r0,|L1.998|
;;;213    			{  								   
;;;214    				pos_temp[cnt][0]=Pen_Point.X;
0003ca  481b              LDR      r0,|L1.1080|
0003cc  8880              LDRH     r0,[r0,#4]  ; Pen_Point
0003ce  a903              ADD      r1,sp,#0xc
0003d0  f8210028          STRH     r0,[r1,r8,LSL #2]
;;;215    				pos_temp[cnt][1]=Pen_Point.Y;
0003d4  4818              LDR      r0,|L1.1080|
0003d6  88c0              LDRH     r0,[r0,#6]  ; Pen_Point
0003d8  eb010188          ADD      r1,r1,r8,LSL #2
0003dc  8048              STRH     r0,[r1,#2]
;;;216    				cnt++;
0003de  f1080001          ADD      r0,r8,#1
0003e2  f00008ff          AND      r8,r0,#0xff
                  |L1.998|
;;;217    			}			 
;;;218    			switch(cnt)
0003e6  f1b80f01          CMP      r8,#1
0003ea  d009              BEQ      |L1.1024|
0003ec  f1b80f02          CMP      r8,#2
0003f0  d00f              BEQ      |L1.1042|
0003f2  f1b80f03          CMP      r8,#3
0003f6  d021              BEQ      |L1.1084|
0003f8  f1b80f04          CMP      r8,#4
0003fc  d108              BNE      |L1.1040|
0003fe  e027              B        |L1.1104|
                  |L1.1024|
;;;219    			{			   
;;;220    				case 1:
;;;221    					LCD_Clear(White);//清屏 
000400  f64f70ff          MOV      r0,#0xffff
000404  f7fffffe          BL       LCD_Clear
;;;222    					Drow_Touch_Point(220,20);//画点2
000408  2114              MOVS     r1,#0x14
00040a  20dc              MOVS     r0,#0xdc
00040c  f7fffffe          BL       Drow_Touch_Point
                  |L1.1040|
;;;223    					break;
000410  e1d7              B        |L1.1986|
                  |L1.1042|
;;;224    				case 2:
;;;225    					LCD_Clear(White);//清屏 
000412  f64f70ff          MOV      r0,#0xffff
000416  f7fffffe          BL       LCD_Clear
;;;226    					Drow_Touch_Point(20,300);//画点3
00041a  f44f7196          MOV      r1,#0x12c
00041e  2014              MOVS     r0,#0x14
000420  f7fffffe          BL       Drow_Touch_Point
;;;227    					break;
000424  e1cd              B        |L1.1986|
000426  0000              DCW      0x0000
                  |L1.1064|
                          DCD      0x40010c00
                  |L1.1068|
                          DCD      0x40012000
                  |L1.1072|
                          DCD      0x40003800
                  |L1.1076|
                          DCD      0x40010400
                  |L1.1080|
                          DCD      Pen_Point
                  |L1.1084|
;;;228    				case 3:
;;;229    					LCD_Clear(White);//清屏 
00043c  f64f70ff          MOV      r0,#0xffff
000440  f7fffffe          BL       LCD_Clear
;;;230    					Drow_Touch_Point(220,300);//画点4
000444  f44f7196          MOV      r1,#0x12c
000448  20dc              MOVS     r0,#0xdc
00044a  f7fffffe          BL       Drow_Touch_Point
;;;231    					break;
00044e  e1b8              B        |L1.1986|
                  |L1.1104|
;;;232    				case 4:	 //全部四个点已经得到
;;;233    	    		    	//对边相等
;;;234    					tem1=abs(pos_temp[0][0]-pos_temp[1][0]);//x1-x2
000450  f8bd100c          LDRH     r1,[sp,#0xc]
000454  f8bd2010          LDRH     r2,[sp,#0x10]
000458  1a88              SUBS     r0,r1,r2
00045a  d401              BMI      |L1.1120|
00045c  4601              MOV      r1,r0
00045e  e000              B        |L1.1122|
                  |L1.1120|
000460  4241              RSBS     r1,r0,#0
                  |L1.1122|
000462  460e              MOV      r6,r1
;;;235    					tem2=abs(pos_temp[0][1]-pos_temp[1][1]);//y1-y2
000464  f8bd200e          LDRH     r2,[sp,#0xe]
000468  f8bd1012          LDRH     r1,[sp,#0x12]
00046c  1a50              SUBS     r0,r2,r1
00046e  d401              BMI      |L1.1140|
000470  4601              MOV      r1,r0
000472  e000              B        |L1.1142|
                  |L1.1140|
000474  4241              RSBS     r1,r0,#0
                  |L1.1142|
000476  460f              MOV      r7,r1
;;;236    					tem1*=tem1;
000478  4376              MULS     r6,r6,r6
;;;237    					tem2*=tem2;
00047a  437f              MULS     r7,r7,r7
;;;238    					d1=sqrt(tem1+tem2);//得到1,2的距离
00047c  19f0              ADDS     r0,r6,r7
00047e  f7fffffe          BL       __aeabi_ui2d
000482  e9cd0100          STRD     r0,r1,[sp,#0]
000486  f7fffffe          BL       sqrt
00048a  4604              MOV      r4,r0
00048c  f7fffffe          BL       __aeabi_d2uiz
000490  fa1ff980          UXTH     r9,r0
;;;239    					
;;;240    					tem1=abs(pos_temp[2][0]-pos_temp[3][0]);//x3-x4
000494  f8bd1014          LDRH     r1,[sp,#0x14]
000498  f8bd2018          LDRH     r2,[sp,#0x18]
00049c  1a88              SUBS     r0,r1,r2
00049e  d402              BMI      |L1.1190|
0004a0  4601              MOV      r1,r0
0004a2  e001              B        |L1.1192|
                  |L1.1188|
0004a4  e18e              B        |L1.1988|
                  |L1.1190|
0004a6  4241              RSBS     r1,r0,#0
                  |L1.1192|
0004a8  460e              MOV      r6,r1
;;;241    					tem2=abs(pos_temp[2][1]-pos_temp[3][1]);//y3-y4
0004aa  f8bd2016          LDRH     r2,[sp,#0x16]
0004ae  f8bd101a          LDRH     r1,[sp,#0x1a]
0004b2  1a50              SUBS     r0,r2,r1
0004b4  d401              BMI      |L1.1210|
0004b6  4601              MOV      r1,r0
0004b8  e000              B        |L1.1212|
                  |L1.1210|
0004ba  4241              RSBS     r1,r0,#0
                  |L1.1212|
0004bc  460f              MOV      r7,r1
;;;242    					tem1*=tem1;
0004be  4376              MULS     r6,r6,r6
;;;243    					tem2*=tem2;
0004c0  437f              MULS     r7,r7,r7
;;;244    					d2=sqrt(tem1+tem2);//得到3,4的距离
0004c2  19f0              ADDS     r0,r6,r7
0004c4  f7fffffe          BL       __aeabi_ui2d
0004c8  4604              MOV      r4,r0
0004ca  f7fffffe          BL       sqrt
0004ce  e9cd0100          STRD     r0,r1,[sp,#0]
0004d2  f7fffffe          BL       __aeabi_d2uiz
0004d6  fa1ffa80          UXTH     r10,r0
;;;245    					fac=(float)d1/d2;
0004da  4650              MOV      r0,r10
0004dc  f7fffffe          BL       __aeabi_ui2f
0004e0  4604              MOV      r4,r0
0004e2  4648              MOV      r0,r9
0004e4  f7fffffe          BL       __aeabi_ui2f
0004e8  4605              MOV      r5,r0
0004ea  4621              MOV      r1,r4
0004ec  f7fffffe          BL       __aeabi_fdiv
0004f0  9002              STR      r0,[sp,#8]
;;;246    					if(fac<0.95||fac>1.05||d1==0||d2==0)//不合格
0004f2  9802              LDR      r0,[sp,#8]
0004f4  f7fffffe          BL       __aeabi_f2d
0004f8  4604              MOV      r4,r0
0004fa  f04f3266          MOV      r2,#0x66666666
0004fe  4bee              LDR      r3,|L1.2232|
000500  f7fffffe          BL       __aeabi_cdcmple
000504  d30e              BCC      |L1.1316|
000506  9802              LDR      r0,[sp,#8]
000508  f7fffffe          BL       __aeabi_f2d
00050c  4604              MOV      r4,r0
00050e  4aeb              LDR      r2,|L1.2236|
000510  4beb              LDR      r3,|L1.2240|
000512  f7fffffe          BL       __aeabi_cdrcmple
000516  d305              BCC      |L1.1316|
000518  f1b90f00          CMP      r9,#0
00051c  d002              BEQ      |L1.1316|
00051e  f1ba0f00          CMP      r10,#0
000522  d10a              BNE      |L1.1338|
                  |L1.1316|
;;;247    					{
;;;248    						cnt=0;
000524  f04f0800          MOV      r8,#0
;;;249    						LCD_Clear(White);//清屏 
000528  f64f70ff          MOV      r0,#0xffff
00052c  f7fffffe          BL       LCD_Clear
;;;250    						Drow_Touch_Point(20,20);
000530  2114              MOVS     r1,#0x14
000532  4608              MOV      r0,r1
000534  f7fffffe          BL       Drow_Touch_Point
;;;251    						continue;
000538  e145              B        |L1.1990|
                  |L1.1338|
;;;252    					}
;;;253    					tem1=abs(pos_temp[0][0]-pos_temp[2][0]);//x1-x3
00053a  f8bd100c          LDRH     r1,[sp,#0xc]
00053e  f8bd2014          LDRH     r2,[sp,#0x14]
000542  1a88              SUBS     r0,r1,r2
000544  d401              BMI      |L1.1354|
000546  4601              MOV      r1,r0
000548  e000              B        |L1.1356|
                  |L1.1354|
00054a  4241              RSBS     r1,r0,#0
                  |L1.1356|
00054c  460e              MOV      r6,r1
;;;254    					tem2=abs(pos_temp[0][1]-pos_temp[2][1]);//y1-y3
00054e  f8bd200e          LDRH     r2,[sp,#0xe]
000552  f8bd1016          LDRH     r1,[sp,#0x16]
000556  1a50              SUBS     r0,r2,r1
000558  d401              BMI      |L1.1374|
00055a  4601              MOV      r1,r0
00055c  e000              B        |L1.1376|
                  |L1.1374|
00055e  4241              RSBS     r1,r0,#0
                  |L1.1376|
000560  460f              MOV      r7,r1
;;;255    					tem1*=tem1;
000562  4376              MULS     r6,r6,r6
;;;256    					tem2*=tem2;
000564  437f              MULS     r7,r7,r7
;;;257    					d1=sqrt(tem1+tem2);//得到1,3的距离
000566  19f0              ADDS     r0,r6,r7
000568  f7fffffe          BL       __aeabi_ui2d
00056c  e9cd0100          STRD     r0,r1,[sp,#0]
000570  f7fffffe          BL       sqrt
000574  4604              MOV      r4,r0
000576  f7fffffe          BL       __aeabi_d2uiz
00057a  fa1ff980          UXTH     r9,r0
;;;258    					
;;;259    					tem1=abs(pos_temp[1][0]-pos_temp[3][0]);//x2-x4
00057e  f8bd1010          LDRH     r1,[sp,#0x10]
000582  f8bd2018          LDRH     r2,[sp,#0x18]
000586  1a88              SUBS     r0,r1,r2
000588  d401              BMI      |L1.1422|
00058a  4601              MOV      r1,r0
00058c  e000              B        |L1.1424|
                  |L1.1422|
00058e  4241              RSBS     r1,r0,#0
                  |L1.1424|
000590  460e              MOV      r6,r1
;;;260    					tem2=abs(pos_temp[1][1]-pos_temp[3][1]);//y2-y4
000592  f8bd2012          LDRH     r2,[sp,#0x12]
000596  f8bd101a          LDRH     r1,[sp,#0x1a]
00059a  1a50              SUBS     r0,r2,r1
00059c  d401              BMI      |L1.1442|
00059e  4601              MOV      r1,r0
0005a0  e000              B        |L1.1444|
                  |L1.1442|
0005a2  4241              RSBS     r1,r0,#0
                  |L1.1444|
0005a4  460f              MOV      r7,r1
;;;261    					tem1*=tem1;
0005a6  4376              MULS     r6,r6,r6
;;;262    					tem2*=tem2;
0005a8  437f              MULS     r7,r7,r7
;;;263    					d2=sqrt(tem1+tem2);//得到2,4的距离
0005aa  19f0              ADDS     r0,r6,r7
0005ac  f7fffffe          BL       __aeabi_ui2d
0005b0  e9cd0100          STRD     r0,r1,[sp,#0]
0005b4  f7fffffe          BL       sqrt
0005b8  4604              MOV      r4,r0
0005ba  f7fffffe          BL       __aeabi_d2uiz
0005be  fa1ffa80          UXTH     r10,r0
;;;264    					fac=(float)d1/d2;
0005c2  4650              MOV      r0,r10
0005c4  f7fffffe          BL       __aeabi_ui2f
0005c8  4604              MOV      r4,r0
0005ca  4648              MOV      r0,r9
0005cc  f7fffffe          BL       __aeabi_ui2f
0005d0  4605              MOV      r5,r0
0005d2  4621              MOV      r1,r4
0005d4  f7fffffe          BL       __aeabi_fdiv
0005d8  9002              STR      r0,[sp,#8]
;;;265    					if(fac<0.95||fac>1.05)//不合格
0005da  9802              LDR      r0,[sp,#8]
0005dc  f7fffffe          BL       __aeabi_f2d
0005e0  4604              MOV      r4,r0
0005e2  f04f3266          MOV      r2,#0x66666666
0005e6  4bb4              LDR      r3,|L1.2232|
0005e8  f7fffffe          BL       __aeabi_cdcmple
0005ec  d308              BCC      |L1.1536|
0005ee  9802              LDR      r0,[sp,#8]
0005f0  f7fffffe          BL       __aeabi_f2d
0005f4  4604              MOV      r4,r0
0005f6  4ab1              LDR      r2,|L1.2236|
0005f8  4bb1              LDR      r3,|L1.2240|
0005fa  f7fffffe          BL       __aeabi_cdrcmple
0005fe  d20a              BCS      |L1.1558|
                  |L1.1536|
;;;266    					{
;;;267    						cnt=0;
000600  f04f0800          MOV      r8,#0
;;;268    						LCD_Clear(White);//清屏 
000604  f64f70ff          MOV      r0,#0xffff
000608  f7fffffe          BL       LCD_Clear
;;;269    						Drow_Touch_Point(20,20);
00060c  2114              MOVS     r1,#0x14
00060e  4608              MOV      r0,r1
000610  f7fffffe          BL       Drow_Touch_Point
;;;270    						continue;
000614  e0d7              B        |L1.1990|
                  |L1.1558|
;;;271    					}//正确了
;;;272    								   
;;;273    					//对角线相等
;;;274    					tem1=abs(pos_temp[1][0]-pos_temp[2][0]);//x1-x3
000616  f8bd1010          LDRH     r1,[sp,#0x10]
00061a  f8bd2014          LDRH     r2,[sp,#0x14]
00061e  1a88              SUBS     r0,r1,r2
000620  d401              BMI      |L1.1574|
000622  4601              MOV      r1,r0
000624  e000              B        |L1.1576|
                  |L1.1574|
000626  4241              RSBS     r1,r0,#0
                  |L1.1576|
000628  460e              MOV      r6,r1
;;;275    					tem2=abs(pos_temp[1][1]-pos_temp[2][1]);//y1-y3
00062a  f8bd2012          LDRH     r2,[sp,#0x12]
00062e  f8bd1016          LDRH     r1,[sp,#0x16]
000632  1a50              SUBS     r0,r2,r1
000634  d401              BMI      |L1.1594|
000636  4601              MOV      r1,r0
000638  e000              B        |L1.1596|
                  |L1.1594|
00063a  4241              RSBS     r1,r0,#0
                  |L1.1596|
00063c  460f              MOV      r7,r1
;;;276    					tem1*=tem1;
00063e  4376              MULS     r6,r6,r6
;;;277    					tem2*=tem2;
000640  437f              MULS     r7,r7,r7
;;;278    					d1=sqrt(tem1+tem2);//得到1,4的距离
000642  19f0              ADDS     r0,r6,r7
000644  f7fffffe          BL       __aeabi_ui2d
000648  4604              MOV      r4,r0
00064a  f7fffffe          BL       sqrt
00064e  e9cd0100          STRD     r0,r1,[sp,#0]
000652  f7fffffe          BL       __aeabi_d2uiz
000656  fa1ff980          UXTH     r9,r0
;;;279    	
;;;280    					tem1=abs(pos_temp[0][0]-pos_temp[3][0]);//x2-x4
00065a  f8bd100c          LDRH     r1,[sp,#0xc]
00065e  f8bd2018          LDRH     r2,[sp,#0x18]
000662  1a88              SUBS     r0,r1,r2
000664  d401              BMI      |L1.1642|
000666  4601              MOV      r1,r0
000668  e000              B        |L1.1644|
                  |L1.1642|
00066a  4241              RSBS     r1,r0,#0
                  |L1.1644|
00066c  460e              MOV      r6,r1
;;;281    					tem2=abs(pos_temp[0][1]-pos_temp[3][1]);//y2-y4
00066e  f8bd200e          LDRH     r2,[sp,#0xe]
000672  f8bd101a          LDRH     r1,[sp,#0x1a]
000676  1a50              SUBS     r0,r2,r1
000678  d401              BMI      |L1.1662|
00067a  4601              MOV      r1,r0
00067c  e000              B        |L1.1664|
                  |L1.1662|
00067e  4241              RSBS     r1,r0,#0
                  |L1.1664|
000680  460f              MOV      r7,r1
;;;282    					tem1*=tem1;
000682  4376              MULS     r6,r6,r6
;;;283    					tem2*=tem2;
000684  437f              MULS     r7,r7,r7
;;;284    					d2=sqrt(tem1+tem2);//得到2,3的距离
000686  19f0              ADDS     r0,r6,r7
000688  f7fffffe          BL       __aeabi_ui2d
00068c  4604              MOV      r4,r0
00068e  f7fffffe          BL       sqrt
000692  e9cd0100          STRD     r0,r1,[sp,#0]
000696  f7fffffe          BL       __aeabi_d2uiz
00069a  fa1ffa80          UXTH     r10,r0
;;;285    					fac=(float)d1/d2;
00069e  4650              MOV      r0,r10
0006a0  f7fffffe          BL       __aeabi_ui2f
0006a4  4604              MOV      r4,r0
0006a6  4648              MOV      r0,r9
0006a8  f7fffffe          BL       __aeabi_ui2f
0006ac  4605              MOV      r5,r0
0006ae  4621              MOV      r1,r4
0006b0  f7fffffe          BL       __aeabi_fdiv
0006b4  9002              STR      r0,[sp,#8]
;;;286    					if(fac<0.95||fac>1.05)//不合格
0006b6  9802              LDR      r0,[sp,#8]
0006b8  f7fffffe          BL       __aeabi_f2d
0006bc  4604              MOV      r4,r0
0006be  f04f3266          MOV      r2,#0x66666666
0006c2  4b7d              LDR      r3,|L1.2232|
0006c4  f7fffffe          BL       __aeabi_cdcmple
0006c8  d308              BCC      |L1.1756|
0006ca  9802              LDR      r0,[sp,#8]
0006cc  f7fffffe          BL       __aeabi_f2d
0006d0  4604              MOV      r4,r0
0006d2  4a7a              LDR      r2,|L1.2236|
0006d4  4b7a              LDR      r3,|L1.2240|
0006d6  f7fffffe          BL       __aeabi_cdrcmple
0006da  d20a              BCS      |L1.1778|
                  |L1.1756|
;;;287    					{
;;;288    						cnt=0;
0006dc  f04f0800          MOV      r8,#0
;;;289    						LCD_Clear(White);//清屏 
0006e0  f64f70ff          MOV      r0,#0xffff
0006e4  f7fffffe          BL       LCD_Clear
;;;290    						Drow_Touch_Point(20,20);
0006e8  2114              MOVS     r1,#0x14
0006ea  4608              MOV      r0,r1
0006ec  f7fffffe          BL       Drow_Touch_Point
;;;291    						continue;
0006f0  e069              B        |L1.1990|
                  |L1.1778|
;;;292    					}//正确了
;;;293    					//计算结果
;;;294    					Pen_Point.xfac=(float)200/(pos_temp[1][0]-pos_temp[0][0]);//得到xfac		 
0006f2  f8bd1010          LDRH     r1,[sp,#0x10]
0006f6  f8bd200c          LDRH     r2,[sp,#0xc]
0006fa  1a88              SUBS     r0,r1,r2
0006fc  f7fffffe          BL       __aeabi_i2f
000700  4604              MOV      r4,r0
000702  4621              MOV      r1,r4
000704  486f              LDR      r0,|L1.2244|
000706  f7fffffe          BL       __aeabi_fdiv
00070a  496f              LDR      r1,|L1.2248|
00070c  60c8              STR      r0,[r1,#0xc]  ; Pen_Point
;;;295    					Pen_Point.xoff=(240-Pen_Point.xfac*(pos_temp[1][0]+pos_temp[0][0]))/2;//得到xoff
00070e  f8bd1010          LDRH     r1,[sp,#0x10]
000712  f8bd200c          LDRH     r2,[sp,#0xc]
000716  1888              ADDS     r0,r1,r2
000718  f7fffffe          BL       __aeabi_i2f
00071c  9001              STR      r0,[sp,#4]
00071e  486a              LDR      r0,|L1.2248|
000720  68c1              LDR      r1,[r0,#0xc]  ; Pen_Point
000722  9801              LDR      r0,[sp,#4]
000724  f7fffffe          BL       __aeabi_fmul
000728  4683              MOV      r11,r0
00072a  4968              LDR      r1,|L1.2252|
00072c  f7fffffe          BL       __aeabi_frsub
000730  4605              MOV      r5,r0
000732  f04f4180          MOV      r1,#0x40000000
000736  f7fffffe          BL       __aeabi_fdiv
00073a  4604              MOV      r4,r0
00073c  f7fffffe          BL       __aeabi_f2iz
000740  b200              SXTH     r0,r0
000742  4961              LDR      r1,|L1.2248|
000744  8288              STRH     r0,[r1,#0x14]
;;;296    						  
;;;297    					Pen_Point.yfac=(float)280/(pos_temp[2][1]-pos_temp[0][1]);//得到yfac
000746  f8bd1016          LDRH     r1,[sp,#0x16]
00074a  f8bd200e          LDRH     r2,[sp,#0xe]
00074e  1a88              SUBS     r0,r1,r2
000750  f7fffffe          BL       __aeabi_i2f
000754  4604              MOV      r4,r0
000756  4621              MOV      r1,r4
000758  485d              LDR      r0,|L1.2256|
00075a  f7fffffe          BL       __aeabi_fdiv
00075e  495a              LDR      r1,|L1.2248|
000760  6108              STR      r0,[r1,#0x10]  ; Pen_Point
;;;298    					Pen_Point.yoff=(320-Pen_Point.yfac*(pos_temp[2][1]+pos_temp[0][1]))/2;//得到yoff  
000762  f8bd1016          LDRH     r1,[sp,#0x16]
000766  f8bd200e          LDRH     r2,[sp,#0xe]
00076a  1888              ADDS     r0,r1,r2
00076c  f7fffffe          BL       __aeabi_i2f
000770  9001              STR      r0,[sp,#4]
000772  4855              LDR      r0,|L1.2248|
000774  6901              LDR      r1,[r0,#0x10]  ; Pen_Point
000776  9801              LDR      r0,[sp,#4]
000778  f7fffffe          BL       __aeabi_fmul
00077c  4683              MOV      r11,r0
00077e  4955              LDR      r1,|L1.2260|
000780  f7fffffe          BL       __aeabi_frsub
000784  4605              MOV      r5,r0
000786  f04f4180          MOV      r1,#0x40000000
00078a  f7fffffe          BL       __aeabi_fdiv
00078e  4604              MOV      r4,r0
000790  f7fffffe          BL       __aeabi_f2iz
000794  b200              SXTH     r0,r0
000796  494c              LDR      r1,|L1.2248|
000798  82c8              STRH     r0,[r1,#0x16]
;;;299    //					POINT_COLOR=BLUE;
;;;300    					LCD_Clear(White);//清屏
00079a  f64f70ff          MOV      r0,#0xffff
00079e  f7fffffe          BL       LCD_Clear
;;;301    					LCD_DisplayStringLine(35,"Touch Screen Adjust OK!",Red,Blue);//校正完成
0007a2  231f              MOVS     r3,#0x1f
0007a4  02da              LSLS     r2,r3,#11
0007a6  a14c              ADR      r1,|L1.2264|
0007a8  2023              MOVS     r0,#0x23
0007aa  f7fffffe          BL       LCD_DisplayStringLine
;;;302    					Delay(20);
0007ae  2014              MOVS     r0,#0x14
0007b0  f7fffffe          BL       Delay
;;;303    					LCD_Clear(Magenta);//清屏   
0007b4  f64f001f          MOV      r0,#0xf81f
0007b8  f7fffffe          BL       LCD_Clear
;;;304    					return;//校正完成				 
;;;305    			}
;;;306    		}
;;;307    	} 
;;;308    }
0007bc  b007              ADD      sp,sp,#0x1c
0007be  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.1986|
0007c2  bf00              NOP                            ;223
                  |L1.1988|
0007c4  bf00              NOP                            ;251
                  |L1.1990|
0007c6  e5f9              B        |L1.956|
;;;309    //触摸屏初始化
                          ENDP

                  Touch_Init PROC
;;;310    void Touch_Init(void)
0007c8  b510              PUSH     {r4,lr}
;;;311    {
;;;312        Touch_Gpio_Init();
0007ca  f7fffffe          BL       Touch_Gpio_Init
;;;313    	TouchSPIx_Init();
0007ce  f7fffffe          BL       TouchSPIx_Init
;;;314    	//NVIC_Configuration();
;;;315    	//TOUCH_EXTI_Configuration();
;;;316    
;;;317    	//Touch_Adjust();
;;;318    }
0007d2  bd10              POP      {r4,pc}
;;;319    /*****************************************************************************
                          ENDP

                  Touch_IRQ PROC
;;;324    *****************************************************************************/
;;;325    void Touch_IRQ(void)
0007d4  b510              PUSH     {r4,lr}
;;;326    {
;;;327    	//u16 i;
;;;328      	if(EXTI_GetITStatus(TOUCH_IRQ_GPIO_Pin) != RESET)
0007d6  2080              MOVS     r0,#0x80
0007d8  f7fffffe          BL       EXTI_GetITStatus
0007dc  b128              CBZ      r0,|L1.2026|
;;;329    	{
;;;330    		//if(Read_TP_Once() == 1)
;;;331    		Pen_Point.Key_Sta=Key_Down;//按键按下 
0007de  2001              MOVS     r0,#1
0007e0  4939              LDR      r1,|L1.2248|
0007e2  7208              STRB     r0,[r1,#8]
;;;332    		EXTI_ClearITPendingBit(TOUCH_IRQ_GPIO_Pin);	 //清楚中断挂起位			 		  				 
0007e4  2080              MOVS     r0,#0x80
0007e6  f7fffffe          BL       EXTI_ClearITPendingBit
                  |L1.2026|
;;;333    	}
;;;334    }
0007ea  bd10              POP      {r4,pc}
;;;335    
                          ENDP

                  Convert_Pos PROC
;;;417    //根据触摸屏的校准参数来决定转换后的结果,保存在X0,Y0中
;;;418    void Convert_Pos(void)
0007ec  e92d41f0          PUSH     {r4-r8,lr}
;;;419    {		 	  
;;;420    	if(Read_ADS2(&Pen_Point.X,&Pen_Point.Y))
0007f0  4935              LDR      r1,|L1.2248|
0007f2  1d89              ADDS     r1,r1,#6
0007f4  1e88              SUBS     r0,r1,#2
0007f6  f7fffffe          BL       Read_ADS2
0007fa  b380              CBZ      r0,|L1.2142|
;;;421    	{
;;;422    		Pen_Point.X0=Pen_Point.xfac*Pen_Point.X+Pen_Point.xoff;
0007fc  4932              LDR      r1,|L1.2248|
0007fe  f9b10014          LDRSH    r0,[r1,#0x14]  ; Pen_Point
000802  f7fffffe          BL       __aeabi_i2f
000806  4606              MOV      r6,r0
000808  492f              LDR      r1,|L1.2248|
00080a  8888              LDRH     r0,[r1,#4]  ; Pen_Point
00080c  f7fffffe          BL       __aeabi_ui2f
000810  4607              MOV      r7,r0
000812  482d              LDR      r0,|L1.2248|
000814  68c1              LDR      r1,[r0,#0xc]  ; Pen_Point
000816  4638              MOV      r0,r7
000818  f7fffffe          BL       __aeabi_fmul
00081c  4605              MOV      r5,r0
00081e  4631              MOV      r1,r6
000820  f7fffffe          BL       __aeabi_fadd
000824  4604              MOV      r4,r0
000826  f7fffffe          BL       __aeabi_f2uiz
00082a  4927              LDR      r1,|L1.2248|
00082c  8008              STRH     r0,[r1,#0]
;;;423    		Pen_Point.Y0=Pen_Point.yfac*Pen_Point.Y+Pen_Point.yoff;  
00082e  f9b10016          LDRSH    r0,[r1,#0x16]  ; Pen_Point
000832  f7fffffe          BL       __aeabi_i2f
000836  4606              MOV      r6,r0
000838  4923              LDR      r1,|L1.2248|
00083a  88c8              LDRH     r0,[r1,#6]  ; Pen_Point
00083c  f7fffffe          BL       __aeabi_ui2f
000840  4607              MOV      r7,r0
000842  4821              LDR      r0,|L1.2248|
000844  6901              LDR      r1,[r0,#0x10]  ; Pen_Point
000846  4638              MOV      r0,r7
000848  f7fffffe          BL       __aeabi_fmul
00084c  4605              MOV      r5,r0
00084e  4631              MOV      r1,r6
000850  f7fffffe          BL       __aeabi_fadd
000854  4604              MOV      r4,r0
000856  f7fffffe          BL       __aeabi_f2uiz
00085a  491b              LDR      r1,|L1.2248|
00085c  8048              STRH     r0,[r1,#2]
                  |L1.2142|
;;;424    	}
;;;425    }
00085e  e8bd81f0          POP      {r4-r8,pc}
;;;426    
                          ENDP

                  Refreshes_Screen PROC
;;;432    *****************************************************************************/
;;;433    void Refreshes_Screen(void)
000862  b510              PUSH     {r4,lr}
;;;434    {
;;;435    	LCD_Clear(White);//清屏  
000864  f64f70ff          MOV      r0,#0xffff
000868  f7fffffe          BL       LCD_Clear
;;;436    	WriteString(216,0,"RST",Red);
00086c  f44f4378          MOV      r3,#0xf800
000870  a21f              ADR      r2,|L1.2288|
000872  2100              MOVS     r1,#0
000874  20d8              MOVS     r0,#0xd8
000876  f7fffffe          BL       WriteString
;;;437    //  	POINT_COLOR=BLUE;//设置画笔蓝色 
;;;438    }
00087a  bd10              POP      {r4,pc}
;;;439    
                          ENDP

                  Draw_Big_Point PROC
;;;441    //2*2的点			   
;;;442    void Draw_Big_Point(uint8_t x,uint16_t y)
00087c  b570              PUSH     {r4-r6,lr}
;;;443    {	    
00087e  4605              MOV      r5,r0
000880  460c              MOV      r4,r1
;;;444    	LCD_SetPoint(x,y,Red);//中心点 
000882  f44f4278          MOV      r2,#0xf800
000886  4621              MOV      r1,r4
000888  4628              MOV      r0,r5
00088a  f7fffffe          BL       LCD_SetPoint
;;;445    	LCD_SetPoint(x+1,y,Red);
00088e  f44f4278          MOV      r2,#0xf800
000892  4621              MOV      r1,r4
000894  1c68              ADDS     r0,r5,#1
000896  f7fffffe          BL       LCD_SetPoint
;;;446    	LCD_SetPoint(x,y+1,Red);
00089a  f44f4278          MOV      r2,#0xf800
00089e  1c60              ADDS     r0,r4,#1
0008a0  b281              UXTH     r1,r0
0008a2  4628              MOV      r0,r5
0008a4  f7fffffe          BL       LCD_SetPoint
;;;447    	LCD_SetPoint(x+1,y+1,Red);	 	  	
0008a8  f44f4278          MOV      r2,#0xf800
0008ac  1c60              ADDS     r0,r4,#1
0008ae  b281              UXTH     r1,r0
0008b0  1c68              ADDS     r0,r5,#1
0008b2  f7fffffe          BL       LCD_SetPoint
;;;448    }
0008b6  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L1.2232|
                          DCD      0x3fee6666
                  |L1.2236|
                          DCD      0xcccccccd
                  |L1.2240|
                          DCD      0x3ff0cccc
                  |L1.2244|
                          DCD      0x43480000
                  |L1.2248|
                          DCD      Pen_Point
                  |L1.2252|
                          DCD      0x43700000
                  |L1.2256|
                          DCD      0x438c0000
                  |L1.2260|
                          DCD      0x43a00000
                  |L1.2264|
0008d8  546f7563          DCB      "Touch Screen Adjust OK!",0
0008dc  68205363
0008e0  7265656e
0008e4  2041646a
0008e8  75737420
0008ec  4f4b2100
                  |L1.2288|
0008f0  52535400          DCB      "RST",0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Pen_Point
                          %        24
